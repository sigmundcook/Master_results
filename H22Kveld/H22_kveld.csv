ext_inspera_questions_5_ext_inspera_candidateResponses_0_ext_inspera_response;ext_inspera_questions_6_ext_inspera_candidateResponses_0_ext_inspera_response;ext_inspera_questions_17_ext_inspera_candidateResponses_0_ext_inspera_response
"def sum_larger(numlist,n):
    summen = 0
    for tall in numlist:
        if tall>n:
            summen+=tall
    return summen
    
        ";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass>7:#ettersom n_pass gir sitteplasser utover f√∏rersete vil da denne settes til maks 7. er 8 med f√∏rer
            if wt>5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    else:
        if wt>3500:
            if wt<=12000:#tolker ikke over som at den kan v√¶re 12000 men ikke mer
                return ""N2""
            else:
                return ""N3""
        else:
            return ""N1""";"def sum_near_whole(A):
    svar=0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if i==0 and j==0: #sjekker kun rad og kolone 1 slik at jeg ikke indexerer utenfor mengden.
                if A[i+1,j]==int(A[i+1,j]) or A[i,j+1]==int(A[i,j+1]):
                    svar+=A[i][j]
                    
            elif i==0 and j!=0 and j!=(len(A[i])-1): #sjekker for rad 1 og kolonnene i midten.
                if A[i+1,j]==int(A[i+1,j]) or A[i,j+1]==int(A[i,j+1]) or A[i,j-1]==int(A[i,j-1]):
                    svar+=A[i][j]
                    
            elif i==0 and j==(len(A[i])-1):#sjekker for rad 1 og siste kolonne.
                if A[i+1,j]==int(A[i+1,j]) or A[i,j-1]==int(A[i,j-1]):
                    svar+=A[i][j]
                    
            elif i!=0 and i!=len(A)-1 and j!=0 and j!=(len(A[i])-1):#sjekker alle rader og kolonner som ikke er i endene
                if A[i+1,j]==int(A[i+1,j]) or A[i-1,j]==int(A[i-1,j]) or A[i,j+1]==int(A[i,j+1]) or A[i,j-1]==int(A[i,j-1]):
                    svar+=A[i][j]
                    
            elif i==(len(A)-1) and j==0: #sjekker kun siste rad og kolone 1 slik at jeg ikke indexerer utenfor mengden.
                if A[i-1,j]==int(A[i-1,j]) or A[i,j+1]==int(A[i,j+1]):
                    svar+=A[i][j]
                    
            elif i==(len(A)-1) and j!=0 and j!=(len(A[i])-1): #sjekker for siste rad og kolonnene i midten.
                if A[i-1,j]==int(A[i-1,j]) or A[i,j+1]==int(A[i,j+1]) or A[i,j-1]==int(A[i,j-1]):
                    svar+=A[i][j]
                    
            elif i==(len(A)-1) and j==(len(A[i])-1):#sjekker for siste rad og siste kolonne.
                if A[i-1,j]==int(A[i-1,j]) or A[i,j-1]==int(A[i,j-1]):
                    svar+=A[i][j]
                    
            #mulig jeg kunne klart med med kun en if setning, men var redd for syntax-feil da jeg kanskje ville ha indexert utenfor mengden. Ved vanlig progging ville jeg ha begynt med √• se hva jeg f√•r, og dermed kodet meg vidre, slik at koden ble kortere og mer ryddig. Denne metodet skal virke slik jeg ser det, s√• sant det ikke er noe feil i tegnsetting.
    return svar
                "
"
def sum_larger(numlist,n):
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
    return summen";"
def car_type(n_pass, wt, person):
    
    if person == True:
        
        if n_pass <= 8:
            return ""M1""
            
        if n_pass > 8:
            if wt <= 5000:
                return ""M2""
            else:
                return ""M3""
                
    if person == False:
        if wt <= 3500:
            return ""N1""
        elif (wt > 3500) and (wt <= 12000):
            return ""N2""
        else:
            return ""N3""";"
def sum_near_whole(A):
    summen = 0
    lengde = len(A)

    #sjekker for alle hj√∏rner i et 2d array
    if A[0,1] == int(A[0,1]) or A[1,0] == int(A[1,0]):
        summen += A[0,0]
    if A[0,-2] == int(A[0,-2]) or A[1,-1] == int(A[1,-1]):
        summen += A[0,-1]
    if A[-2,0] == int(A[-2,0]) or A[-1,1] == int(A[-1,1]):
        summen += A[-1,0]
    if A[-1,-2] == int(A[-1,-2]) or A[-2,-1] == int(A[-2,-1]):
        summen += A[-1,-1]
    
    # for l√∏kke for resterende √∏verste rad
    for i in range(1,lengde-1):
        if A[0,i-1] == int(A[0,i-1]) or A[0,i+1] == int(A[0,i+1]) or A[1,i] == int(A[1,i]):
            summen += A[0,i]
    
    
    #for l√∏kke for resterende nedrerste rad
    for j in range(1,lengde-1):
        if A[-1,i-1] == int(A[-1,i-1]) or A[-1,i+1] == int(A[-1,i+1]) or A[-2,i] == int(A[-2,i]):
            summen += A[-1,i]
    
    #sjekker sider til h√∏yre
    for m in range(1,lengde-1):
        if A[m-1,0] == int(A[m-1,0]) or A[m+1,0] == int(A[m+1,0]) or A[m,1] == int(A[m,1]):
            summen += A[m,0]
    
    #sjekker sider til venstre
    for n in range(1,lengde-1):
        if A[n-1,-1] == int(A[n-1,-1]) or A[n+1,-1] == int(A[n+1,-1]) or A[n,-2] == int(A[n,-2])
        
    #generell sjekk for alle de elementene som ligger mellom fire andre elementer
    for k in range(1,lengde-1):
        for l in range(1,lengde-1):
            if (A[k,l-1] == int(A[k,l-1]) or A[k,l+1] == int(A[k,l+1]) or A[k-1,l] == int(A[k-1,l]) or A[k+1,l] == int(A[k+1,l])):
                summen += A[k,l]
            
    return summen
        
"
"def sum_larger(numlist, n):
    total = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            total += numlist[i]
            
    return total
            
        ";"def car_type(n_pass, wt,person):    #Antar at n_pass og wt alltid vil vere ein tallverdi, der wt er i kg, og at person er ein bool
    
    if person == True:
        if n_pass <= 7:   #<7 fordi n_pass inkluderer ikkje f√∏rersetet
            return ""M1""
            
        else:
            if wt <= 5000:
                return ""M2""
                
            else:
                return ""M3""
                
    else:       #Ettersom person er ein bool, s√• er det enten True, som dei over, eller False som n√•
        if wt <= 3500:
            return ""N1""
            
        if wt > 3500 and wt <= 12000:
            return ""N2""
            
        else:
            return ""N3""";"def sum_near_whole(A):          #Litt usikker p√• om oppg√•va vile at om det stod same tall to ulike plasser, om begge skulle bli                               #addert eller ikkje
    brukte_tall = []
    
    for i in range(len(A)):
        for j in range(len(A)):
            
            if len(A[i][j]) == 2:           #Antar eit heilt flyttall vil st√• . og ikkje .0
                brukte_tall.append(A[i+1][j])
                brukte_tall.append(A[i-1][j])
                brukte_tall.append(A[i][j+1])
                brukte_tall.append(A[i][j-1])
                
            
            
    brukte_tall = set(brukte_tall)
    tot = 0
    
    for i in len(brukte_tall):
        tot += brukte_tall[i]
                
    return tot"
"def sum_larger(numlist, n):
    sum=0 #starter med en 'tom' sum og legger til tall her etter hvert
    for i in numlist:#g√•r gjennom lista element for element
        if i>n:#sjekker om elementet er st√∏rre enn n
            sum+=i#hvis det er st√∏rre s√• legges det til i summen
    return sum#til slutt returneres hele summen etter at alle elementene i lista er sjekket";"car_type(n_pass, wt, person):
    if person==True: #sjekker for persontransport f√∏rst
        if n_pass<9: #sjekker om det er en personbil som har max 8 passasjerer
            return 'M1'
        elif (n_pass>9) and (wt<=5000): #sjekker for M2
            return 'M2'
        else:
            return 'M3' #hvis det er mer enn 8 passasjerer og den veier mer enn 5000 er det M3
    else: #Hvis person==False, alts√• sjekker jeg for varetransport
        if wt<=3500: #sjekker om vekten er under 3500 alts√• N1
            return 'N1'
        elif wt<=12000: #sjekker om den veier 3500-12000, siden de som veier under 3500 allerede er 'tatt' av betingelsen over
            return 'N2'
        else:
            return 'N3' #hvis den veier mer enn 3500 og mer enn 12000 blir det N3";"def sum_near_whole(A):
    summen=0 #starter med en 'tom' sum som jeg skal legge til i senere
    s=set()# et tomt set som jeg legger ting til i etter hvert. set sikrer at jeg ikke legger til samme tall flere ganger. Skal summere settet til slutt
    
    for y in range(len(A)): #for hver linje i arrayet
        for x in range(len(A[y])): #g√•r gjennom hvert tall i hver linje
        
             if A[y,x]==int(A[y,x]): #sjekker om tallet er likt heltallet, det er tilfellet hvis desimalen er 0
             
#her skal jeg legge nabotallene inn i s, men ettersom tallene 'ytterst' i arrayet ikke vil ha alle 4 nabotallene s√• sjekker jeg for hvert enkelt nabotall om det kan legges til i s eller om det utl√∏ser en IndexError
                try:
                    s=s.add(A[y,x-1])   
                except IndexError: #Hvis nabotallet ikke finnes i arrayet legger jeg til 0, siden det ikke p√•virker summen
                    s=s.add(0)
                try:
                    s=s.add([y,x+1])
                except IndexError:
                    s=s.add(0)
                try:
                    s=s.add(A[y-1,x])
                except IndexError:
                    s=s.add(0)
                try:
                    s=s.add(A[y+1,x])
                except IndexError:
                    s=s.add(0)
    for element in s:
        summen+=element #adderer alle elementene i settet, alts√• alle nabotall, men ingen tall blir lagt til mer enn 1 gang
    return summen
    "
"def sum_larger(numlist,n):
    summen = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            summen += numlist[i]
        else:
            summen = summen
    return summen";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass == 8:
            return ""M1""
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt > 3500 and wt <= 12000:
            return ""N2""
        else:
            return ""N3""
        ";"def sum_near_whole(A):
    summen = 0
    for i in A:
        for x in i:
            if A[i] == int:
               
    return summen       
            
    
    
bruke kommandoen set() for √• ikke f√• flere tall mer enn to ganger.
N√•r jeg har funnet ut hvilke indekser som skal bli summert og returnert, adderer jeg de sammen med summen += indeksen
for s√• √• returnere indeksen
 "
"def sum_larger(numlist,n):
    
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
        else:
            summen += 0
    
    return summen
    
    print(sum_larger(numlist,n))";"def car_type(n_pass,wt,person):
    if person == persontransport and n_pass <= 8:
        return ""M1""
    
    if person == persontransport and n_pass > 8:
        if wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    
    if person == varetransport:
        if wt <= 3500:
            return ""N1""
        
        if wt > 3500 and wt <= 12000:
            return ""N2""
            
        else:
            return ""N3""
            
    print(car_type(n_pass,wt,person))";"def sum_near_whole(A):
    
    
    return summen(tall_nabo_til_heltall)"
"def sum_larger(numlist, n):
    sum = 0
    for i in len(numlist):
        if i > n:
            sum += i
        else:
            sum += 0
    return sum
   
        ";"def car_type(n_pass, wt, person):
    persontransport = 1
    varetransport = 0
    if person = True:
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt != 5000:
            return ""M2""
        else n_pass > 8 and wt > 5000:
            return ""M3""
    else: 
        if wt > 3500:
            return ""N1""
        elif wt > 12000 and wt > 3500:
            return ""N2""
        else: 
            return ""N3""
            ";"import numpy as np

def sum_near_whole(A):
    sum = 0
    for i in np.array(A):
        if i //1 == i:
            "
"def sum_lager(numlist,n):
    tempSum=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            tempsum+=numlist[i]
    return tempSum
    
";"def car_type(n_pass,wt,person):
    if wt==True:
        if n_pass<=8:
            return ""M1""
        else:
            if wt<=5000:
                return ""M2""
            else:
                return ""M3""
    else:
        if wt>12000:
            return ""N3""
        elif wt>3500:
            return ""N2""
        else: 
            return ""N1""
        
        ";"def sum_near_whole(A):
    sumtotal=0
    temp_set=set() #lager et tumt sett til √• lagre positionenee til verdieene som skla med i summen. vil ta h√•nd om duplikater 
    
    for i in range(len(A)): #iterer gjennom matrisens rader 
        for j in range(len(A[i])): #iterere gjennom kolonnnene. 
            temp_array_o=[] #initisierer tomme arrayer som skal nullstilles hver iterasjon 
            temp_array_u=[]
            temp_array_l=[]
            temp_array_r=[]
            if A[i][j]==int(A[i][j]):#sjekker at det er heltall 
                
                if i==0:#langs √∏verste rad 
                    if j==0: #i √∏verste hj√∏rne til venstre 
                        temp_array_r=[i,j+1]
                        temp_array_u=[i+1,j]
                        temp_set.add(temp_array_r)
                        temp_set.add(temp_array_u)
                    elif j==len(A[i]): #I √∏verste hj√∏rne til h√∏yre 
                        temp_array_l=[i,j-1]
                        temp_array_u=[i+1,j]
                        temp_set.add(temp_array_l)
                        temp_set.add(temp_array_u)
                    else: #resterende plasser langs √∏verste rad 
                        temp_array_r=[i,j+1]
                        temp_array_l=[i,j-1]
                        temp_array_u=[i+1,j]
                        temp_set.add(temp_array_r)
                        temp_set.add(temp_array_u)
                        temp_set.add(temp_array_l)
                
                elif i==len(A):#langs nederste rad 
                    if j==0: #Nederst til venstre  
                        temp_array_r=[i,j+1]
                        temp_array_o=[i-1,j]
                        temp_set.add(temp_array_r)
                        temp_set.add(temp_array_o)
                    elif j==len(A[i]): #nederst til h√∏yre 
                        temp_array_l=[i,j-1]
                        temp_array_o=[i-1,j]
                        temp_set.add(temp_array_l)
                        temp_set.add(temp_array_o)
                    else: #kunn langs nederste rad 
                        temp_array_r=[i,j+1]
                        temp_array_l=[i,j-1]
                        temp_array_o=[i-1,j]
                        temp_set.add(temp_array_r)
                        temp_set.add(temp_array_o)
                        temp_set.add(temp_array_l)
                    
                elif j==0: #langs venstre kant 
                    if i==0: #til venstre √∏vers  
                        temp_array_r=[i,j+1]
                        temp_array_u=[i+1,j]
                        temp_set.add(temp_array_r)
                        temp_set.add(temp_array_u)
                    elif i==len(A): #til venstre neders  
                        temp_array_l=[i,j-1]
                        temp_array_o=[i-1,j]
                        temp_set.add(temp_array_l)
                        temp_set.add(temp_array_o)
                    else: #kunn langs venstre kolonne 
                        temp_array_r=[i,j+1]
                        temp_array_u=[i+1,j]
                        temp_array_o=[i-1,j]
                        temp_set.add(temp_array_r)
                        temp_set.add(temp_array_u)
                        temp_set.add(temp_array_o)
                    
                
                elif j==len(A[i]): #langs h√∏yre kant 
                    if i==0: #til h√∏yre √∏verst  
                        temp_array_l=[i,j-1]
                        temp_array_u=[i+1,j]
                        temp_set.add(temp_array_l)
                        temp_set.add(temp_array_u)
                    elif i==len(A): #til h√∏yre nederst  
                        temp_array_l=[i,j-1]
                        temp_array_o=[i-1,j]
                        temp_set.add(temp_array_l)
                        temp_set.add(temp_array_o)
                    else: #kunn langs h√∏yre kolonne 
                        temp_array_l=[i,j-1]
                        temp_array_u=[i+1,j]
                        temp_array_o=[i-1,j]
                        temp_set.add(temp_array_l)
                        temp_set.add(temp_array_u)
                        temp_set.add(temp_array_o)
                        
                else:#denne er for alle andre palseringer uten om kanten
                    temp_array_l=[i,j-1]
                    temp_array_u=[i+1,j]
                    temp_array_o=[i-1,j]
                    temp_array_r=[i,j+1]
                    temp_set.add(temp_array_l)
                    temp_set.add(temp_array_u)
                    temp_set.add(temp_array_o)
                    temp_set.add(temp_array_r)
    
    
    for k in range(len(temp_set)):#summerer bidrag fra alle instansene i settet
        sum_total+= A[temp_set[k][0]][temp_set[k][1]] 
    
    return sum_total
                    
                        
                
                    
                    
                
                "
"def sum_larger(numlist, n):
    result = 0
    for number in numlist:
        if number > n:
            result += number
    return result";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
        elif n_pass > 8 and wt > 5000:
            return ""M3""
    elif person == False:
        if wt <= 3500:
            return ""N1""
        elif 3500 < wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"def sum_near_whole(A):
    result = 0
    for i in range(1, len(A)):
        for j in range(1, len(i)):
            if float(int(A[i][j-1])/2) == float(A[i][j-1]/2):
                result += A[i][j]
            elif float(int(A[i][j+1])/2) == float(A[i][j+1]/2):
                result += A[i][j]
            elif float(int(A[i-1][j])/2) == float(A[i-1][j]/2):
                result += A[i][j]
            elif float(int(A[i+1][j])/2) == float(A[i+1][j]/2):
                result += A[i][j]
    return result"
"def sum_lagrer(numlist,n): 
    summasjon=[]
    for i in range(len(numlist)): 
        if numlist[i]>n: 
            summasjon.append(numlist[i])
    
    return sum(summasjon)
    
print(sum_lagrer(numlist,n)) 
";"def car_type(n_pass,wt,person): 
    
    
    if person=='persontransport': 
        person= True
    if person=='varetransport': 
        person=False
    
    if n_pass==8 and person==True: 
        print('M1')
    elif n_pass>8 and wt<5000 and person==True: 
        print('M2')
    elif n_pass>8 and wt>5000 and person==True: 
        print('M3')
    if person==False and wt<3500: 
        print('N1')
    elif person==False and 3500<wt<12000: 
        print('N2')
    elif person==False and wt>12000: 
        print('N3')
        
print(car_type(n_pass,wt,person))
    
    
    ";"import numpy as np
def sum_near_whole(A): 
    count= set()
    for i in range(len(A)): 
        for j in range(len(A[i])): 
            if str(A[i][j])[2]=='0' and j==0 and i==0:
                count= count.add(A[i][j+1])
                count= count.add(A[i+1][j])
            elif str(A[i][j])[2]=='0' and j==len(A[i]) and i==0: 
                count= count.add(A[i][j-1])
                count= count.add(A[i+1][j])
            elif str(A[i][j])[2]=='0' and j== 0 and i==len(A): 
                count.add(A[i][j+1])
                count.add(A[i-1][j])
            elif str(A[i][j])[2]=='0' and j==len(A[i]) and i==len(A): 
                count=count.add(A[i][j-1])
                count=count.add(A[i-1][j])
            elif str(A[i][j])[2]=='0' and j==0: 
                count= count.add(A[i+1][j])
                count= count.add(A[i-1][j])
                count= count.add(A[i][j+1])
            elif str(A[i][j])[2]=='0' and j==len(A[i]): 
                 count= count.add(A[i+1][j])
                 count= count.add(A[i-1][j])
                 count= count.add(A[i][j-1])
            elif str(A[i][j])[2]=='0' and i==0: 
                count= count.add(A[i][j+1])
                count= count.add(A[i][j-1])
                count= count.add(A[i+1][j])
            elif str(A[i][j])[2]=='0' and i==len(A): 
                 count= count.add(A[i][j+1])
                 count= count.add(A[i][j-1])
                 count= count.add(A[i-1][j])
            elif str(A[i][j])[2]=='0': 
                count= count.add(A[i][j+1])
                count= count.add(A[i][j-1])
                count= count.add(A[i+1][j])
                count= count.add(A[i-1][j])
    a=np.array(count)  
    b=np.sum(a)
    return (b)
    
#alle if setningene pr√∏ver √• dekke hele arrayet, der de 4 f√∏rste setningene dekker endepunktene p√• 2d listen, imens de 4 neste dekker de imellom hj√∏rnene og den siste dekker alle i midten av disse. count er et set som betyr at selv om verdiene legges til flere ganger vil det kun eksistere en av dem i settet. sikkert en mye lettere m√•te √• l√∏se dette p√• da. 


"
"def sum_larger(numlist, n):
    result = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            result += numlist[i]
    return result";"def car_type(n_pass, wt, person):
    if n_pass <= 7:
        if wt <= 3500:
            if person == True:
                return ""M1""
            else:
                return ""N1""
        elif wt <= 12000:
            return ""N2"" #Antar her at en personbil ikke veier over 3500kg, kan evt sjekkes med samme m√•te over
        else:
            return ""N3""
    else:
        if wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    
#Litt usikker p√• hva ""utover f√∏rersetet"" betyr s√• antar det betyr uten f√∏rersetet";"def sum_near_whole(A):
    total_sum = 0.0
    for rader in range(len(A)): #A[rader]
        under_linje = A[rader+1]
        over_linje = A[rader-1]
        for tall in range(len(rader)): #A[rader[tall]]
            if rader[tall[2]] == 0:
                try:
                    if (rader[(tall+2)[2]] or (rader[(tall-2)[2]]) != 0:
                        total_sum += rader[tall+1]
                        total_sum += rader[tall-1]
                    elif (rader[(tall+2)[2]] or (rader[(tall-2)[2]]) == 0:
                        total_sum += (rader[tall+1])/2
                        total_sum += (rader[tall-1])/2
                    elif (rader[(tall+2)[2]] and (rader[(tall-2)[2]]) == 0:
                        total_sum += (rader[tall+1])/3
                        total_sum += (rader[tall-1])/3
                    if (A[(rader+2)[tall[2]]]) or (A[(rader-2)[tall[2]]]) != 0:
                        total_sum += under_linje[tall]
                        total_sum += over_linje[tall]
                    elif (A[(rader+2)[tall[2]]]) or (A[(rader-2)[tall[2]]]) == 0:
                        total_sum += (under_linje[tall])/2
                        total_sum += (over_linje[tall])/2
                    elif (A[(rader+2)[tall[2]]]) and (A[(rader-2)[tall[2]]]) == 0:
                        total_sum += (under_linje[tall])/2
                        total_sum += (over_linje[tall])/2
    return total_sum"
"def sum_larger(numlist, n):
    #return sum([x for x in numlist if x > n])
    res = 0
    for x in numlist:
        if x > n:
            res += x
    return res";"def car_type(n_pass, wt, person):
    if person:
        if n_pass =< 8:
            return ""M1""
        if wt <= 5000:
            return ""M2""
        return ""M3""
        
    if wt > 12_000:
        return ""N3""
    if wt > 3500:
        return ""N2""
    # wt <= 3500
    return ""N1""";"def sum_near_whole(A):
    total_rows, total_cols = A.shape()
    coords_to_sum = set()
    for y, row in enumerate(A):
        for x, n in enumerate(row):
            if int(n) == n:
                adjacents = ((y-1,x), (y+1,x), (y, x-1), (y, x+1))
                for r, c in adjacents:
                    if r in range(0, total_rows) and c in range(0, total_cols):
                        coords_to_sum.add((r, c))
    
    return sum([A[r,c] for r, c in coords_to_sum])"
"def sum_larger(numlist, n):
    sum = 0
    for key in numlist:
        if key > n:
           sum += key
    return sum
    
";"def car_type(n_pass, wt, person):
    if 1 < n_pass =< 8 and person == True:
        return ""M1""
    elif n_pass > 8 and 0 < wt < 5000 and person == True:
        return ""M2""
    elif n_pass > 8 and wt > 5000 and person == True:
        return ""M3""
    
    elif person == False and 0 < wt < 3500:
        return ""N1""
    elif person == False and 3500 < wt < 12000:
        return ""N2""
    elif person == False and wt > 12000:
        return ""N3""
    else:
        return ""Feil input""";"import numpy as np


def sum_near_whole(A):
    sum = 0
    for key in A:
        sum2 = 0
        for key2 in key:
            if A[key] < 3:
               sum2 += key2
        sum += sum2
    return sum
    
## Forslag til l√∏sning, ettersom jeg ikke fikk til oppgaven: Hadde tenkt √• benytte to for-l√∏kker, den f√∏rste for √• hente ut de fire kolonnene i matrisen, og den andre for √• hente ut innholdet til de fire kolonnene. Etter det skulle jeg sjekke etter om tallenes lengde er over 3, ettersom hvis de er under det vil tallet mest sannsynlig v√¶re et heltall (=. Vi det var en funksjon for √• sjekke om tallet var flyttall eller ikke vil jeg ha benyttet den. 
        
        "
"def sum_larger(numlist, n):
    tall_st√∏rre = 0
    for i in numlist:
        if i > n:
            tall_st√∏rre += i
    return tall_st√∏rre
        ";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return 'M1'
        elif (n_pass >= 8 and wt <= 5000):
            return 'M2'
        else:
            return 'M3'
    else:
        if wt <= 3500:
            return 'N1'
        elif wt <= 12000:
            return 'N2'
        else:
            return 'N3'
    ";"def sum_near_whole(A):
    summen = []
    for i in A:
        for tall in i:
            tallets_indeks = i.index(tall) #henter ut indeksen til tallet
            if tall-int(tall) == 0.0: #sjekker om kommadelen = 0
                if (tallets_index == 0 or -1): #sjekker om det er endetallene
                    #om tid ville jeg her funnet en m√•te √• plukke ut tallene rundt med gyldig index
                else:
                    if i[tallets_indeks+1] not in summen:
                        summen.append(i[tallets_indeks+1]) #legger til tallet til h√∏yre
                        
                    if i[tallets_indeks-1] not in summen: 
                        summen.append(i[tallets_indeks-1]) #legger til tallet til venstre
                        
                    if (i+1)[tallets_indeks] not in summen:
                        summen.append(i+1)[tallets_indeks] #legger til tallet under
                    
                    if (i-1)[tallets_indeks] not in summen:
                        summen.append((i-1)[tallets_indeks]) #legger til tallet over

    return sum(summen)
                
                
                
                "
"def sum_larger(numlist,n):
    lst=[]
    for i in numlist:
        if i<n:
            lst.append(i)
    svar=sum(lst)
    return svar";"def car_type(n_pass,wt,person):
    if person==True:
        if n_pass<=8:
            return ""M1""
        elif n_pass>8 and wt<=5000:
            return ""M2""
        elif n_pass>8 and wt>5000:
            return ""M3""
        else:
            return ""ugyldig input""
    elif person==False:
        if wt<=3500:
            return ""N1""
        elif wt>3500 and wt<=12000:
            return ""N2""
        elif wt>12000:
            return ""N3""
        else:
            return ""ugyldig input""
    
    else:
        return ""ugyldig input""";"import numpy as np
def sum_near_whole(A):
    list=[]
    √Ö=A
    for a in range(len(A)):
        for i in range(len(A[a])):
            if int((A[a][i])*10)==(int(A[a][i]))*10:
                if a>=1 and a+2<=len(A):
                    list.append(√Ö[a-1][i])
                    √Ö[i-1][i]=0
                if a+1<=len(A):
                    list.append(√Ö[a+1][i])
                    √Ö[a+1][i]=0
                if i+2<=len(A[a]):
                    list.append(√Ö[a][i+1])
                    √Ö[a][i+1]=0
                if i>0:
                    list.append(√Ö[a][i-1])
                    √Ö[a][i-1]=0
                √Ö[a][i]=0
    return sum(list)
    "
"def sum_larger(numlist,n):
    storetall = [] #definerer en tom liste som skal legges til i
    sum = 0 
    for i in range(len(numlist)): #kj√∏rer gjennom lista, sammenlikner hvert element med n
        if numlist[i] > n:
            storetall.append(numlist[i])
    for i in range(len(storetall)): #adderer tallene fra lista storetall
        sum+=int(storetall[i])
    
    return sum";"def car_type(n_pass,wt,person):
    type = """"
    #persontransport
    if n_pass<=8 and person ==True:  #sjekker for M1 kriterier
        type = ""M1""
    elif wt<=5000 and n_pass>8 and person == True: #sjekker for M2 kriterier
        type = ""M2""
    elif person == True and n_pass>8: #sjekker for M3 kriterier
        type = ""M3""
        
    #varetransport
    if wt<=3500 and person == False: #sjekker kriterier for N1. ny If-sekvens, s√• alle verdier kj√∏res gjennom denne, selv om de var oppfylt i M-sjekken. 
        type = ""N1"" 
    elif wt>3500 and wt <=12000 and person == False:
        type =""N2""
    elif wt > 12000 and person == False:
        type = ""N3""
        
    else:
        type = ""Dine oppgitte spesifikasjoner passer ikke overens med dagens regelverk.""
    return type 

    
        ";"import numpy as np
def sum_near_whole(A):
    tall = []
    for i in range(len(A)):
        for j in range(len(A[i])) #antar at arrayet best√•r del-lister med like mange elementer 
            if j>=1 and i>=1: #sjekker at vi ikke er ved venstre ende eller √∏vre rad. Dette ville gitt index out of range error
                if (A[i][j-1])% 1 == 0 or (A[i-1][j])% 1 == 0: #sjekker tallene til venstre og ovenfor. kun et helt tall % 1 vil gi 0.
                    if A[i][j] not in tall: #sjekker at tallet ikke finnes i lista fra f√∏r
                        tall.append(A[i][j]) #legger til det aktuelle tallet i listen ""tall"" 
            elif i<=len(A)-1 and j<=len(A[i])-1: #utf√∏rer samme kodeblokk som over, men sjekker her at vi ikke befinner oss ved h√∏yre eller nedre kant. 
                if (A[i][j+1])% 1 == 0 or (A[i+1][j])% 1 == 0:
                    if A[i][j] not in tall:
                        tall.append(A[i][j]) 
    tallarray = np.array(tall) #gj√∏r om lista til array for √• finne sum med np.sum
    summen = np.sum(tallarray)
    return summen 
    "
"def sum_larger(numlist,n):
    
    result = 0 #Opretter en variabel lik 0, dvs. en integrer
    
    for num in numlist: #itererer gjennom listen, for hver nummer i listen.
    
        if num > n: #hvis tallet er st√∏rre enn n
        
            result += num #s√• skal den legges til i variabel result
            
    return result #returnerer summen i som har blit lagt til i variabelen result";"def car_type(n_pass, wt, person):
    
    if n_pass > 8 and person == True: #Hvis ant. plasser st√∏rre enn 8 og det transporteres personer
        if wt > 5000: #hvis vekten er st√∏rre enn 5000kg
            return ""M3"" #s√• er det en buss M3
            
        elif wt <= 5000: #hvis vekter er mindre eller lik 5000kg
            return ""M2"" #s√• er det en buss M2
            
    elif n_pass <= 8 and person == True: #Hvis ant. plasser er mindre eller lik 8 og det transporteres personer
        return ""M1"" #s√• er det en personbil M1
        
    elif person == False:# Hvis det ikke transporteres personer, m√• det v√¶re varetransport
        if wt <= 3500: #hvis vekten er mindre eller lik 3500
            return ""N1"" #s√• er det varebil N1
            
        elif 3500 < wt <= 12000: #hvis vekten er over 3500kg og mindre eller lik 12000kg. trenger kanskje ikke 3500< wt
            return ""N2"" #s√• er det lastebil N2
            
        elif wt > 1200: #hvis vekten er over 12000kg
            return ""N3"" #s√• er det lastebil N3
            ";"def sum_near_whole(A):
    #antar at lengden p√• radene ikke blir lenger enn 4 elementer. 
    
    result = 0 #Lager en variabel som skal v√¶re sluttresultat av summen
    ny_liste = [] #lager ny liste der jeg kan samle alle elementene som har heltall i n√¶rheten
    
    for rad in A: #for hver rad i A
        for number in rad: #for hvert tall i radene
            ny_liste.append(number) #legger til tallene i den nye listen
    
    for tall in ny_liste: #for alle tall i den nye listen
    
        #ved √• dele et tall med // 1 s√• og sammenlikner med opprinnelig tall s√• kan vi se om det er float eller int
        
        if (ny_liste[tall+1]) == ((ny_liste[tall+1])//1): #hvis tallet 1 steg foran er heltall
            result += (ny_liste[tall]) #s√• skal tallet bak heltallet legges til
            
        elif (ny_liste[tall-1]) == (([ny_liste[tall-1])//1): #hvis tallet 1 steg bak er heltall
            result += (ny_liste[tall]) #-..-
            
        elif (ny_liste[tall+4]) == ((ny_liste[tall+4])//1): #hvis tallet 4 steg foran er heltall
            result += (ny_liste[tall]) #-..-
        
        elif (ny_liste[tall-4]) == ((ny_liste[tall-4])//1): #hvis tallet 4 steg bak er heltall
            result += (ny_liste[tall]) #-..-
        
    return result
        
        #tanken er √• sjekke om 1 steg f√∏r eller etter, og 4 steg f√∏r eller etter tallet er heltall.
        #hvis den er det s√• skal den legges til listen og summeres
        #dette forutsetter at lengden til radene er 4 elementer
        #usikker p√• om riktig indeksering og bruk av elementer i listen, kokt i hodet...
        #men tankegangen bak l√∏sningen kan v√¶re en fin m√•te √• l√∏se problemet p√•"
"def sum_larger(numlist,n):
    for i in numlist:
        if i > n:
            zum += i
    return zum";"def car_type(n_pass,wt,person)
    if person == True:
        if n_pass > 8 and wt > 5000: #Hadde brukt 7 dersom f√∏rersete var inkludert
            return ""M3""
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
        else:
            return ""M1""
    else:
        if wt > 12000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        else:
            return ""N1""
        ";"def sum_near_whole(A):
    zum = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if type(j) == ""0"":      #antar her at alle tallene med 0 i desimal er skrevet som et heltall
                A[i,j] = a
                
            if A[i,j+1] == a:
                zum += A[i,j]
            elif A[i,j-1] == a:
                zum += A[i,j]
            elif A[i+1,j] == a:
                zum += A[i,j]
            elif A[i-1,j] == a:
                zum += A[i,j]
            else:
                zum = zum
    return zum"
"def sum_larger(numlist, n):
    
    summen = 0
    
    for i in numlist:
        if i > n:
            summen += i
    
    return summen";"# Jeg er litt usikker p√• hva max ""8 sitteplasser i tillegg til f√∏rersetet"" betyr.
# Slik jeg tolker oppgaven, har en personbil (""M1""), lov til √• ha TOTALT 9 personer i bilen, og alt over er ulovlig.
# Det betyr at en f√∏rer kan ta med seg 8 passasjerer i personbilen sin.

# For√∏vrig er jeg ogs√• litt usikker p√• hva ""antall sitteplasser utover f√∏rersetet"" betyr.
# Dette tolker jeg som antall sitteplasser uten sj√•f√∏r, alts√• bare passasjerer.

def car_type(n_pass, wt, person):
    
    if person:
        if n_pass <= 8 # Hvis, og bare hvis antall sitteplasser utover f√∏rersetet betyr antall passasjerer.
                        # Hvis n_pass betyr antall siteplasser med sj√•f√∏r, hadde jeg byttet ut tallet 8 med tallet 9.
            return ""M1""
        
        if wt >= 5000:
            return ""M3""
        
        return ""M2""
    
    if wt < 3500:
        return ""N1""
    elif 3500 <= wt < 12000:
        return ""N2""
    
    return ""N3""
    

# Dersom oppgaven sier at det kun er lov med 8 personer TOTALT i personbilen, ville koden sett slik ut:

def car_type(n_pass, wt, person):
    
    if person:
        if n_pass <= 7 # Hvis, og bare hvis antall sitteplasser utover f√∏rersetet betyr antall passasjerer.
                        # Hvis n_pass betyr antall siteplasser med sj√•f√∏r, hadde jeg byttet ut tallet 7 med tallet 8.
            return ""M1""
        
        if wt > 5000:
            return ""M3""
        
        return ""M2""
    
    if wt < 3500:
        return ""N1""
    elif 3500 <= wt < 12000:
        return ""N2""
    
    return ""N3""";"import numpy as np

def sum_near_whole(arr):
    
    heltall = []
    
    for row in range(len(arr)):
        
        for col in range(len(row)):
            element = arr[row,col]
            if not (element > int(element) or element < int(element)): # sjekker om flyttallet er et heltall
                heltall.append([row, col])                              # Hvis det er, legger jeg koordinatene til 
                                                                        # tallet en liste
    
    posisjoner = {}
    
    for i in heltall:
        
        a = i[0]
        b = i[1]
        
        if a == 0 and b == 0:
            posisjoner.add([0,1])
            posisjoner.add([1,0])
        elif a == 0 and b == len(arr[a]) - 1:
            posisjoner.add([0, b - 1])
            posisjoner.add([1, b])
        elif a == len(arr) - 1 and b == 0:
            posisjoner.add([a - 1, b])
            posisjoner.add([a , b + 1]
        elif a == len(arr) - 1 and b == len(arr[a]) - 1:
            posisjoner.add([a, b - 1])
            posisjoner.add([a - 1, b])
        elif (0 < a < len(arr) - 1) and b == 0:
            posisjoner.add([a - 1, b])
            posisjoner.add([a + 1, b])
            posisjoner.add([a, b + 1])
        elif (0 < a < len(arr) - 1) and b == len(arr[a]) - 1:
            posisjoner.add([a - 1, b])
            posisjoner.add([a + 1, b])
            posisjoner.add([a, b - 1])
        elif a == 0 and 0 < b < len(arr[a]) - 1:
            posisjoner.add([a, b - 1])
            posisjoner.add([a, b + 1])
            posisjoner.add([a + 1, b])
        elif a == len(arr) - 1 and 0 < b < len(arr[a]) - 1:
            posisjoner.add([a, b - 1])
            posisjoner.add([a, b + 1])
            posisjoner.add([a - 1, b])
        else:
            posisjoner.add([a , b - 1])
            posisjoner.add([a , b + 1])
            posisjoner.add([a - 1, b])
            posisjoner.add([a + 1, b])
            
        # Oj rett over her ble det visst mye kode som sikkert kunne blitt gjort mye enklere. Men men. Over sjekker 
        # koden hvor heltallet er i arrayet, og legger til koordinatene til naboverdiene i et set. Fordi jeg legger 
        # til verdiene i et set, eller mengde, vil de samme koordinatene aldri dukke opp p√• ny.
        # Derfor kan jeg bruke denne metoden til √• finne alle koordinatene til tallene ved siden av heltallene
        # og ingen tall blir tellt to ganger. S√• gjenst√•r det bare √• plusse alle tallene tilh√∏rende koordinatene i 
        # mengden posisjoner sammen
    
    summen = 0.0
    
    for s in posisjoner:
        
        c = s[0]
        d = s[1]
        
        summen += arr[c, d]
    
    return summen
        "
"def sum_larger(numlist, n):
    for x in numlist:
        if numlist[x] > 5:
            result += numlist[x]
        else:
            f += 1
    return result";"def car_type(n_pass, wt, person):
    car = """"
    if person == True and n_pass <= 8:
            car = ""M1""
        elif person == True and wt < 5000:
            car = ""M2""
    else:
        car = ""M3""
    if person == False and wt < 3500:
        car = ""N1""
        elif person == False and 3500 < wt < 12000:
            car = ""N2""
    else:
        car = ""N3""
    return car";"import numpy as np
A = np.array

def sum_near_whola(A):
    Sum = 
    for row in A:
        for col in A[row]:
            if A[row][col] == round(A[row][col])
                sv = (row, col)                         #Finne heltallene
    if abs(A[row]) + abs(A[col]) == (abs(A[row]) + abs(A[col]))-1  #finne tangerende verdier
        Sum += A[row][col]
    return Sum"
"def sum_larger(numlist, n):
    summen = 0 #starter med 0 i sum
    for i in range(len(numlist)):
        if i > n:
            summen += i #g√•r gjennom hvert element i lista og legger til elementet som er st√∏rre enn n til variabelen          summen
    return summen #returnerer summen av tallene som er av h√∏yere verdi enn n";"def car_type(n_pass, wt, person):
    if person = True:
        if n_pass < 9:
            return 'M1'
        elif n_pass > 8 and wt > 5000:
            return 'M3'
        else:
            return 'M2'
    elif person = False and wt <= 3500:
        return 'N1'
    elif person = False and 3500 < wt < 12000:
        return 'N2'
    elif person = False and wt >= 12000:
        return 'N3'
        
    ";"import numpy as np

def sum_near_whole(A):
    result = 0 #starter med en variabel som er lik 0
    for line in range(len(A)): #kj√∏rer gjennom hvert element i ""arrayet""
        if float(A[i]) == int(A[i]): #sjekker om desimalet er 0
            result += A[i-1] + A[i+1] + A[i-4] + A[i+1] #adderer p√• tallet bak, tallet etter, tallet over, og tallet                                          under
    return result
    "
"def sum_larger(numlist, n):
    summen = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            summen += numlist[i]
        
    return summen";"# jeg g√•r ut ifra at m1 betyr 8 personer totalt i bilen

def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8:
            if wt <= 5000:
                return ""M2""
            elif wt > 5000:
                return ""M3""
    elif person == False:
        if wt <= 3500:
            return ""N1""
        elif 3500 < wt <= 12000:
            return ""N2""
        elif wt > 12000:
            return ""N3""";"import numpy as np

def sum_near_whole(A):
    liste = []
    for i in range(len(A)):
        for j in range(len(A[0]))
            string = str(A[i][j]) 
            if string[2] != ""0"":
                if 0 < j < 3:
                    if str(A[i][j-1])[2] = ""0"" or str(A[i][j+1])[2] != ""0"":
                        liste.append(A[i][j])
                    
                elif j == 0:
                    if str(A[i][j+1])[2] = ""0"":
                        liste.append(A[i][j])
                
                 elif j == 3:
                     if str(A[i][j-1])[2] = ""0"": # rakk bare √• sjekk for rader 
                        liste.append(A[i][j])
                    
                    
                
        
       
    liste = np.array(liste) 
    return np.sum(liste)"
"def sum_larger(numlist, n):
    
    summ = 0
    
    for tall in numlist:
        if tall > n:
            summ += tall
    return summ
    
#funksjonskall er ikke n√∏dvendig her i inspera, men bare som et eksempel for √• vise en komplett kode
sum_larger(numlist = [2,5,4,7,3,8], n = 5)";"def car_type(n_pass, wt , person):
    
    #Sjekker for personbil og sorterer deifra
    #n_pass er gitt i sitteplasser eklusiv f√∏rersetet, eks n_pass = 8, dermed 7 sitteplasser
    
    #totalt_sitteplasser = n_pass + 1 Vi kunne ha brukt denne fordi oppgaveteksten sier at n_pass er antall sitteplasser utover f√∏rersetet / dvs eksl f√∏rer. derfor plusse p√• 1 for √• f√• totale sitteplasser
    
    if person == True:
        if n_pass <= 9:
            #m1 = str(M1)
            return 'M1'
        elif n_pass > 9 and wt <= 5000:
            return 'M2'
        elif n_pass > 9 and wt > 5000:
            return 'M3'
        
    #Hvis person ikke er True dermed False er det varetransport og vi kan sortere derifra    
    #Kunne ha skrevet else istdenfor elif, hvis person ikke er True vet vi at den er False...    
    elif person == False:
        if wt <= 3500:
            return 'N1'
        elif wt > 3500 and wt <= 12000:
            return 'N2'
        elif wt > 12000:
            return 'N3'





#Igjen funksjonskallet er ikke n√∏dvendig i inspera men heller for en komplett kode:
car_type(n_pass = 7, wt = 3500 , person = True)";"def sum_near_whole(A):
    summ = 0
    
    posisjon_index_for_tall_med_null_desimal = []
    for verdier in A:
        for verdi in verdier:
            if verdi == int(verdi):
                p = A.index(verdi)
            posisjon_index_for_tall_med_null_desimal.append(p)
                
    #Over har vi funnet posisjoner til tallene i den 2d-lista som har 0 som desimal
    
    #N√• m√• vi sammenligne dems posisjon med tallenen i 2d-lista A sin posisjon:
    #Dette gj√∏r vi ved √• bruke .index()
    for verdier in A:
        for posisjoner in posisjon_index_for_tall_med_null_desimal:
            if A.index(verdier) == posisjoner +1:  #Sjekker om tallet kommer f√∏r/over 
                summ += verdier
            
            if A.index(verdier) == posisjoner -1:#Sjekker om tallet kommer etter/under
                summ+= verdier
    return summ
    
#Funksjonskall trenger vi ikke i inspera siden koden ikke kan kj√∏res men-
#For en komplett funksjonell kode m√• vi ha funksjonskallet med data inn parameter.
sum_near_whole(A = #np.array([]))
"
"def sum_larger(numlist, n):
    sum = 0
    for i in numlist:
        if numlist[i]>5:
            sum += numlist[i]
    return sum 
            
        ";"#antagelse: person tas in som en bool - True om personbil, False om varutransport
#antagelse: Alla bilar som testas passar in i n√•gon kategori 
def car_typ(n_pass,wt,person): 
    
    if person:
        if n_pass <= 8:
            return 'M1'
        else:
            if wt<5000:
                return 'M2'
            elif wt>5000:
                return 'M3'
        
    else:
        if wt<3500:
            return 'N1'
        elif 3500<=wt<12000:
            return 'N2'
        elif wt>12000:
            return 'N3'";"def sum_near_whole(A):
    a,b = 0,0
    used_n = []
    used_m = []
    for i in A:
        for num in A[i]: #g√•r igenom alla tal i alla listor i A
            if num == float(int(num)): #om decimalen in tal √¶r noll
                a = i
                b = A[i].index(num)
                used_m.append(a)
                used_n.append(b)
                
                for m in range(-1,2):
                    for n in range(-1,2):
                        try:
                            if not(a+m in used_m and b+n in used_n) #om b√•de m och n 
                                near_tal += A[a+m][b+n]
                                used_m.append(a+m) #adderar index till listan used numbers
                                used_n.append(b+n)
                        except:
                            pass
                        
                sum += near_tal
    return sum 
                
    "
"def sum_larger(numlist,n):
    if numlist > n:
        return np.sum(numlist)
sum_larger(numlist,n)";"def car_type(n_pass, wt, person):
    person=()
    if person == persontransport:
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt =< 5000:
            return ""M2""
        elif n_pass > 8 and wt > 5000:
            return ""M3""
    elif person == varetransport:
         if wt <= 3500:
            return ""N1""
        elif wt > 8 and wt < 5000:
            return ""M2""
        elif n_pass > 8 and wt >= 5000:
            return ""M3""
    else:
        return ""Koden har sl√•tt seg vrang, eller s√• har du tastet inn en ulovlig verdi""
car_type(n_pass, wt, person)";"import numpy as np
import matplotlib.pyplot as plt

A = np.array([1. , 1.4, 1.8, 2.2], [2.6, 3.8, 3.4, 3.8], [4.3, 4.6, 0.9, 5.4], [5.8, 6.2, 6.6, 7.], 1. , 7.8, 8.2, 8.6])
def sum_near_whole(A):
    
sum_near_whole(A)

#her ville jeg brukt if-setninger og sjekket lengden til de forskjellige arrayene slik at jeg kunne skrevet in at om noe har samme lengde (s√• det havner over eller under) s√• ville jeg plusset de p√•, om de hadde 1 eller -1 i forhold i lengde ville jeg ogs√• plusset de p√•. dette rakk jeg dessverre ikke. Tror kanskje man kunne brukt slicing ogs√• og at det hadde v√¶rt enklere. "
"def sum_larger(numlist, n):
    sum = 0
    for num in numlist:
        if num > n:
            sum += num
    return sum";"def car_type(n_pass, wt, person):
    if person:
        if n_pass < 9:
            return ""M1""
        else:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
    else:
        if wt < 3500:
            return ""N1""
        if wt > 12000:
            return ""N3""
        else: 
            return ""N2""";"def sum_near_whole(A):
    #G√•r ut ifra at numpy allerede er importert
    sum = 0
    used = []
    for i in range(len(A)):
        for j in range(len(A[i])):
            intOfNum = int(A[i][j])
            if (A[i][j]-intOfNum == 0.0):
                if(i == 0):
                    if(j == 0):
                        sum += A[i+1][j]
                        used.append((i+1, j))
                        
                        sum += A[i][j+1]
                        used.append((i, j+1))
                    
                    elif(j == len(A[i])):
                        if !((i+1, j) in used):
                            sum += A[i+1][j]
                            used.append((i+1, j))
                        if !((i, j-1) in used):
                            sum += A[i][j-1]
                            used.append((i, j-1))
                    else:
                        if !((i, j-1) in used):
                            sum += A[i][j-1]
                            used.append((i, j-1))
                        if !((i, j+1) in used):
                            sum += A[i][j+1]
                            used.append((i, j+1))
                        if !((i+1,j) in used):
                            sum += A[i+1][j]
                            used.append((i+1, j))
                        
                elif(i == len(A)):
                    if(j == 0):
                        if !((i-1, j) in used):
                            sum += A[i-1][j]
                            used.append((i-1, j))
                        if !((i, j+1) in used):
                            sum += A[i][j+1]
                            used.append((i, j+1))
                            
                    elif(j == len(A[i])):
                        if !((i-1, j) in used):
                            sum += A[i-1][j]
                            used.append((i-1, j))
                        if !((i, j-1) in used):
                            sum += A[i][j-1]
                            used.append((i, j-1))
                    
                    else:
                        if !((i, j-1) in used):
                            sum += A[i][j-1]
                            used.append((i, j-1))
                        if !((i, j+1) in used):
                            sum += A[i][j+1]
                            used.append((i, j+1))
                        if !((i-1,j) in used):
                            sum += A[i-1][j]
                            used.append((i+1, j))
                
                elif(j == 0 and i != 0 and i != len(A)):
                    if !((i, j+1) in used):
                        sum += A[i][j+1]
                        used.append((i, j+1))
                    if !((i+1, j) in used):
                        sum += A[i+1][j]
                        used.append((i+1, j))
                    if !((i-1, j) in used):
                        sum += A[i-1][j]
                        used.append((i-1, j))
                
                elif(j == len(A[i]) and i != 0 and i != len(A)):
                    if !((i, j-1) in used):
                        sum += A[i][j-1]
                        used.append((i, j-1))
                    if !((i+1, j) in used):
                        sum += A[i+1][j]
                        used.append((i+1, j))
                    if !((i-1, j) in used):
                        sum += A[i-1][j]
                        used.append((i-1, j))
                
                else:
                    if !((i+1, j) in used):
                        sum += A[i+1][j]
                        used.append((i+1, j))
                    if !((i, j+1) in used):
                        sum += A[i][j+1]
                        used.append((i, j+1))
                    if !((i, j-1) in used):
                        sum += A[i][j-1]
                        used.append((i, j-1))
                    if !((i-1, j) in used):
                        sum += A[i-1][j]
                        used.append((i-1, j))
    return sum                    
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    "
"def sum_larger(numlist,n):
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
    return summen
        ";"def car_type(n_pass, wt, person):
    if n_pass < 8 and person == True:  #Antar at plasser utover f√∏rersetet betyr at det kan maks v√¶re 7 plasser, i tillegg til f√∏rersetet (alts√• tilsammen 8) for at det skal kunne v√¶re M1
        return 'M1'
    elif n_pass >= 8 and wt < 5000 and person == True:
        return 'M2'
    elif n_pass >= 8 and wt > 5000 and person == True:
        return 'M3'
    elif wt < 3500 and person == False:
        return 'N1'
    elif 3500 < wt < 12000 and person == False:
        return 'N2'
    elif wt > 12000 and person == False:
        return 'N3'
        
        ";"import numpy as np
sum_near_whole(a):
    summen = 0
    for linje in range(0, len(A)):
        for i in linje:
            if A[linje][i] == int(A[linje][i]):
                
                if A[linje][i] == A[0][0]:
                    summen = summen + A[0][1] + A[1][0]
                
                elif A[linje][i] == A[0][-1]:
                    summen = summen + A[0][-2] + A[1][-1]
                    
                elif A[linje][i] == A[-1][0]:
                    summen = summen + A[-2][0] + A[-1][1]
                    
                elif A[linje][i] == A[-1][-1]:
                    summen = summen + A[-1][-2] + A[-2][-1]
                    
                elif A[linje][i] == A[1][1] or A[1][2] or A[2][1] or A[2][2] or A[3][1] or A[3][2]:
                    summen = summen + A[linje][i+1] + A[linje][i-1] + A[linje-1][i] + A[linje+1][i]
                
                elif A[linje][i] == A[0][1] or A[0][2]:
                    summen = summe + A[0][i-1] + A[0][i+1] + A[1][i]
                
                elif A[linje][i] == A[1][0] or A[2][0] or A[3][0]:
                    summen = summen + A[i-1][0] + A[i+1][0] + A[i][1]
                    
                elif A[linje][i] == A[-1][1] or A[-1][2]:
                    summen = summen + A[-1][i-1] + A[-1][i+1] + A[i-1][i]
                    
                elif A[linje][i] == A[1][-1] or A[2][-1] or A[3][-1]:
                    summen = summen + A[i][-2] + A[i-1][-1] + A[i+1][-1]
    return summen
    
        








"
"def sum_lager(numlist,n):
    summen=0
    for num in numlist:
        if num>n:
            summen+=num
    return summen";"def car_type(n_pass,wt,person):  #Funksjonen antar at den f√•r inn gyldige verdier for parameterne ettersom oppgaven ikke spesifiser at vi skal h√•ndtere parametere p√• gyldig format. Hvis dette er √∏nsket kan det l√∏ses med Try og except eller assert.
#Tolker fra oppgaven at hvis n_pass er 8 er det en personbil. Over 8 seter er en av typene buss.
    
    if person==true:
        if n_pass>8:
            if wt>5000:
                return ""M3""
            else: #Antar her at wt har en gyldig verdi (dvs wt>=0)
                return ""M2""
        else:
            return ""M1""
    
    else:
        if wt>12000
            return ""N3""
        elif wt>3500:
            return ""N2""
        else:
            return ""N1""
            ";"#Kommentar til egen funksjon: denne forutsetter at alle flyttall i arrayet er unike ettersom jeg bruker set()-funksjonen. Denne antagelsen gj√∏res bassert p√• eksempelet vist i oppgaven hvor alle flyttall er unike.

def sum_near_whole(A):  #Her er det fare for mye ""index out of range"" errors s√• l√∏ser oppgaven med unntaksbehandling
    sum_liste=[]
    for i in range(len(A)): #rader
        for j in range(len(A[i])): #kolonner
            num=A[i][j]
            try:
                if type(int(num))==int: #Koden kj√∏rer dersom desimalen er 0, hvis ikke raiser en exception for- l√∏kka g√•r videre
                    
                    try:
                        num_h√∏yre=[A[i][j+1]]: #Er vi p√• raden helt til h√∏yre f√•r vi index out of range problem
                        
                    except:
                        num_h√∏yre=[A[i][0]]
                        pass
                        
                    try:
                        num_under=[A[i+1][j]] #Er vi p√• raden helt nederst f√•r vi index out of range problem
                    except:
                        num_under=[A[0][j]]
                        pass
                    
                    num_over=[A[i-1][j]]
                        
                    num_venstre=[A[i][j-1]]
                
                    sum_liste+=num_h√∏yre+num_venstre+num_under+num_over
            
            except:
                pass
    return sum(set(sum_liste)) #fjerner de tallene som er summert inn fler enn en gang
                        
                        
                        
                    
                "
"def sum_larger(numlist,n):
        sum = 0
        for i in range(len(numlist)):
            if numlist[i] > n:
                sum += numlist[i]
        return sum
        ";"def car_type(n_pass,wt,person):
    if person == ""True"":
        if n_pass =< 8:
            return(""M1"")¬®
        elif (n_pass > 8) and (wt =< 5000):
            return(""M2"")
        elif (n_pass > 8) and (wt > 5000):
            return(""M3"")
    elif person == ""False:
        if wt =< 3500:
            return(""N1"")
        elif (wt > 3500) and (wt < 12000):
            return(""N2"")
        elif wt > 12000:
            return(""N2"")

";"import numpy as np

def sum_near_whole(A):
    A_new = set() #lager set fordi alle elementene m√• v√¶re unike. Kan alts√• ikke legge til samme element to ganger
    for i in range(len(A)):
        for n in range(A[i]):
            if A[i] == (A[i]//1):
                A_new.append(A[n+1])
                A_new.append(A[n-1])
                A_new.append(A[n,i+1])
                A_new.append(A[n,i-1])
    S = np.sum(A_new) #I teorien summere opp alle tallene i settet
    return S
    "
"def sum_larger(numlist,n):
    for tall in numlist:
        if tall > n:
            tall+=tall
            sum_tall = sum(tall)
    return sum_tall
    
            ";"def car_type(n_pass,wt,person):
    if (person != ""N1"" or person !=""N2"" or person != 'N3' :
        return person
    else:
        return False";"import numpy as np
def sum_near_whole(A):
    for i in range(len(A)):
        for x in range(len(A)):
            if column[i].index([x].0) in A:
                column [i][x]+= column[i][x]
    return coulmn






















"
"def sum_larger(numlist, n):
    summen = 0 
    
    for tall in numlist: 
        if tall > n:
            summen += tall
    return summen ";"def car_type(n_pass, wt, person): #Antar at funksjonen bare f√•r inn gyldige verdier
    
    if person ==  'True': #Vet med en gang at det er persontransport
        
        if n_pass < 8: #Antar max 8 vil si mindre enn 8, ikke med 8
            return ""M1""
            
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
            
        else: 
            return ""M3""
            
    elif person == ""False"": #Varetransport
        
        if wt <= 3500: #Antar ikke over vil si med 3500 kg
            return ""N1""
            
        elif wt > 3500 and wt < 1200:
            return ""N2""
            
        else: 
            return ""N3""";"import numpy as np

def sum_near_whole(A): 
    summen = 0 
    
    for i in range(len(A)): 
        rad = A[i]
        for tall in rad: #vil f√• ut alle tallene i hver rad
            heltall = [] 
            tall.split(',') #finner ut hvilket tall som er et helt talll, og setter inn i liste
            if tall[1] == 0:
                heltall.append(tall) #har n√• en liste med alle heltall, vil s√• finne tallene over, under eller ved siden av dette heltallet 
                
            
            hel_tall = set(heltall) #vil senere gj√∏re om listen heltall til et sett siden vi ikke skal summere samme tall flere ganger (set inneholder unike tall).
    
    
    
    return summen"
"def sum_larger(numlist, n):
    summen = 0 
    for i in range(len(numlist)):
        if i > n: 
            summen += i
    return summen
        ";"def car_type(n_pass, wt, person):
    if (n_pass < 8) and (person == True): 
        return ""M1""
    elif (n_pass > 8 and wt) < 5000 (person == True): 
        return ""M2""
    elif (n_pass > 8) and (wt > 5000 person == True):
        return ""M3""
    elif (wt < 3500) and (person == False): 
        return ""N1""
    elif (wt < 3500 and wt < 12000) and (person == False):
        return ""N2""
    elif (wt > 12000) and (person == False):
        return ""N3""
    ";"def sum_near_whole(A): 
    summen = 0
    for i in A:
        for j in i:
            if type(j) not float:
                summen += [j+1], [j-1]
    return summen
        "
"def sum_larger(numlist, n):
    summen = 0
    for i in range(len(numlist)):
        if numlist[i]>n:
            summen += numlist[i]
    return summen
            ";"def car_type(n_pass, wt, person):
    if person:
        if n_pass<=8:
            return 'M1'
        elif n_pass>8:
            if wt<=5000:
                return 'M2'
            else:
                return 'M3'
    else:
        if wt<=3500:
            return 'N1'
        elif wt>3500 and wt<=12000:
            return 'N2'
        else:
            return 'N3'
    ";"def sum_near_whole(A):
    summen = 0
    for i in A:
        for j in A[i]:
            if j%1 == 0:
            
                
                "
"def sum_larger(numlist, n):
    summen = 0
    for i in range(len(numlist)):
        if int(numlist[i]) > int(n):
            summen += int(numlist[i])
    return summen";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 7:          #tolker oppgaveteksten som at det er over 8 sitteplasser totalt, med f√∏rersetet, for M2 og M3
            if wt =< 5000:
                return ""M2""
            else:
                return ""M3""
        else:
            return ""M1""
        
    if person == False:
        if wt <= 3500:
            return ""N1""
        elif: wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"import numpy as np
                                 #generelt i denne oppgaven g√•r jeg utifra at det st√•r f.eks ""1.0"" og ikke ""1."""" i arrayet
def sum_near_whole(A):            
    summering = [] #gj√∏res senere om til et set for √• fjerne tallene som st√•r mer enn √©n gang
    for i in range(len(A)):
        for a in range(len(A[i])):
            if (A[i][a][-1]) == 0:                #meningen her er √• sjekke om et tall er et heltall eller ikke. Dersom det er det, skjer koden p√• neste linje 
                summering.append((A[i][a+1]), (A[i][a-1]), (A[i+1][a]), (A[i-1][a])) #legger til elementene som er omgitt med tynne streker p√• bildet over, til arrayet ""summering""
    return np.sum(list(set(summering)))"
"def sum_larger(numlist,n):
    for x in numlist:
        if x > 5:
            return x+x
        ";"def car_type(n_pass,wt,person):
    totalvekt = wt
    sitteplasser = n_pass
    persontransport = True
    for car in car_type:
        for sitteplasser in car_type:
            return True
            if sitteplasser <= 8:
                return  ""M1""
            if sitteplasser > 8 and totalvekt < 5000:
                return ""M2""
            if sitteplasser > 8 and totalvekt > 5000:
                return ""M3""
        else:
            return False
            if totalvekt >= 3500:
                return ""N1""
            if totalvekt > 3500 <= 12000:
                return ""N2""
            if totalvekt > 12000:
                return ""N3""
        
        
                                ";"import numpy as np

def sum_near_whole(A):
    A = []
    for i in range(A):
        if i == #ville funnet noe som kunne representert tallene som er n√¶rme et heltall
        sum =+ i 
        sum.append(A)
    return sum
return A
    "
"def sum_larger(numlist,n): 
    
    sum=0
    
    for i in numlist: 
        if i > n: 
            sum += i
    return sum";"def car_type(n_pass,wt,person): 
    
    if person == True: 
        if person < 9: 
            typ= ""M1""
        if person > 8 and wt <= 5000: 
            typ= ""M2""
        if person > 8 and wt > 5000: 
            typ=""M3""
            
    
    
    if person == False:
        if wt <= 3500: 
            type = ""N1""
        elif wt >= 3500 and wt<=12000: 
            typ = ""N2""
        elif wt > 12000: 
            typ = ""N3""
    
    return typ
        ";"import numpy as np

def sum_near_whole(A):
    
    summen = 0
    l_rad = len(A)
    l_col = len(A[0])
    for rad in range(l_rad):
        for col in range(l_col):
            
        #Sjekke om de er omringet av tall p√• alle kanter for √• unng√• feilmelding: 
            if (col -1) in range(0,l_rad)
                venstre = 1
            else: 
                venstre = 0
    
            if (col +1 ) in range(0,l_rad):
                h√∏yre = 1
            else: 
                h√∏yre = 0
            
            if (rad +1 ) in range(0,l_col):
                ned = 1
            else: 
                ned = 0
                
            if (rad -1 ) in range(0,l_col):
                opp = 1
            else: 
                opp = 0
                
             #hvis tallet er int, lager vi en boks av tallene rundt og summerer de   
            if type(A[rad][col]) == int:
                box = A[rad-venstre:rad+h√∏yre+1][col-opp:col+ned+1]
                #summere p√• summen av boksen
                summen += np.sum(box)
                
                #bytte ut boksen i A med boks med 0 s√• de ikke plusses igjen 
                rader_boks = len(box)
                col_boks = len(rader_boks)
                array = np.zeros(col_boks*rader_boks)
                null_boks = np.resize(array,(rader_boks,col,bok))
                
                A[rad-venstre:rad+h√∏yre+1][col-opp:col+ned+1] = null_boks
    return  summen
             
                    
                
            
        
                
        "
"def sum_larger(numlist, n):
    s=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            s+=numlist[i]
    return s
    ";"def car_type(n_pass, wt, person):
    svar=""""
    if person:
        if n_pass<=8:
            svar+=""M1""
        else:
            if wt<=5000:
                svar+=""M2""
            else:
                svar+=""M3""
    else:
        if wt<=3500:
            svar+=""N1""
        elif wt<=12000:
            svar+=""N2""
        else:
            svar+=""N3""
    return svar
        
    ";"def sum_near_whole(A):
    s=0
    added_numbers=[]
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j]==int(A[i][j]):
                if i == 0:
                    if j==0:
                        s+=A[i][j+1]+A[i+1][j]
                        
                        if A[i][j+1] in added_numbers:
                            s-=A[i][j+1]
                        else:
                            added_numbers.append(A[i][j+1])
                            
                        if A[i+1][j] in added_numbers:
                            s-=A[i+1][j]
                        else:
                            added_numbers.append(A[i+1][j])
                            
                    elif j==(len(A[i])-1):
                        s+=A[i][j-1]+A[i+1][j]
                        
                        if A[i][j-1] in added_numbers:
                            s-=A[i][j-1]
                        else:
                            added_numbers.append(A[i][j-1])
                            
                        if A[i+1][j] in added_numbers:
                            s-=A[i+1][j]
                        else:
                            added_numbers.append(A[i+1][j])
                        
                    else:
                        s+=A[i][j+1]+A[i][j-1]+A[i+1][j]
                        
                        if A[i][j+1] in added_numbers:
                            s-=A[i][j+1]
                        else:
                            added_numbers.append(A[i][j+1])
                            
                        if A[i][j-1] in added_numbers:
                            s-=A[i][j-1]
                        else:
                            added_numbers.append(A[i][j-1])
                            
                        if A[i+1][j] in added_numbers:
                            s-=A[i+1][j]
                        else:
                            added_numbers.append(A[i+1][j])
                            
                elif i==(len(A)-1):
                    if j==0:
                        s+=A[i][j+1]+A[i-1][j]
                        
                        if A[i][j+1] in added_numbers:
                            s-=A[i][j+1]
                        else:
                            added_numbers.append(A[i][j+1])
                            
                        if A[i-1][j] in added_numbers:
                            s-=A[i-1][j]
                        else:
                            added_numbers.append(A[i-1][j])
                    
                    elif j==(len(A[i])-1):
                        s+=A[i][j-1]+A[i-1][j]
                        
                        if A[i][j-1] in added_numbers:
                            s-=A[i][j-1]
                        else:
                            added_numbers.append(A[i][j-1])
                            
                        if A[i-1][j] in added_numbers:
                            s-=A[i-1][j]
                        else:
                            added_numbers.append(A[i-1][j])
                            
                    else:
                        s+=A[i][j+1]+A[i][j-1]+A[i-1][j]
                        
                        if A[i][j+1] in added_numbers:
                            s-=A[i][j+1]
                        else:
                            added_numbers.append(A[i][j+1])
                            
                        if A[i][j-1] in added_numbers:
                            s-=A[i][j-1]
                        else:
                            added_numbers.append(A[i][j-1])
                            
                        if A[i-1][j] in added_numbers:
                            s-=A[i-1][j]
                        else:
                            added_numbers.append(A[i-1][j])
                            
                else:
                    if j==0:
                        s+=A[i][j+1]+A[i+1][j]+A[i-1][j]
                        
                        if A[i][j+1] in added_numbers:
                            s-=A[i][j+1]
                        else:
                            added_numbers.append(A[i][j+1])
                            
                        if A[i+1][j] in added_numbers:
                            s-=A[i+1][j]
                        else:
                            added_numbers.append(A[i+1][j])
                            
                        if A[i-1][j] in added_numbers:
                            s-=A[i-1][j]
                        else:
                            added_numbers.append(A[i-1][j])
                            
                        
                    elif j==(len(A[i])-1):
                        s+=A[i][j-1]+A[i+1][j]+A[i-1][j]
                        
                        if A[i][j-1] in added_numbers:
                            s-=A[i][j-1]
                        else:
                            added_numbers.append(A[i][j-1])
                            
                        if A[i+1][j] in added_numbers:
                            s-=A[i+1][j]
                        else:
                            added_numbers.append(A[i+1][j])
                            
                        if A[i-1][j] in added_numbers:
                            s-=A[i-1][j]
                        else:
                            added_numbers.append(A[i-1][j])
                        
                    else:
                        s+=A[i][j+1]+A[i][j-1]+A[i+1][j]+A[i-1][j]
                        
                        if A[i][j-1] in added_numbers:
                            s-=A[i][j-1]
                        else:
                            added_numbers.append(A[i][j-1])
                            
                        if A[i+1][j] in added_numbers:
                            s-=A[i+1][j]
                        else:
                            added_numbers.append(A[i+1][j])
                            
                        if A[i-1][j] in added_numbers:
                            s-=A[i-1][j]
                        else:
                            added_numbers.append(A[i-1][j])
                            
                        if A[i][j+1] in added_numbers:
                            s-=A[i][j+1]
                        else:
                            added_numbers.append(A[i][j+1])
                            
    return s
                        
                        
                    "
"def sum_larger(numlist,n):
    summen = 0
    
    for i in range(len(numlist)):
        if numlist[i] > n:
           summen += numlist[i]
        
    return summen
    
    ";"def car_type(n_pass, wt, person):
    
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        else:
            return ""M3""
        
    else:
        if wt <= 3500:
            return ""N1""
        if wt > 3500 and wt <= 12000:
            return ""N2""
        else:
            return ""N3""
            ";"import numpy as np

def sum_near_whole(A):
    oversikt = []
    sum = 0
    i = 0
    
    for i range(A):
        for j in range(i):
            if len(i(j)) < 2:
                
                sum += (i(j+1))
                sum += (i(j-1))
                sum += (i+1(j)))
                sum += (i-1(j))
            
            #Denne koden tar ikke stilling til om de er i sum-listen eller ikke, men fikk ikke tid til dette.
            
    return sum"
"def sum_larger(numlist, n): 
    summen = 0
    
    for i in range(len(numlist)):
        if i > n: 
            summen += numlist[i]
    
    return summen";"def car_type(n_pass, wt, person): 
    
    if person == False: 
        if wt >= 12000: 
            return ""N3""
        elif 3500 <= wt < 12000: 
            return ""N2""
        else:                   # else =(her) elif wt < 3500
            return ""N1""
    
    elif person == True: 
        if n_pass <= 8: 
            return ""M1""
        elif n_pass > 8: 
            if wt < 5000: 
                return ""M2""
            else:               # else =(her) elif wt >= 5000
                return ""M3""
        ";"def sum_near_whole(A):
    summen = 0
    
    for i in range(len(A)): 
        for j in range(len(A[i])): 
            if j[2] == 0:           #j[2]: antar her at alle verdiane i A er l√•gare enn 10 for √• kunne indeksere med 2
                summen += A[i][j+1]
                summen += A[i][j-1]
                summen += A[i+1][j]      
                summen += A[i-1][j]
                
    return summen
    

# i dei fire radene der tala vert lagt til summen, vart det ikkje tid til √• ta omsyn til indekseringsfeil.S√• det ville ved k√∏yring blitt indeksfeil fordi det er indeksert til [i-1], [j+1] osv. 
# det har heller ikkje blitt teke omsyn til at verdiar kan bli addert fleire gongar i denne koden"
"def sum_larger(numlist,n):
    sum = 0
    for i in numlist:
        if i > n:
            sum += i
    return sum";"def car_type(n_pass, wt, person):
    try:
        int(n_pass)
        float(wt)
    except TypeError:
        print(""Ugyldig input, bruk tall for antall sitteplasser og vekt"")
    if isinstance(person,bool):
        if person:
            if int(n_pass) <= 8:
                return ""M1""
            else:
                if wt <= 5000:
                    return ""M2""
                else:
                    return ""M3""
        else:
            if wt <= 3500:
                return ""N1""
            elif wt <= 12000:
                return ""N2""
            else: 
                return ""N3""
    else:
        print(""Bruk True for persontransport og False for varetransport"")";"def sum_near_whole(A):
    d={}
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j]==int(A[i][j]):
                if (A[i+1][j]) in A:
                    d[A[i][j]=(A[i+1][j])
                if (A[i][j+1]) in A:
                    d[A[i][j]=(A[i][j+1])
                if i > 0:
                    d[A[i][j]=(A[i-1][j])
                if j > 0:
                    d[A[i][j]=(A[i][j-1])
    sum=0
    for x in d(values):
        for i in values:
            sum += i
        
    return sum"
"def sum_larger(numlist,n):
    result = 0
    for i in numlist:
        if i>n:
            result+=i
    return result
    
    
    ";"def car_type(n_pass,wt,person):
    
    if person:
        if n_pass <= 8:
            return 'M1'
        elif wt <= 5000:
            return 'M2'
        else:
            return 'M3'
    
    else:
        if wt<= 3500:
            return 'N1'
        elif wt <= 12000:
            return 'N2'
        else:
            return 'N3'
";"import numpy as np

def in_A(A,i,j):
    if i,j>=0 and i<len(A) and j<len(A[i]):
        return A[i,j]
    else:
        return 0
    
def sum_near_whole(A):
    result = dict()
    
    for i in range (len(A)):
        for j in range (len(A[i])):
            
            if A[i,j] == int(A[i,j]):
                
                key = str(i+1)+'-'+str(j)
                if key in result:
                    pass
                else:
                    result[key] = in_A(A,i+1,j)
                
                key = str(i)+'-'+str(j+1)
                if key in result:
                    pass
                else:
                    result[key] = in_A(A,i,j+1)
                
                key = str(i-1)+'-'+str(j)
                if key in result:
                    pass
                else:
                    result[key] = in_A(A,i-1,j)
                
                key = str(i)+'-'+str(j-1)
                if key in result:
                    pass
                else:
                    result[key] = in_A(A,i,j-1)
                
    result = np.sum(np.array(result.values()))
    
    
    return result 
    
"
"def sum_larger(numlist, n):
    return sum([i for i in numlist if i > n])";"def car_type(n_pass, wt, person):
    try:
        if n_pass < 0:
            return '""n_pass"" is not a valid value.'
        if wt < 0:
            return '""wt"" is not a valid value.'
            
        if person:
            if n_pass > 8:
                if wt > 5000:
                    return 'M3'
                else:
                    return 'M2'
            else:
                return 'M1'
        
        else:
            if wt <= 3500:
                return 'N1'
            elif 3500 < wt <= 12000:
                return 'N2'
            else:
                wt > 12000:
                    return 'N3'
    
    except:
        return 'Your input was incorrect.'";"import numpy as np
from math import floor

def sum_near_whole(A):
    indices = []
    for r, v in enumerate(A):
        for c, n in enumerate(r):
            if n - n.floor() == 0.0:
                if c - 1 >= 0:
                    indices.append((r, c - 1))
                if c + 1 <= len(A[0]):
                    indices.append((r, c + 1))
                if r + 1 <= len(A):
                    indices.append((r + 1, c))
                if r - 1 >= 0:
                    indices.append((r - 1, c))
    
    indices = set(indices)
    
    s = 0
    
    for inds in indices:
        s += A[inds[0]][inds[1]]
        
    return s"
"def sum_larger(numlist, n):
    summen = 0
    for number in numlist: #Itererer gjennom listen med heltall
        if number > n: #Sjekker hvert heltall om det er st√∏rre enn n (m√• v√¶re st√∏rre. kan ikke v√¶re lik)
            summen += number #Hvis number er st√∏rre enn n, summeres dette p√• variabelen summen
    return summen #Returnerer summen 
    
";"def car_type(n_pass, wt, person):
    if person == True: #Sjekker om det er persontransport eller varetransport - Dersom True; persontransport
        if n_pass > 8: #Sjekker om antall sitteplasser er over √•tte - dette utelukker M1
            if wt > 5000: #Sjekker om vekten er st√∏rre enn 5000 for √• skille mellom M2 og M3
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    else: #Dersom person gir False, vil denne delen av koden kj√∏res - vet da at det er varetransport
        if wt > 12000: #Sjekker om vekten er st√∏rre enn 12000
            return ""N3""
        elif 3500 < wt < 12000: #Sjekker om vekten er mellom 3500 og 12000
            return ""N2""
        else:
            return ""N1""
        #Det riktige kj√∏ret√∏yet returneres etter hvilke kvalifikasjoner kj√∏ret√∏yet har
        ";"def sum_near_whole(A):
    summen = 0 
    for rad in A:
        for posisjon in rad: #Ittererer gjennom rad og hver posisjon i raden - for √• finne riktig posisjon i matrisen
            pos = posisjon.split(""."") #Splitter posisjonen i to ved punktum for √• finne ut av hva det bak komma er
            if pos[1] == () or pos[1] == 0: #Dersom det ikke er noe bak komma, eller det er lik 0
                summen += rad[posisjon+1] #Summerer neste posisjon i tilsvarende rad p√• summen
    return summen #Returnerer summen
"
"def sum_larger(numlist, n):
    return sum([num in numlist if num > n])
    ";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    elif wt <= 3500:
        return ""N1""
    elif wt <= 12000:
        return ""N2""
    return ""N3""
    
# her kan jeg egetlig bare bruke if-setninger ettersom alt returnerer
# Men else og elif er nice for leselighet
    ";"def sum_near_whole(A):
    summy_sum_sum = 0
    for y in range(len(A)):
        for x in range(len(A[y])):
            is_near_whole_num = False
            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Loop over direct neighbours
                new_x, new_y = x+dx, y+dy
                if (new_x < 0 or new_x >= A.shape[1]) or (new_y < 0 or new_y >= A.shape[0]):
                    # Out of bounds
                    continue
                if A[new_y, new_x] == round(A[new_y, new_x]): # is a whole number
                    is_near_whole_num = True
                    break
            summy_sum_sum += A[y, x]
    return summy_sum_sum"
"def sum_larger(numlist, n):
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
    return summen";"# Siden oppgaveteksten ikke spesifiserer om parameterne n_pass og wt er heltall/flyttal, forutsetter jeg at begge skal v√¶re heltall, da dette gir mest mening med tanke p√• kj√∏ret√∏yforskriften.

def car_type(n_pass, wt, person):
    if person == True:
        if int(n_pass) <= 8:
            return 'M1'
        else:
            if int(wt) < 5000:
                return 'M2'
            else:
                return 'M3'
    elif person == False:
        if int(wt) < 3500:
            return 'N1'
        elif int(wt) < 12000:
            return 'N2'
        else:
            return 'N3'
        ";"def sum_near_whole(A):
    summen = 0
    for liste in A:
        h = 0
        for i in range(len(liste)):
            s = str(liste[i])
            if s[-1] == '.':
                if i == 0:
                    summen += liste[i+1]
                elif (h == 0) and (i != (len(liste)-1)):
                    summen += (liste[i-1] + liste[i+1])
                elif (h == 0) and (i == (len(liste)-1)):
                    summen += liste[i-1]
                elif (h > 0) and (i != (len(liste)-1)):
                    summen += liste[i+1]
                h += 1
            
    return summen
"
"import math

def sum_larger(numlist, n):
    summen = []
    for element in numlist:
        for i in range(len(numlist)):
            if element[i] > n:
                summen.append(element[i])
            return math.fsum(summen)
            
            ";"def car_type(n_pass, wt, person):
    ""persontransport"" = True
    ""varestransport"" = False
    for (person == True):
        if (n_pass <= 8):
            return ""M1""
        elif (n_pass > 8) and (wt <= 5000):
            return ""M2""
        elif (n_pass > 8) and (wt > 5000):
            return ""M3""
        else:
            return None
    for (person == False):
        if wt <= 3500:
            return ""N1""
        elif (wt > 3500 and wt <= 12000):
            return ""N2""
        elif wt > 12000:
            return ""N3""
        else:
            return None
        ";"import math
def sum_near_whole(A):
    liste_m_tall_som_har_int_n√¶r = []
    for row in A:
        for i in range(len(row)): #starter med √• se p√• de horisontale elementene som kan v√¶re n√¶r et element i row som har desimal lik 0
            if (str(row[i])-"".0"") == str(int(row[i])): #gj√∏r begge om til strings med str()
                if row[i] == row[0]:
                    liste_m_tall_som_har_int_n√¶r.append(row[i+1])
                else:
                    liste_m_tall_som_har_int_n√¶r.append(row[i+1])
                    liste_m_tall_som_har_int_n√¶r.append(row[i-1])
        if (str(row[i])-"".0"") == str(int(row[i])) == True:
            liste_m_tall_som_har_int_n√¶r.append(A[i+1][i]) #pr√∏ver √• appende elementet i raden under til listen for √• summere det. 
    return math.fsum(liste_m_tall_som_har_int_n√¶r) 
            
            "
"def sum_lager(numlist, n):
    s=[]
    for i in numlist:
        if i>n:
            s+=[i]
    summ = sum(s)
    return summ";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass<= 8:
            return ""M1""
        else:
            if wt <=5000:
                return ""M2""
            else:
                return ""M3""
    else:
        if wt<=3500:
            return ""N1""
        elif wt>12000:
            return ""N3""
        else:
            return ""N2""";"import numpy as np
# OBS. jeg leste oppgaven feil. jeg s√• den siste delen om at man ikke kunne ha med duplikater de siste 5 minuttene av pr√∏ven. hadde jeg hat tid ville jeg l√∏st dette ved √• enten bruke set og set.add() fordi set ikke tilater duplikater s√• laget en liste av settet, s√• brukt sum(). eller s√• kunne jeg brukt mange if elif else setninger for √• sjekke om det er et helt tall 2 bak eller 2 opp for indeksen fra i[2,:] og j[2,:]. men har desverre ikke tid :/ 
# tror man kan iterere gjennom numpy arrays slik = A[i,j] men bruker to metoder med try except for √• v√¶re sikker p√• at minst en funker :) 
def sum_near_whole(A):
    try: # forskjellen mellom try og except her er bare at jeg bruker to forskjellige m√•ter √• indexe A
        summ=0
        for i in range(len(A)):
            for j in range(len(A[i])):
                if np.round(A[i,j]) == A[i,j]:
                    if i==0:
                        if j==0:
                            summ+=A[i+1,j]+A[i,j+1]
                        elif j==len(A[i]):
                            summ+=A[i,j-1]+A[i+1,j]
                        else:
                            summ+=A[i,j+1]+A[i,j-1]
                    elif i==len(A):
                        if j==len(A[i]):
                            summ+=A[i-1,j]+A[i,j-1]
                        elif j ==0:
                            summ+=A[i-1,j]+A[i,j+1]
                        else:
                            summ+=A[i-1,j]+A[i,j-1]+A[i,j+1]
                    else:
                        summ+=A[i+1,j]+A[i-1,j]+A[i,j+1]+A[i,j-1]
        return summ  
    except:
        summ=0
        for i in range(len(A)):
            for j in range(len(A[i])):
                if np.round(A[i][j]) == A[i][j]:
                    if i==0:
                        if j==0:
                            summ+=A[i+1][j]+A[i][j+1]
                        elif j==len(A[i]):
                            summ+=A[i][j-1]+A[i+1][j]
                        else:
                            summ+=A[i][j+1]+A[i][j-1]
                    elif i==len(A):
                        if j==len(A[i]):
                            summ+=A[i-1][j]+A[i][j-1]
                        elif j ==0:
                            summ+=A[i-1][j]+A[i][j+1]
                        else:
                            summ+=A[i-1][j]+A[i][j-1]+A[i][j+1]
                    else:
                        summ+=A[i+1][j]+A[i-1][j]+A[i][j+1]+A[i][j-1]
        return summ
"
"def sum_larger(numlist, n):
    result = 0
    for number in numlist:
        
        if number > n:
            result += number
        
        else:
            continue
        
    return result
            
            ";"def car_type(n_pass, wt, person):
    
    if person == True:
        
        if n_pass <= 8:
            return ""M1""
            
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
            
        elif n_pass > 8 and wt > 5000:
            return ""M3""
            
    elif person == False:
        
        if wt <= 3500:
            return ""N1""
            
        elif wt > 3500 and wt <= 12000:
            return ""N2""
        
        elif wt > 12000:
            return ""N3""";"import numpy as np

def sum_near_whole(A):
    
    sum_numbers = []
    
    for line in A:
        
        sum_numbers.append(np.sum(line))
        
    return np.sum(sum_numbers)
            
            
            

            
        "
"def sum_larger(numlist, n):
    
    summ = 0
    
    for i in numlist:
        
        if i > n:
            
            summ += i
    
    return summ";"def car_type(n_pass, wt, person):
    
    if person: #Denne kj√∏rer dersom person = True
        
        if n_pass < 9 and wt < 5001:
            return ""M1""
        
        elif n_pass > 8 and wt < 5001:
            return ""M2""
        
        else:
            return ""M3""
    
    else: #Denne kj√∏rer dersom person = False
        
        if wt < 3501:
            return ""N1""
        
        elif wt > 3500 and wt < 12000:
            return ""N2""
            
        else:
            return ""N3""";"def sum_near_whole(A):
    
    summ = 0
    
    for i in range(len(A)):
        
        for j in range(len(i)):
            
            if A[i,j] % 1 == 0: #Sjekker om tallet er et heltall
            
                
                if i == 0: #Sjekker om tallet er en av kantene i matrisen
                
                    
                    if j == 0: #Sjekker om tallet ligger i et hj√∏rne
                        
                        summ += A[i+1, j] + A[i, j+1]
                    
                    elif j == len(i)-1: #Sjekker om tallet ligger i et hj√∏rne
                        
                        summ += A[i+1, j] + A[i, j-1]
                    
                    else:
                        summ += A[i+1, j] + A[i, j+1] + A[i, j-1]
                        
                
                elif i == len(A)-1: #Sjekker om tallet er en av kantene i matrisen
                
                    
                    if j == 0: #Sjekker om tallet ligger i et hj√∏rne
                        
                        summ += A[i, j+1] + A[i-1, j]
                    
                    elif j == len(i)-1: #Sjekker om tallet ligger i et hj√∏rne
                        
                        summ += A[i, j-1] + A[i-1, j]
                    
                    else:
                        
                        summ += A[i, j+1] + A[i, j-1] + A[i-1, j]
                        
                    
                elif j == 0: #Sjekker om tallet er en av kantene i matrisen
                
                    
                    if i == 0 or i == len(A)-1: #Sjekker om tallet ligger i et hj√∏rne
                        pass
                    
                    else:
                        
                        summ += A[i, j+1] + A[i+1,j] + A[i-1,j]
                        
                
                elif j == len(i)-1: #Sjekker om tallet er en av kantene i matrisen
                
                    
                    if i == 0 or i == len(A)-1: #Sjekker om tallet ligger i et hj√∏rne
                        pass
                    
                    else:
                        summ += A[i, j-1] + A[i+1,j] + A[i-1,j]
                
                else:
                    
                    summ += A[i,j+1] + A[i, j-1] + A[i+1,j] + A[i-1,j]
            
    return summ
                
                
                
                
                
                
                
"
"def sum_larger(numlist, n):
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
    return summen
            ";"car_type(n_pass, wt, person):
    if (person == True) and (n_pass <= 8):
        return M1
    elif (person == True) and (n_pass > 8) and (wt<= 5000):
        return M2
    elif (person == True) and (n_pass > 8) and (wt>5000):
        return M3
    elif (person == False) and (wt <= 3500):
        return N1
    elif (person == False) and (3500 < wt <=12000): 
        return N2
    else:
        return N3
        ";"def sum_near_whole(A):
    tall_rundt = []
    summen = 0
    for i in range len(A)):
        for j in range len(A[i])):
            if j ....: #er et heltall
                if ([j] != [0]) and ([i] != [0]):
                    [i+1][j], [i-1][j], [i][j+1], [i][j-1].append(tallet_rundt)
                if [j] != [0]:
                    [i+1][j], [i][j+1], [i][j-1].append(tallet_rundt)
                if [i] != [0]:
                    [i+1][j], [i-1][j], [i][j+1].append(tallet_rundt)
                if [i] != [-1]:
                    .....
                    
                tall_rundt2 = set(tall_rundt)
                for tall in tall_ru
                    
                "
"def sum_larger(numlist,n):
    summen = 0
    
    for i in numlist:
        if i > n:
            summen += i
        else:
            summen = summen
    
    return summen";"def car_type(n_pass, wt, person):
    
    if person == True:
        
        if n_pass <= 8:
            return ""M1""
        elif (wt <= 5000) and (n_pass > 8):
            return ""M2""
        elif (wt > 5000) and (n_pass > 8):
            return ""M3""
    
    else:
        
        if wt <= 3500:
            return ""N1""
        elif 3500 < wt <= 12000:
            return ""N2""
        elif wt > 12000:
            return ""N3""
    
";"def sum_near_whole(A):
    summen = 0
    for rad in A:
        for i in range(len(rad)):
            
            if len(str(rad[i]).strip(""."")) == len(str(rad[i])+1):
                if i == 0:
                    summen += rad[i+1]
                elif i == (len(rad)-1)
                else:
                    summen += rad[i-1]+rad[i-1]
                
                
                if A.index(rad)==0:
                    summen += A[A.index(rad)+1][i]
                elif A.index(rad)==(len(A)-1):
                    summen += A[A.index(rad)-1][i]
                else:
                    summen+=A[A.index(rad)+1][i]
                    summen+=A[A.index(rad)-1][i]
    
    return summen
    
    
    
    
    usikker p√• om A.index(rad) gir indexen til raden, men finner ikke noe bedre alternativ for √• si noe om det er den f√∏rste eller siste raden til arrayet. 
                    
                
    
    
    
    
    
    
    
    
    
    
    
    return summen"
"def sum_larger(numlist,n):
    tall_storre_enn_n = []
    summen = 0
    for i in sum_larger:
        if i > n:
            tall_storre_enn_n.append(i)
    summen = sum(tall_storre_enn_n)
    return summen";"def car_type(n_pass, wt, person):
    if person == True:
        if wt == 0 and n_pass >= 8:
            return M1
        elif wt > 5000:   
            return M2
        else:
            return M
    if person == False
        if wt > 3500:
            return N1
        elif wt > 12000:
            return N2
        else:
            return N3
    
        
    person #True hvis persontransport, False hvis varetransport";"import numpy as np

def sum_near_whole(A):
    g = []
    for i in A:
        for j in a:
        if A[i][j] == Float():
            g.append(i,j)
    
            
            
    
"
"def sum_larger(numlist, n):
    summen = 0
    for i in range(len(numlist)):
        if numlist[i] > 5:
            summen += numlist[i]
    return summen";"def car_type(n_pass, wt, person):
    if n_pass <= 8 and person == True:
        return ""M1""
    elif n_pass > 8 and wt <= 5000 and person == True:
        return ""M2""
    elif n_pass > 8 and wt > 5000 and person == True:
        return ""M3""
    elif wt <= 3500 and person == False:
        return ""N1""
    elif 3500 < wt <= 12000 and person == False:
        return ""N2""
    elif 12000 < wt and person == False:
        return ""N3""
    else:
        print(""En eller flere av parameterverdiene som er gitt inn er ugyldige."")
    ";"import numpy as np

def sum_near_whole(A):
    summen = 0
    for i in range A:
        for j in range(A[i]):
            if len(str(j)) < 3:
                summen += A[i][j+1]
                summen += A[i][j-1]
                summen += A[i+1][j]
                summen += A[i-1][j]
    return summen
    "
"def sum_larger(numlist, n):
    summen = 0
    for tall in numlist:
        if tall > n:
            summen += tall
    return summen";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            retrun ""M1""
        elif n_pass > 8:
            if wt <= 5000:
                return ""M2""
            elif wt > 5000:
                return ""M3""
    if person == False:
        if wt <= 3500:
            return ""N1""
        elif wt > 3500:
            if wt <= 12000:
                return ""N2""
            elif wt > 12000:
                return ""N3""
    ";"import numpy as np
def sum_near_whole(A):
    summen = 0
    k = len(A[0])
    r = len(A)
    for i in range(len(A)):
        for l in range(len(A)):
            if A[i][l] % 1 == 1:
                if i == 0 and l == 0:
                    summen += A[i+1][l] + A[i][l+1]
                elif i == 0 and l == k:
                    summen += A[i+1][l] + A[i][l-1]
                elif i == r and l == 0:
                    summen += A[i-1][l] + A[i][l+1]
                elif i == r and l == k:
                    summen += A[i-1][l] + A[i][l-1]
                    
                elif i == 0:
                    summen += A[i+1][l] + A[i][l+1] + A[i][l-1]
                elif l == 0:
                    summen += A[i+1][l] + A[i][l+1] + A[i-1][l]
                elif i == r:
                    summen += A[i-1][l] + A[i][l+1] + A[i][l-1]
                elif l == k:
                    summen += A[i+1][l] + A[i][l-1] + A[i-1][l]
                
                else:
                    summen += A[i+1][l] + A[i][l-1] + A[i-1][l] + A[i][l+1]
    return sum #Tar ikke h√∏yde for dobble adderinger

#test kode:

def sum_near_whole(A):
    sum = 0
    k = len(A[0])
    r = len(A)
    check = set()
    liste = np.zeros((r, k))
    for i in range(len(A)):
        for l in range(len(A)):
            if A[i][l] % 1 == 1: 
                if i -1 > 0:
                    check.append((i-1)*len(A)+(l))
                if i +1 < len(A):
                    check.append((i+1)*len(A)+(l))
                if l -1 > 0:
                    check.append((i)*len(A)+(l-1))
                if l + 1 > len(A[0]):
                    check.append((i-1)*len(A)+(l+1))
    for i in range(len(A))
        for i in range(len(A[0])):
            
                
                
                    "
"def sum_larger(numlist, n):
    summen = 0
    for tall in numlist:
        if tall > n:
            summen +=  tall
        
    return summen 
    
    #antar at koden bare skal 'returnere summen' og ikke printe den.";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return 'M1'
        
        elif wt <= 5000:
            return 'M2'
            
        else:
            return 'M3'
            
    else:
        if wt <= 3500:
            return 'N1'
        
        elif wt <= 12000:
            return 'N2'
            
        else:
            return 'N3'";"def sum_near_whole(A):
    n = len(A)
    b = len(A[0])  #antar at alle radene er like lange
    summen = 0
    pos = []
    for i in range(n):
        for j in range(b):
            if A[i][j] == int(A[i]):
                if i==0:
                    if j==0:
                        summen += A[i][j+1] + A[i+1][j]
                        pos.append([i,j+1])
                        pos.append([i+1,j])
                    elif j==(b-1):
                        summen += A[i][j-1] + A[i+1][j]
                        pos.append([i,j-1])
                        pos.append([i+1,j])
                    else:
                        summen += A[i][j-1] + A[i][j+1] + A[i+1][j]
                        pos.append([i,j-1])
                        pos.append([i,j+1])
                        pos.append([i+1,j])
                    
                elif i==(n-1):
                    if j==0:
                        summen += A[i][j+1] + A[i-1][j]
                        pos.append([i,j+1])
                        pos.append([i-1,j])
                    elif j==(b-1):
                        summen += A[i][j-1] + A[i-1][j]
                        pos.append([i,j-1])
                        pos.append([i-1,j])
                    else:
                        summen += A[i][j-1] + A[i][j+1] + A[i-1][j]
                        pos.append([i,j-1])
                        pos.append([i,j+1])
                        pos.append([i-1,j])
                    
                elif j==0:
                    summen += A[i+1][j] + A[i-1][j] + A[i][j+1]
                    pos.append([i+1,j])
                    pos.append([i-1,j])
                    pos.append([i,j+1])
                
                elif j==(b-1):
                    summen += A[i+1][j] + A[i-1][j] + A[i][j-1]
                    pos.append([i+1,j])
                    pos.append([i-1,j])
                    pos.append([i,j-1])
                
                else:
                    summen += A[i+1][j] + A[i-1][j] + A[i][j+1] +A[i][j-1]
                    pos.append([i+1,j])
                    pos.append([i-1,j])
                    pos.append([i,j+1])
                    pos.append([i,j-1])
                    
    brukt =[]               
    for sted in pos:
        if sted in brukt:
            summen -= A[sted[0],sted[1]]
        brukt.append(sted)
            
    return summen
            
            "
"def sum_larger(liste, n):
    sumN = 0
    for i in range(len(liste)):
        if liste[i]>n:
            sumN += liste[i]
    
    return sumN";"def car_type(n_pass, wt, person):
    plasser = n_pass
    vekt = wt
    pers = person
    
    if pers:
        if plasser>8 and vekt>5000: #tolker fra oppgaveteksten at det skal v√¶re mer enn 8 sitteplasser (9 eller fler) og vekt mer enn 5000kg
            return ""M3""
        elif plasser>8 and vekt<=5000:
            return ""M2""
        else:
            return ""M1""
    
    if not pers:
        if vekt>12000:
            return ""N3""
        elif vekt>3500 and vekt<=12000:
            return ""N2""
        else:
            return ""N1""";"def sum_near_whola(A):
    tot = 0
    tall = set()
    for i in range(len(A)):
        for j in range(len(A[i])):
            if ""0"" in str(A[i][j])[1:]:
                if i==0:
                    tall.add(A[i+1][j])
                if i == len(A)-1:
                    tall.add(A[i-1][j])
                if j == 0:
                    tall.add(A[i][j+1])
                if j == len(A[i])-1:
                    tall.add(A[i][j-1])
                else:
                    tall.add(A[i+1][j])
                    tall.add(A[i-1][j])
                    tall.add(A[i][j+1])
                    tall.add(A[i][j-1])
    return sum(tall)    "
"def sum_larger(numlist, n):
    big_nr = []
    for i in numlist:
        if i > n:
            big_nr.append(i)
    sum(big_nr)

sum_larger()
";"def car_type(n_pass, wt, person):
    
    if n_pass =< 1:
        person = Flase
    else:
        person = True
    
    
    for person == True:
        if n_pass > 8 and wt =< 5000:
            print(""M2"")
        elif n_pass > 8 and wt > 5000:
            print(""M3"")
        else:
            print(""M1"")
    
    for person == False:
        if wt =< 3500:
            print(""N1"")
        elif 3500 < wt =< 12000:
            print(""N2"")
        else:
            print(""N3"")

car_type()";"def sum_near_whole(A):
    sum_list = [] #Tom liste hvor jeg vil legge til tallene som til slutt skal summeres
    
    for i in A:
        for j in i:
            if len(j) == 1:
                sum_list.append(A[i[j+1]])
                sum_list.append(A[i[j-1]])
                sum_list.append(A[i-1[j]])
                sum_list.append(A[i+1[j]])
            
    print(sum(sum_list[]))
sum_near_whole()"
"def sum_larger(numlist, n):
   
    x=s.sort(numlist) 
    if x > n:
        return sum(x)
    
    else: 
        print(""ingen av tallene var st√∏rre"")
        
        
        ";"def car_type(n_pass, wt, person):
    
    True=personbil
    Varetransport=false
    if true: 
        if n_pass < 8:
            return (M1)
        elif n_pass > 8 and wt < 5000:
            return (M2)
        elif n_pass > 8 and wt > 5000:
            return (M3)
    
    if false:
        if wt > 12000:
            return (N3)
        elif wt > 3500:
            return (N2)
        else:
            return (N1)
            

    ";"def sum_near_whole (A):
    i+=1
    i in range (A):
        i==int(A):
            return 
        "
"
def sum_larger(numlist,n):
    
    summen = 0
    
    for tall in numlist:    #G√•r gjennom et og et tall i lista
        if tall > n:        # Sier at hvis tall er st√∏rre enn det oppgitte heltallet 
            summen += tall     #S√• skal tall legges til i summen
            
                                #Programmet kj√∏rer s√• til det har g√•tt gjennom alle tallene i lista
    return summen       #Returnerer summen av tallene";"kjoretoy = ['M1', 'M2', 'M3']
varetransport = ['N1', 'N2', 'N3']



def car_type(n_pass, wt, person):
    
    if person == False:
        
        if wt > 12000:
            return varetransport[2]
        
        elif 3500 < wt <= 12000:
            return varetransport[1]
            
        else:
            return varetransport[0]
            
            
    else:
        if n_pass <= 8:
            return kjoretoy[0]
            
        elif n_pass > 8 and wt < 5000:
            return kjoretoy[1]
            
        else:
            return kjoretoy[2]
            
    ";"
import numpy as np

def sum_near_whole(A):
    summen = 0
    
    for rad in A:
        for tall i rad:
            if tall
            
            
            summen += tall
    
    
    return summen"
"def sum_larger(numlist, n):

    for i in range(len(numlist)):
        sum = 0
        if numlist[i] > n:
            sum += numlist[i]
    return sum
    ";"def car_type(n_pass, wt, person):
    
    if wt > 1200 and person = False:
        return N3
    elif 3500 < wt < 12000 and person = False:
        return N2
    elif wt < 35000 and person = False:
        return N1
    elif n_pass > 8 and wt > 5000 and person = True:
        return M3
    elif n_pass > 8 and wt < 5000 and person = True:
        return M2
    elif n_pass <= 8 and person = True:
        return M1";"def sum_near_whole(A):
    sum = 0
    
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[j]%1 == 0:
                sum += (A[j+1] + A[j-1] + A[i+1,j] + A[i-1,j])
    return sum"
"import numpy as np

def sum_larger(numlist, n):
    larger_than_n_list=[] #empty list
    total
    for i in len(numlist): #for every value in numlist
        if num_list[i]>n: #if the value is greater than n
            larger_than_n_list.append(num_list[i]) #add the value to the empty list
            larger_than_n_array=np.array(larger_than_n_list) #converts list to numpy array
            total=np.sum(larger_than_n_array) #calculates the sum of the terms in the numpy array
        else: #if not
            pass #pass over the value
    return total ";"def car_type(n_pass, wt, person):
    result=''
    if person==True:
        if n_pass>8:
            if wt>5000:
               result=M3
            else:
                result=M2
        else:
            result=M1
    else:
        if wt>3500:
            result=N2
        elif wt>1200:
            result=N3
        else:
            result=N1
    return result";"import numpy as np

    
def func2(array):
    num_near_whole_list=numpy.ndarray.tolist(array) #converts np array with selected values to a list
    num_near_whole_set=set(num_near_whole_list) #converts list to set to remove duplicates
    num_near_whole_array=np.array(num_near_whole_set) #converts set back to array 
    return num_near_whole_array

def sum_near_whole(A)
    num_near_whole=np.array([]) #an empty numpy array which will include the numbers to sum
    for i, j in range(len(A)-1, len(A[0])-1): #for loop over all index positions, assuming every list is equal in length
      if A[i,j]=np.round(A[i,j]): #condition for being a whole number, division
        try: num_near_whole.append(A[i+1, j+1]) #attempts to add every surrounding value to list
             num_near_whole.append(A[i+1, j-1])
             num_near_whole.append(A[i-1, j+1])
             num_near_whole.append(A[i-1, j-1])
        except: 
            try: #attempts to add existing surrounding values to list
             num_near_whole.append(A[i+1, j-1])
             num_near_whole.append(A[i-1, j+1])
             num_near_whole.append(A[i-1, j-1])
            except: 
             num_near_whole.append(A[i+1, j+1]) #2nd attempt to add existing surrounding values to list
             num_near_whole.append(A[i-1, j+1])
             num_near_whole.append(A[i-1, j-1])
                try: 
                    num_near_whole.append(A[i+1, j+1]) #3nd attempt to add existing surrounding values to list
                    num_near_whole.append(A[i-1, j+1])
                    num_near_whole.append(A[i-1, j-1])
                    except: 
                    try:
                        num_near_whole.append(A[i+1, j-1])
                        num_near_whole.append(A[i+1, j+1]) #final attempt to add existing surrounding values to list
                        num_near_whole.append(A[i-1, j+1])
                    except:
                        pass
      else:
          pass
    return np.sum(func2(num_near_whole))"
"#antar for oppgaven at funksjonen f√•r inn n som er int og at numlist kun inneholder integers

def sum_larger(numlist, n):
    storre = 0
    for tall in numlist:
        if tall > n:
            storre += tall
    return storre";"#antar for oppgaven at parameterene som blir gitt til funksjonen er typene n_pass = int, wt = int og person = bool

def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return ""M1""
        else:
            if wt <= 5000:
                return ""M2""
            else:
                return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt <= 12000:
            return ""N2""
        else:
            return ""N3""
";"#antar fra oppgaveteksten at alle elementene i arrayet er floats

def sum_near_whole(A):
    null = []
    summer = []
    ind = []
    for rad in A:
        for col in rad:
            if A[rad,col] / round(A[rad,col]) == 1.0:
                null.append([rad,col])
                if (col+1 < len(A[0])) and ([rad, col+1] not in ind):
                    summer.append(A[rad, col+1])
                    ind.append([rad, col+1])
                if ((col-1) >= 0) and ([rad, col-1] not in ind):
                    summer.append(A[rad, col-1])
                    ind.append([rad, col-1])
                if (rad + 1 < len(A)) and ([rad+1, col] not in ind):
                    summer.append(A[rad+1, col])
                    ind.append([rad+1, col])
                if (rad - 1 >= 0) and ([rad-1, col] not in ind):
                    summer.append(A[rad-1, col])
                    ind.append([rad-1, col])
    return sum(summer)"
:);:);:)
"def sum_larger(numlist, n):
    output = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            output += numlist[i]
    return output";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return 'M1'
        else:
            if wt <= 5000:
                return 'M2'
            else:
                return 'M3'
    else:
        if wt <= 3500:
            return 'N1'
        elif wt <= 12000:
            return 'N2'
        else:
            return 'N3'";"def sum_near_whole(A):
    summert = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if int(A[i,j]) == A[i,j]:
                if i != (0 and len(A)):
                    if j != (0 and len(A[i])):
                        summert += A[i-1,j]+A[i+1,j]+A[i,j-1]+A[i,j+1]
                    elif j == 0:
                        summert += A[i-1,j]+A[i+1,j]+A[i,j+1]
                    elif j == len(A[i]):
                        summert += A[i-1,j]+A[i+1,j]+A[i,j-1]
                elif i == 0:
                    if j != (0 and len(A[i])):
                        summert += A[i+1,j]+A[i,j-1]+A[i,j+1]
                    elif j == 0:
                        summert += +A[i+1,j]+A[i,j+1]
                    elif j == len(A[i]):
                        summert += A[i+1,j]+A[i,j-1]
                elif i == len(A):
                    if j != (0 and len(A[i])):
                        summert += A[i-1,j]+A[i,j-1]+A[i,j+1]
                    elif j == 0:
                        summert += A[i-1,j]+A[i,j+1]
                    elif j == len(A[i]):
                        summert += A[i-1,j]+A[i,j-1]
    return summert
    
"
"
def sum_lager(numlist, n):
    
    summen = 0
    
    for i in numlist:
        if i > n:
            summen += i
            
    return summen        ";"def car_type(n_pass, wt, person):
    
    if person == True:
        if n_pass <= 8:
            return (""M1"")
        elif (n_pass > 8) and (wt < 5000):
            return (""M2"")
        else:
            return (""M3"")
    
   else: 
        if wt >= 12000:
            return (""N3"")
            
        elif (3500 < wt < 12000):
            return (""N2"")
        
        else:
            retrun (""N1"")";"def sum_near_whole(A):
    
    summen = 0
    
    for rad in A:
        
        for element in rad:
            if element == round(element):
                element = heltall
                
                indeks = rad.index(heltall)
                
                summen += element[indeks+1]
                summen += element[indeks-1]
                summen += A[rad+1][indeks]
                summen += A[rad-1][indeks]
    #bruke (if not in) p√• et vis for √• sjekke om tallet allerede er blitt addert til summen. 
    
    
    return summen"
"def sum_larger(numlist, n):
    
    sum = 0
    
    for tall in range(len(numlist)):
        if tall > n:
            sum += (sum + tall)
        else:
            return 0
            
    return sum";"def car_type(n_pass, wt, person):
    
    if n_pass >= 8 and wt >= 5000 and person == True:
        return ""M3""
    elif n_pass >= 8 and wt <= 5000 and person == True:
        return ""M2""
    elif n_pass < 9 and person == True: 
        return ""M1""
    elif wt > 12000 and person == False:
        return ""N3""
    elif 3500 < wt <= 12000 and person == False:
        return ""N2""
    elif wt <= 3500 and person =0 False:
        return ""N1""
    else:
        return ""Dette kj√∏ret√∏yet er hverken en transportbil eller en personbil""

return n_pass, wt, person
";"def sum_near_whole(A):
    
    sum = 0
    
    for i in range(len(A)):
        if A[i] == float(.0):
            sum += A[i + 1] + A[i-1]
            
        else:
            return 0 
            
    return sum"
"def sum_larger(numlist, n):
    
    summen = 0
    
    for i in range(len(numlist)):
        tall = numlist[i]
        if tall > n:
            summen += tall
        
    return summen
    
    #Her har jeg alts√• iterert gjennom lista for √• g√• gjennom alle tallene, og brukt if-setning til √• sjekke om tallene i lista er st√∏rre enn n. Dersom det er st√∏rre, s√• vil det bli addert til summen. St√•r ingenting i oppgaven om hva som skal skje dersom ingen av heltallene i lista er st√∏rre enn n, men i dette tilfellet vil funksjonen returnere 0 dersom det skjer. 
    ";"def car_type(n_pass, wt, person):
    
    if person == True:              #Sjekker f√∏rst persontransporten
        if n_pass == 8:
            return ""M1""
        else:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
    
    elif person == False:           #Sjekker derretter varetransporten
        if wt < 3500:
            return ""N1""
        elif wt < 12000:
            return ""N2""
        else:
            return ""N3""
            

    
    
    ";"import numpy as np

def sum_near_whole(A):
    
    summen = 0
    
    for rad in A:
        for i in range(len(rad)):
            tall = rad[i]
            if tall // int(tall) == 1.0:
                summen += rad[i + 1] + rad[i - 1] + A[i + 1][i] + A[i - 1][i]
            
    return summen
    
    
    #Tanken bak denne oppgaven er √• f√∏rst definere en tom sum. Siden arrayet er en 2D-liste itererer jeg gjennom to ganger: iterer gjenom hver rad i A, for s√• √• itere gjennom hvert element i raden. Bruker en if-setning til √• se om flytttallet heltallsdividert med seg selv som heltall blir 1,0. For eksempel vil 1,0 // 1 =  1,0, og 7,0 // 7 = 1,0. Hvis det stemmer, s√• vil alle tallene rundt bli addert til summen. 
    
    #I tillegg m√• det lages en if-setning for √• sjekke om tallet allerede har blitt addert til summen, fordi det ikke skulle bli addert to ganger.
    
    #Kunne evt. heller opprettet en tom liste istedet for summen = 0, for s√• √• legge til elementene i lista og summert alle tallene i den.
            "
"def sum_lager(numlist,n):
    result = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            result += numlist[i]
    return result";"def car_type(n_pass, wt, person):
    if person == False:
        if wt <= 3500:
            return 'N1'
        elif wt > 3500 and wt <= 12000:
            return 'N2'
        elif wt > 12000:
            return 'N3'
    elif person:
        if n_pass <= 8:
            return 'M1'
        elif n_pass > 8 and wt <= 5000:
            return 'M2'
        elif n_pass > 8 and wt > 5000:
            return 'M3'";"def sum_near_whole(A):
    sum = 0
    max_i = len(A)
    max_j = len(A[0])
    for i in range(len(A)):
        for j in range(len(A[i])):
            if (A[i][j] - int(A[i][j]) == 0:
                if i < max_i:
                    sum =+ A[i+1][j]
                if i > 0:
                    sum =+ A[i-1][j]
                if j < max_j:
                    sum =+ A[i][j+1]
                if j > 0:
                    sum =+ A[i][j-1]
    return(sum)"
"def sum_larger(numlist, n):
    for i in numlist:
        if i > n:
            return sum(numlist)
            
sum_larger(numlist, n)";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
        elif n_pass > 8 and wt > 5000:
            return ""M3""
    if person == False:
        if wt > 12000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        elif wt <= 3500:
            return ""N1""
            
car_type(n_pass, wt, person)";"import numpy as np

def sum_near_whole(A):
    result = []
    for i in range(A):
        for j in range(A[i]):
            if  
        
        result.append(np.sum([]))
    return result
            
            
sum_near_whole(A)
        "
"def sum_larger(numlist, n):
    result = 0
    for elm in numlist:
        if elm > n:
            result += elm
    return result";"def car_type(n_pass, wt, person):
    car = """"
    if person:
        if n_pass <= 8:
            car = ""M1""
        else:
            if wt <= 5000:
                car = ""M2""
            elif wt > 5000:
                car = ""M3""
        return car
    elif not person:
        if wt <= 3500:
            car = ""N1""
        
        elif wt =< 12000:
            car = ""N2""
            
        else:
            car = ""N3""
    
        return car
                ";"def sum_near_whole(A):
    result_list = []
    whole_nums = []
    

    for i in range(len(A)):
        for j in range(len(row)):
            if A[i,j] == int(A[i,j]):
                whole_nums.append((i,j))#Finner hvor heltallene st√•r i A. 
    
    for tup in whole_nums:
        if tup[0] == 0:    #Lager ifsetninger for tallene langs ""kanten"" av matrisen. Kanskje litt vel tungvindt med eksempelarrayet i oppgaven, men intuitivt dersom matrisen hadde v√¶rt mye st√∏rre. 
            if tup[1] == 0:
                result_list.append(A[tup[0],tup[1]+1],A[tup[0]+1, tup[1]])
            elif tup[1] == len(A[0])-1 :
                result_list.append(A[tup[0], tup[1] -1], A[tup[0]+1, tup[1]])
            else:
                qual_nums = A[tup[0], tup[1]-1],A[tup[0], tup[1]+1], A[tup[0]+1, tup[1]]
                result_list.append(qual_nums)
            
        elif tup[0] == len(A)-1:
            if tup[1] == 0:
                qual_nums = A[tup[0], tup[1]+1], A[tup[0]-1, tup[1]]
                result_list.append(qual_nums)
            elif tup[1] == len(A[tup[0]])-1:
                qual_num = A[tup[0], tup[1]-1], A[tup[0]-1, tup[1]]
            else:
                qual_nums = A[tup[0], tup[1]-1],A[tup[0], tup[1]+1], A[tup[0]-1, tup[1]]
                result_list.append(qual_nums)
                
        elif tup[1] == 0:
            qual_nums = A[tup[0], tup[1]+1], A[tup[0]-1, tup[1]], A[tup[0]+1, tup[1]]
            result_list.append(qual_nums)
            
            
        elif tup[1] == len(A[tup[0]])-1:
            qual_nums = A[tup[0],tup[1]-1], A[tup[0]-1, tup[1]], A[tup[0]+1, tup[1]]
            
        else:
            qual_nums = A[tup[0],tup[1]+1], A[tup[0],tup[1]-1], A[tup[0]-1,tup[1]],A[tup[0]+1, tup[1]]
            
    
    unique_results = set(result_list)
    return np.sum(result_set)
            
    #Dette kunne kanskje v√¶rt gjort med l√∏kker, men rekker ikke pr√∏ve p√• det n√•.         "
"def sum_larger(numlist,n):
    svar = 0
    for i in range(len(numlist)):
        if i > n:
            svar += i
    return svar

sum_lagrer([2,5,4,7,3,8],5)
    ";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass <= 8:
            print('M1')
        elif n_pass>8 and wt<=5000:
            print('M2')
        elif n_pass>8 and wt>5000:
            print('M3')
    else:
        if wt<=3500:
            print('N1')
        elif wt>3500 and wt<=12000:
            print('N2')
        else: 
            print('N3')

car_type(9,2000,True)";"def sum_near_whole(A):
    "
"def sum_lager(numlist,n):
    a = 0
    for i in numlist:
        if numlist[i] > n:
            a += int(numlist[i])
    return a";"def car_type(n_pass, wt, person):
    if n_pass > 8 and wt >= 5000 and person == True:
        return ""M2""
    if n_pass > 8 and wt < 5000 and person == True:
        return ""M3""
    if n_pass =< 8 and person == True:
        return ""M1""
    if wt =< 3500 and person == False:
        return ""N1""
    if 3500 < wt >=12000 and person == False:
        return ""N2""
    if wt > 12000 and person == False:
        return ""N3""";"def sum_near_whole(A):
    "
"def sum_larger(numlist, n):
    sum = 0
    for num in numlist:
        if num > n:
            sum += num
    return sum";"def car_type(n_pass, wt, person):
    
    if person:
        if n_pass <= 8:
            return ""M1""
        if wt <= 5000:
            return ""M2""
        return ""M3""
    
    if wt <= 3500:
        return ""N1""
    if wt > 12000:
        return ""N3""
    return ""N2""";"def sum_near_whole(A):
    sum = 0
    row_num = len(A)
    col_num = len(A[0])
    
    for i in range(len(A)):
        for j in range(len(A[i])):
            
            if j > 0:
                if A[i][j-1] == round(A[i][j-1]):
                    sum += A[i][j]
                    continue
            if j < col_num - 1:
                if A[i][j+1] == round(A[i][j+1]):
                    sum += A[i][j]
                    continue
                
            if i > 0:
                if A[i-1][j] == round(A[i-1][j]):
                    sum += A[i][j]
                    continue
            if i < row_num - 1:
                if A[i+1][j] == round(A[i+1][j]):
                    sum += A[i][j]
                    continue
    return sum"
"def sum_larger(numlist, n):
    summen=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            summen+=numlist[i]
    return summen";"def car_type(n_pass, wt, person):
    if person:
        if n_pass<=8:
            return 'M1'
        elif wt<=5000:
            return 'M2'
        else:
            return 'M3'
    else:
        if wt>12000:
            return 'N3'
        elif wt<=3500:
            return 'N1'
        else:
            return 'N2'";"def sum_near_whole(A):
    rader=len(A)
    kolonner=len(A[0])
    heltall=[]
    for i in range(rader): #finner posisjon til heltall
        for k in range(kolonner):
            if A[i][k]-int(A[i][k])==0:
                heltall.append[i,k])# lager en liste med lister med posisjoene til heltallene
    
    sumpos=[] #finner posisjonen til tallene ved siden av heltallene
    
    for i in range(len(heltall)):
        if heltall[i][0]==0: #alle posisjoenen ved sidenav heltall som er i 1. rad
            if heltall[i][1]==0:
                sumpos.append([0,1],[1,0])
            elif heltall[i][1]==kolonner-1:
                sumpos.append([0,kolonner-2],[1,kolonner-1])
            else:
                sumpos.append([0,heltall[i][1]-1],[0,heltall[i][1]+1],[1,heltall[i][1]])
        elif heltall[i][0]==rader-1:  #alle posisjonene ved siden av heltall i siste rad(nederste rad)
            if heltall[i][0]==0:
                sumpos.append([rader-1,1],[rader-2,0])
            elif heltall[i][1]==kolonner-1:
                sumpos.append([rader-2,kolonner-1],[rader-1,kolonner-2])
            else:
                sumpos.append([rader-1,heltall[i][1]-1],[rader-1,heltall[i][1]+1],[rader-2,heltall[i][1]])
        elif heltall[i][1]==0: #alle posisjonene ved siden av heltall i f√∏re kolonne (ikke hj√∏rner)
            sumpos.append([heltall[i][0]+1,0],[heltall[i][0]-1,0],[heltall[i][0],1])
        elif heltall[i][1]==kolonner-1: #alle posisjonene ved siden av heltall i siste kolonne (ikke hj√∏rner)
            sumpos.append([heltall[i][0]+1,kolonner-1],[heltall[i][0]-1,kolonner-1],[heltall[i][0],kolonner-2])
        else: #alle posisjoene ved siden av heltall som ikke er p√• kanten av matrisen(todimensjonale np arrayet)
            sumpos.append([heltall[i][0],heltall[i][1]+1],[heltall[i][0],heltall[i][1]-1]) # til h√∏yre og venstre
            sumpos.append([heltall[i][0]-1,heltall[i][1]],[heltall[i][0]+1,heltall[i][1]]) # opp og ned
    
    dobble_verdier=[]
    for i in range(len(sumpos)): #lagrer hvilke liser i listen sumpos som er duplikate verdier
        for k in range(len(sumpos)):
            if sumpos[i][0],sumpos[i][1]==sumpos[k][0],sumpos[k][1] and i!=k:
                dobble_verdier.append(i)
                
    triple_verdier=[] #tripple verdier dukker opp 2 ganger(p√• rad) i dobbleverider listen
    kvadruppel_verdier=[] #kvadrupple verdier dukker opp 3 ganger(p√• rad) i dobbelverdi listen
                            #kan ikke ha mer enn kvadrupple verdier (maks)

    for i in range(len(dobble_verdier)-2): 
        if dobble_verdier[i]==dobble_verdier[i+1] and dobble_verdier[i]==dobble_verdier[i+2]:
            kvadruppel_verdier.append(dobble_verdier[i])
        elif: dobble_verdier[i]==dobble_verdier[i+1]:
            triple_verdier.append(dobble_verdier[i])
        elif: dobble_verdier[i+1]==dobble_verdier[i+2]:
            triple_verdier.append(dobble_verdier[i])
        
    #summere alle posisjonen (sumpos) i A
    summen=0
    for i in range(len(sumpos)):
        if i in kvadruppel_verdier:
            summen+=(A[sumpos[i][0]][sumpos[i][1]])/4 #summere alle kvadruple verdier, men deler de p√• 4
        elif i in triple_verdier:
            summen+=(A[sumpos[i][0]][sumpos[i][1]])/3 #dummerere alle tripple verdier, men deler de p√• 3
        elif i in dobble_verdier:
            summen+=(A[sumpos[i][0]][sumpos[i][1]])/2 #summerer alle dobble verider, men deler de p√• 2
        else:
            summen+=(A[sumpos[i][0]][sumpos[i][1]])
    return summen
            
#NB det sto ikke i oppgaveteksten at heltall ikke skulle legges til dersom de er ved siden av hverandre
#om jeg har misfort√•rr er det bare √• legge til en if f√∏r summen legges til som sjekker at tallet - int(tallet)!=0"
"def sum_larger(numlist, n):
    new_list = []
    result = 0
    for i in numlist:
        if numlist[i] > n:
            newlist.append(numlist[i])
    for j in new_list:
        result += new_list[j]
    return result";"def car_type(n_pass, wt, person):
    person_transport = [""M1"", ""M2"", ""M3""]
    vare_transport = [""N1"", ""N2"", ""N3""]
    if person == True:
        if n_pass <= 8:
            return person_transport[0]
        elif wt <= 5000:
            return person_transport[1]
        else:
            return person_transport[2]
    else:
        if wt <= 3500:
            return vare_transport[0]
        elif wt > 3500 and wt <= 12000:
            return vare_transport[1]
        else:
            return vare_transport[2]
    ";"def sum_near_whole(A):
    result = []
    for i in A:
        for j in A[i]:
            if A[i][j] % 2 == 0 or 0.5:
                result += A[i][j-1]
                result += A[i][j+1]
                result += A[i-1][j]
                result += A[i+1][j]
    set_of_result = set(result)
    last_word_of_exam = sum(set_of_result)
    return last_word_of_exam"
"def sum_larger(numlist, n):
    
    st√∏rre_enn = []
    
    for i in range(len(numlist)):
        if numlist[i] > n:              #tar bare med tall st√∏rre enn n, ikke tall som er lik n           
            st√∏rre_enn.append(numlist[i])
            
    return sum(st√∏rre_enn)
    
";"def cartype(n_pass, wt, person):
    
    type = ''
    
    if person:
        if n_pass <= 8:     #8 eller mindre seter
            type = 'M1'
        elif wt > 5000:     #vekt over 5000, ikke lik 5000
            type = 'M3'
        else:
            type = 'M2'
            
    else:
        if wt > 12000:      #vekt over 12000, ikke lik 12000
            type = 'N3'
        elif wt > 3500:     #vekt over 3500, ikke lik 3500
            type = 'N2'
        else:
            type = 'N1'
    
    return type";"def sum_near_whole(A):
    
    indekser = set()        #lager et tomt set for √• lagre indeksene i, slik at jeg ikke f√•r noen duplikater
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j] == int(A[i][j]):     #tall hvor int og float av tallet er like
                B = {[i-1, j], [i, j-1], [i+1, j], [i, j+1]}  #de fire indeksene rundt tallet
                indekser.update(B)            #legger de fire indeksene inn i settet med alle indeksene
    
    summen = 0
    
    for liste in indekser:
        try:
            summen += A[liste[0]][liste[1]]   #Hver liste best√•r av 2 indekser: liste[0] og liste[1]
        except IndexError:      #kommer til √• ha noen indekser utenfor range i matrisen A, n√•r disse forekommer vil de                     hoppes over, og l√∏kken fortsetter
            pass
        
    return summen"
"def sum_larger(numlist,n):
    a=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            a= a+numlist[i]
        else:
            pass
    return a
            
            ";"def car_type(n_pass,wt,person):
    if person:
        if n_pass<=8:
            beskjed = ""M1""
        else:
            if wt<=5000:
                beskjed = ""M2""
            else:
                beskjed = ""M3""
    else:
        if wt<=3500:
            beskjed = ""N1""
        elif 3500<wt<=12000:
            beskjed = ""N2""
        else:
            beskjed = ""N3""
    return beskjed
            ";"def sum_near_whole(A):
    a=0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i,j]==int(A[i,j]):
                if 0<i<len(A[i]):
                    if 0<j<len(A[i,j]):
                        a+=(A[i,j+1])+(A[i,j-1])+(A[i+1,j])+(A[i-1,j])
                    elif j==len(A[i,j]): 
                        a+=(A[i,j-1])+(A[i+1,j])+(A[i-1,j])
                    elif j==0:
                        a+=(A[i,j+1])+(A[i+1,j])+(A[i-1,j])
                elif i==len(A[i]):
                    if 0<j<len(A[i,j]):
                        a+=(A[i,j+1])+(A[i,j-1])+(A[i-1,j])
                    elif j==len(A[i,j]): 
                        a+=(A[i,j-1])+(A[i-1,j])
                    elif j==0:
                        a+=(A[i,j+1])+(A[i-1,j])
                elif i==0:
                    if 0<j<len(A[i,j]):
                        a+=(A[i,j+1])+(A[i,j-1])+(A[i+1,j])
                    elif j=len(A[i,j]): 
                        a+=(A[i,j-1])+(A[i+1,j])
                    elif j=0:
                        a+=(A[i,j+1])+(A[i+1,j])
            else:
                pass


Koden tar inn numpy arrayet og legger sammen alle hosliggende verdier. Den finner derimot ikke ut om et tall er brukt f√∏r. For √• gj√∏re dette ville jeg definert en funksjon som tar verdiene som skal plusses sammen inn i en liste, og sjekket om posisjonen til den gitte verdien er brukt f√∏r, hvis nei, legg til i liste, hvis ja ikke legg til. Deretter summert ved hjelp av en enkel for l√∏kke (lignende oppgave 6., uten if).
                        
                       
    "
"def sum_larger(numlist, n):
    sumlist = []
    for num in numlist:
        if num > n:
            sumlist.append(num)
    sum = sum(sumlist)
    return sum
    ";"def car_type(n_pass, wt, person):
    if person:
        #anttar max 9 seter totalt i bilen (inkludert f√∏rersete)
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"import numpy as np

#Not the most efficent way of testing if num is a wole number, but found no better way
#I am not shure int(1.2) will throw an error but if it does would have used this instead
def is_whole(num):
    try: 
        #Asuming this will throw an error when string cannot be converted to int
        #Stripping the string of any '.' before or after the number thefore asuming that 
        #there are no numbers wittten as .5 but rather 0.5 
        int(str(num).strip('.'))
        return True
    except:
        return False
    

def sum_near_whole(A):
    num_to_sum = []
    index_of_nts = []
    
    #Find indexes of whole numbers and then adding the indexes of the numbers around them
    #this way we can remove duplicate indexes later in case some of the numbers we we'll be summing turns out to be equal.
    
    for i_row in range(len(A)):
        for i_col in range(len(A[i_row])):
            if is_hole(A[i_row, i_col]):
                
                try:
                    #appending the index of the number above our number
                    test = A[i_row-1, i_col]
                    index_of_nts.append([i_row-1, i_col])
                except IndexError:
                    print(""Index does not exist... \nContinuing"")
                    
                try:
                    #appending the index of the number below our number
                    test = A[i_row+1, i_col]
                    index_of_nts.append([i_row+1, i_col])
                except IndexError:
                    print(""Index does not exist... \nContinuing"")
                    
                try:
                    #appending the index of the number to the rigth of our number
                    test = A[i_row, i_col+1]
                    index_of_nts.append([i_row, i_col+1])
                except IndexError:
                    print(""Index does not exist... \nContinuing"")
                    
                try:
                    #appending the index of the number to the left of our number
                    test = A[i_row, i_col-1]
                    index_of_nts.append([i_row, i_col-1])
                except IndexError:
                    print(""Index does not exist... \nContinuing"")
    
    #removing all duplicates and adding numbers to the list of numbers we are summing
    index_of_nts = set(index_of_nts)
    for i in index_of_nts:
        num_to_sum.append(A[i[0],i[1]])
    
    
    sum = np.sum(num_to_sum)
    return sum
    
        "
"def sum_larger(numlist, n):
    summen = 0
    for i in numlist:
        if i > 5:
            summen += i
    return summen";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8 and wt > 5000:
            car = 'M3'
        elif n_pass > 8 and wt <= 5000:
            car = 'M2'
        elif n_pass < 8:
            car = 'M1'
    else:
        if wt > 12000:
            car = 'N3'
        elif 3500 < wt <= 12000:
            car = 'N2'
        elif wt <= 3500:
            car = 'N1'
    return car";"def sum_near_whole(A):
    whole = []
    for i in range(len(A)):
        for j in range(A[i]):
            if A[i,j] == float(int(A[i,j])):
                if len(A[i]-1) == j:
                    whole.append(A[i,j-1])
                    if (i != 0 or i != len(A)-1):
                        whole.append(A[i-1,j], A[i+1,j])
                    elif i == 0:
                        whole.append(A[i+1,j])
                    elif i != len(A)-1):
                        whole.append(A[i-1,j])
                    
                elif j == 0:
                    whole.append(A[i,j+1])
                    if(i != 0 or i != len(A)-1):
                        whole.append(A[i+1,j], A[i-1,j] )
                    elif i == 0:
                        whole.append(A[i+1,j])
                    elif i == len(A)-1:
                        whole.append(A[i-1,j])
                    
                
                else:
                    whole.append(A[i, j-1], A[i,j+1])
                    if i == 0:
                        whole.append(A[i+1,j])
                    elif i != len(A)-1):
                        whole.append(A[i-1,j])
    return sum(whole)
#Jeg har ikke testet at en av verdiene ved siden av et heltall ogs√• kan v√¶re et heltall i denne koden"
"def sum_larger(numlist,n):
    larger = []
    for i in numlist:
        if i > n:
            larger.append(i)
            
    summen = sum(larger)
    
    return summen ";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass <= 7          # Forsto det s√•nn at n_pass er antall sitteplasser unntatt f√∏rersetet. 
            return ""M1""
        elif n_pass > 7 and wt <= 5000:
            return M2
        elif n_pass < 7 and wt > 5000:
            return M3
            
    else:
        if wt <= 3500:
            return N1
        elif 3500 < wt <= 12000:
            return N2
        elif wt > 12000:
            return N3 
    
        ";"
def sum_near_whole(A):
    summen = []
    for i in A:
        for p in A[i]:
            tall = str(i)
            for j in tall:
                if tall[3] == ""0"":
                    if A[i][p] != (A[i][0] or A[i][-1]):
                        sum= A[i][p-1] + A[i][p+1]
                        summen.append(sum)
                    if A[i] != (A[0] or A[-1]):
                        indeks = index(A[i][j])
                        sum_y = A[i-1][indeks]+A[i+1][indeks] 
                        summen.append(sum_y) 
                        
    return summen 
                    
                
                
                
                "
"def sum_larger(numlist,n):
    summen = 0
    for tall in numlist:
        if tall>n:          #Summerer alle tall i listen som er st√∏rre enn n
            summen += tall
    return summen";"def car_type(n_pass,wt,person):
    if person and n_pass <= 8:
        return ""M1""
    elif person and wt <= 5000: #Vet at n_pass > 8 n√•r person = True for alle under
        return ""M2""
    elif person:
        return ""M3""
    elif wt <= 3500:
        return ""N1""
    elif wt <= 12000:
        return ""N2""
    else:
        return ""N3""";"import numpy as np

def sum_near_whole(A):
    #Lager et array av samme st√∏rrelse med verdier av 0 p√• v√¶r indeks
    #Finner alle indexer der det er heltall i arayet A
    #Verdiene rundt heltallene puttes inn i det nye arrayet
    #Summerer alle tallene i det nye arrayet sammen
    
    sum_arr = np.zeroes((len(A),len(A[0]))) #Lager et array av samme dimensjoner som A
    
    for i in len(A):
        for j in len(A[i]): #Iterer gjennom alle verdier
            
            if float(int(A[i,j])) == A[i,j]:  #Sjekker her om floaten av inten av verdien er lik verdien
                
                if j+1<len(A[i]): #N√•r indexen j+1 er mindre lengden av A[i] vet vi at det er en verdi til h√∏yre
                    sum_arr[i,j+1] = A[i,j+1]
                if j-1>=0: #N√•r indexen j-1 er st√∏rre eller lik 0 vet vi at det er en verdi til venstre 
                    sum_arr[i,j-1] = A[i,j-1]
                if i+1<len(A): #N√•r indexen i+1 er mindre enn lengden av A vet vi at det er en rad under den 
                    sum_arr[i+1,j] = A[i+1,j]
                if i-1>=0: #N√•r indexen i-1 er st√∏rre eller lik 0 vet vi at det finnes en rad over den
                    sum_arr[i-1,j] = A[i-1,j]
    
    return np.sum(sum_arr) #Summerer alle verdiene sammen til slutt og returnerer summen
                    "
"def sum_larger(numlist, n):
    return sum(for item > n in numlist)";"def car_type(n_pass, wt, person):
    if preson == True:
        if n_pass <= 8:
            result = M1
        elif (n_pass >8) and (wt < 5000):
            result = M2
        elif (n_pass >8) and (wt>=5000):  #kan bruke else
            result = M3
            
    else:
        if wt < 3500:
            result = N1
        elif wt > 3500 and wt < 12000:
            result = N2
        else:
            result = N3
            
    return result
            
    ";"import numpy as np
def sum_near_whole(A):
    for i in A:
        for j in i:
            while i :
                [j,i+1]
                [j,i-1]
                [j-1,i]
                [j+1,i]
    return sum_near_whole(A)"
"def sum_larger(numlist,n):
    liste = []
    for el in numlist:
        if el > n:
            liste.append(el)
     
    summen = 0
    for elem in liste:
        summen += elem
    
    return summen";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"def sum_near_whole(A):
    number_to_sum = []
    for i in range(len(A)):
        for j in range(len(A[i]):
            if A[i,j] - int(A[i,j]) == 0:
                try:
                    number_to_sum.append(A[i,j+1])
                except IndexError:
                    countinue
                if j != 0:
                    number_to_sum.append(A[i,j-1])
                try:
                    number_to_sum.append(A[i+1,j])
                except IndexError:
                    countinue
                if i != 0:
                    number_to_sum.append(A[i-1,j])
    number_to_sum = list(set(number_to_sum))
    summen = 0
    for el in number_to_sum:
        summen += el
    
    return summen"
"def sum_larger(numlist, n):
    bigger = []
    for i in numlist:
        if i > n:
            bigger.append(i)
    return sum(bigger)
    ";"def car_type(n_pass, wt, person):
    if person:
        if n_pass > 8:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    else:
        if 3500 < wt <= 12000:
            return ""N2""
        elif wt > 12000:
            return ""N3""
        else: 
            return ""N1""";"def sum_near_whole(A):
    specials = []
    around_list = []

    for i in range(len(A)):
        for j in range(len(A[i])):
            num = A[i,j]
            if num == (num // 1): ##hele koden min avhenger om dette fungerer (tror jeg)
                specials.append(num)

    for i in range(len(A)):
        for j in range(len(A[i])-1):
            if A[i,j] in around_list:
                continue
            else:
                if j == 0:
                    if A[i,j+1] in specials:
                        around_list.append(A[i,j])
                else:
                    if A[i,j-1] in specials:
                        around_list.append(A[i,j])
                if i == 0:
                    if A[i+1,j] in specials:
                        around_list.append(A[i,j])
                else:
                    if A[i-1,j] in specials:
                        around_list.append(A[i,j])
                        
    return sum(around_list)
                "
"def sum_larger(numlist, n):
    
    sluttsum = 0
    
    for tall in numlist:
        
        if numlist[tall] > n:
            sluttsum += n
    
    return sluttsum";"def car_type(n_pass, wt, person):
    
    if person == True:
        
        if n_pass <= 8:
            kategori = 'M1'
        else:
            if wt > 5000:
                kategori = 'M3'
            else:
                kategori = 'M2'
    
    else:
        if wt > 12000:
            kategori = 'N3'
        elif wt <= 3500:
            kategori = 'N1'
        else:
            kategori = 'N2'
            
    return kategori
            ";"import numpy as np

def sum_near_whole(A):
   
    riktige_tall = [ ]
    sluttsum = 0
    
    for liste in A:
        
        for i in range(len(A[liste])):
            
            if A[liste,i]//1 == A[liste, i]:
                riktige_tall.append(A[liste, i+1])
                riktige_tall.append(A[liste+1, i])
                riktige_tall.append(A[liste, i-11])
                
        
    
    
    for i in riktige_tall:
        sluttsum += riktige_tall[i]
        
    return sluttsum"
"def sum_lager(numlist,n):
    summen=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            summen+=numlist[i]
    return summen";"def car_type(n_pass,wt,person):
    if person==True:
        if n_pass<=8:
            return ""M1""
        else:
            if wt<=5000:
                return ""M2""
            else:
                return ""M3""
    else:
        if wt<=3500:
            return ""N1""
        elif wt>=3500 and wt<=12000:
            return ""N2""
        else:wt>=12000:
            return ""N3""
        ";"def sum_near_whole(A):
    summen=0
    ekstra=""""
    for tall in A:
        if tall[1]==0:
            venstre=l.just(tall[1])
            hoyre=r.just(tall[1])
            if venstre not in ekstra:
                ektra.append(venstre)
            if hoyre not in ekstra:
                ekstra.append(hoyre)

        tallene=int(ekstra)
        summen=sum(tallene)
    return summen
                
            "
"def sum_larger(numlist,n):
    
    sum=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            sum+=numlist[i]
    
    return sum";"def car_type(n_pass,wt,person):
    
    if person==True:
        if n_pass<8:
            return ""M1""
        else:
            if wt<=5000:
                return ""M2""
            else:
                return ""M3""
                
    elif wt<=3500:
        return ""N1""
    elif wt<=12000:
        return ""N2""
    else:
        return ""N3""
        
    ";"import numpy as np

def sum_near_whole(A):
    
    l_sum=[]

    for i in range(len(A)):
        for j in range(len(A[i])):
            if int(A[i,j])==A[i,j]:
            
            #pr√∏ver √• legge til tallene i indeksene rundt, hvis det g√•r utenfor indeks s√• pr√∏ver jeg p√• nye indekser 
                try:
                    l_sum.append(A[i+1,j])
                    l_sum.append(A[i,j+1])
                    l_sum.append(A[i-1,j])
                    l_sum.append(A[i,j-1])
                except IOError:
                    try:
                        l_sum.append(A[i-1,j])
                        l_sum.append(A[i,j-1])
                        l_sum.append(A[i,j+1])
                    except IOError:
                        try:
                            l_sum.append(A[i+1,j])
                            l_sum.append(A[i,j-1])
                            l_sum.append(A[i,j+1])
                        except IOError:
                            try:
                                l_sum.append(A[i-1,j+1])
                                l_sum.append(A[i,j-1])
                                l_sum.append(A[i,j+1])
                            
    
    l_set=set(l_sum)
    produkt=sum(l_set)
    
    return produkt
                        
                    

       
            
            
        "
"def sum_larger(numlist,n):
    sum = 0
    for i in numlist:
        if i>n:
            sum+=i
    return sum";"def car_type(n_pass, wt, person): # antar at b√•de wt og n_pass er tall >=0
    if person:
        if n_pass <= 8:
            return ""M1""
        elif wt<= 5000:
            return ""M2""
        else:
            return ""M3""
    if not person:
        if wt<= 3500:
            return ""N1""
        elif wt<= 12000:
            return ""N2""
        else:
            return ""N3""";"def sum_near_whole(A):
    summen = []
    for i in range(len(A)):
        for j in range(len(i)):
            if (A[i,j]-round(A[i,j])) == 0:
                if j==0:
                    summen.append(A[i,j+1])
                elif j==len(i)-1:
                    summen.append(A[i,j-1])
                else:
                    summen.append(A[i,j-1])
                    summen.append(A[i,j+1])
                if i==0:
                    summen.append(A[i+1,j])
                elif i==len(A)-1:
                    summen.append(A[i-1,j])
                else:
                    summen.append(A[i+1,j])
                    summen.append(A[i-1,j])
    tot_summen = sum(list(set(summen)))
    return tot_summen
#hvis jeg antar at ingen av flyttallene er like, og
#at det ikke er noen int rett ved siden av hverandre, vil dette gi en korrekt sum.
#Skj√∏nner at disse antagelsene ikke svarer helt p√• oppgaven, men det var det beste jeg klarte     
    "
"def sum_larger(numlist,n):
        numlist_larger_than_num=[]
        for num in range(len(numlist)):
            if n<numlist[num]:
                numlist_larger_than_num.append(numlist[num])       #legger til heltallet som er st√∏rre enn n legges det
            else:                                                   #til i den tomme listen 
                print()
        return sum(numlist_larger_than_num)";"def car_type(n_pass,wt,person):
    type=''
    if person==True:
        if n_pass<8
            type='M1'
        if n_pass>8 and wt<5000:
            type='M2'
        else:
            type='M3'
    else:
        if wt<3500:
            type='N1'
        if wt<12000:
            type='N2'
        else:
            type='N3'
            
    return type
    
";"def sum_near_hole(A):
    for i in A:
        for j in i:
            x=A[j]+A[j+1]+A[i+1[j]]
    return x"
"def sum_larger(numlist, n):
    x = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            x += numlist[i]
    return x";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return 'M1'
        elif totalvekt <= 5000:
                return 'M2'
        return 'M3'
    elif wt <= 3500:
        return 'N1'
    elif wt <= 12000:
        return 'N2'
    return 'N3'";"def sum_near_whole(A):
    x = 0
    addreserte_tal = np.zeroes(len(A),len(A[:,0]))
    for i in range(len(A)):
        for j in range(len(A[i])):
            if  float(int(A[i,j])) - A[i,j] == 0:
                "
"def sum_larger(numlist,n):
    summen = 0
    for i in range(len(numlist)): #Itererer gjennom numlist for √• sjekke hver eneste indeks
        if numlist[i] > n: #Sjekker om tallet er strengt st√∏rre enn n
            summen += numlist[i] # adderer indeksen til sum om betingelsen stemmer
    return summen";"def car_type(n_pass, wt, person):
    if person == True: #Sjekker om det er person- eller varetransport
        if n_pass <= 8: #Sjekker om det er personbil eller buss
            return ""M1""
        elif (n_pass > 8 and wt <= 5000): #Sjekker hvilken type buss totalvekten tilsier
            return ""M2""
        else:
            return ""M3"" #Returnerer den gjenv√¶rende muligheten(G√•r da utfra at betingelsene som er oppgitt tilsier at M3 er eneste mulig gjenv√¶rende mulighet om bilen ikke faller inn under de andre kategoriene)
        
    else: 
        if wt <= 3500: #Sjekker om det er varebil eller lastebil utfra totalvekt
            return ""N1""
        elif (wt > 3500 and wt <= 12000): #Sjekker hvilken type lastebil utfra maksvekt
            return ""N2""
        else:
            return ""N3"" #Returnerer den gjenv√¶rende muligheten (G√•r da utfra at betingelsene som er oppgitt tilsier at N3 er eneste mulig gjenv√¶rende mulighet om bilen ikke faller inn under de andre kategoriene)";"import numpy as np

def sum_near_whole(A):
    result = set(np.array(liste)) #Lager et numpy array slik at vi kan bruke funksjonen np.sum for √• summere alle verdiene. Bruker ogs√• set() funksjonen for √• passe p√• at verdier som tidligere har blitt lagt til i listen ikke legges til to eller flere ganger
    for i in range(len(A)): #itererer gjennom listene
        for j in range(len(A[i])): #itererer gjennom elementene i listen
            A[i][j] = str(A[i][j]) #Gj√∏r om til streng for √• kunne iterere gjennom elementene
            if not j[-1].isdigit(): #Lokaliserer elementene som er flyttall med desimaldel lik null (alts√• bakerste ledd lik punktum og da ikke et tall)
                A[i][j] = float(A[i][j]) #Gj√∏r om til tall for √• kunne summere de
                liste.append(i[j+1], i[j-1], A[i+1][j], A[i-1][j]) #Legger de aktuelle verdiene inn i lista(ved siden av, over og under)
    return np.sum(result)"
"def sum_larger(numlist,n):
    summen=0
    for number in numlist:
        if number>n:
            summen+=number
    return summen";"def car_type(n_pass, wt, person):
    if person==True:
        if n_pass<=8:
            cartype=""M1""
        if n_pass>8 and wt<=5000:
            cartype=""M2""
        if n_pass>8 and wt>5000:
            cartype=""M3""
    else:
        if wt<=3500:
            cartype=""N1""
        if 3500<wt<=12000:
            cartype=""N2""
        if wt>12000:
            cartype=""N3""
    return cartype
    
#antar at brukeren skriver inn vekten (wt) i kg";"def sum_near_whole(A):
    liste = []
    for row in A:
        for column in A[row]:
            if int(A[row,column])==A[row,column]:
                if row == A[0]
                    if column==A[0,0]:
                        liste.append(A[row+1,column])
                        liste.append(A[row,column+1])
                    elif column==A[0,len(A[0])-1]:
                        liste.append(A[row+1,column])
                        liste.append(A[row, column-1])
                    else:
                        liste.append(A[row+1,column])
                        liste.append(A[row,column+1])
                        liste.append(A[row, column-1])
                elif row == A[len(A)-1]
                    if column==A[len(A)-1,0]:
                        liste.append(A[row-1,column])
                        liste.append(A[row,column+1])
                    elif column==A[len(A)-1,len(A[0])-1]:
                        liste.append(A[row-1,column])
                        liste.append(A[row, column-1])
                    else:
                        liste.append(A[row+1,column])
                        liste.append(A[row,column+1])
                        liste.append(A[row, column-1])
                else:
                    if column == A[row,0]:
                        liste.append(A[row-1,column])
                        liste.append(A[row+1,column])
                        liste.append(A[row,column+1])
                    elif column== A[row,len(A[0])-1]
                        liste.append(A[row-1,column])
                        liste.append(A[row+1,column])
                        liste.append(A[row,column-1])
                    else:
                        liste.append(A[row-1,column])
                        liste.append(A[row+1,column])
                        liste.append(A[row,column+1])
                        liste.append(A[row, column-1])
        
    tall_som_summeres= set(liste)
    summen =0
    for tall in tall_som_summeres:
        summen+=tall
                    
    return summen
    
                "
"def sum_larger(numlist,n):
    for tall in numlist:
        if tall>n:
            sum+=tall
    return sum";"def car_type(n_pass,wt,person):
    while person==True:
        if n_pass<=8:
            return ""M1""
        elif wt>5000: 
            return ""M3""
        else:
            return ""M2""
            
    while person==False:
        if wt>12000:
            return ""N3""
        elif 3500<wt<12000:
            return ""N2""
        else:
            return ""N1""";"import numpy as np

def sum_near_whole(A):
    for linje in A:
        for i in linje:
            While linje[i] is Float:
                sum*=linje[i+1]
                sum*=linje[i-1]
                
    np.A.reshape(lines,rows)  #Husker ikke hvordan jeg reshaper til rader vertikalt og kolonner horisontalt
    
    for linje in A:
        for i in linje:
            while linje[i] is Float:
                sum*linje[i+1]
                sum*linje[i+1]
    
    return sum"
"def sum_lagrer(numlist,n):
    sum=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            sum+=numlist[i]
        else:
            None
    return sum";"def car_type(n_pass,wt,person):
    type=''
    if person==True:
        type+='M'
        if n_pass<=8:
            type+='1'
        elif n_pass>8:
            if wt<=5000:
                type+='2'
            elif wt>5000:
                type+='3'
    elif person==False:
        type+='N'
        if wt>12000:
            type+='3'
        elif wt>3500:
            type+='2'
        else:
            type+='1'
    return type";"import numpy as np

def sum_near_whole(A):
    candidates=set()
    sum=0
    for i in A:
        for j in A[i]:
            if A[i][j]%1==0:
                candidates.add(A[int(np.abs(i+1))][j])
                candidates.add(A[int(np.abs(i-1))][j])
                candidates.add(A[i][int(np.abs(j+1))])
                candidates.add(A[i][int(np.abs(j-1))])
                for x in candidates:
                    if x%1==0:
                        candidates.pop(x)
                    sum+=x
    return sum
    
#ser at indexen vil bli out of range noen ganger, men har ikke tid til √• se mer p√• d."
"def sum_larger(numlist, n):
    
    summ = 0
    
    for i in numlist:
        if i > n:
            summ+=i
    return summ
    
";"def car_type(n_pass, wt, person):
    
    kj√∏ret√∏y = ''
    
    if person == True:
        
        if wt <= 3500:
            kj√∏ret√∏y+= 'M1'
        elif wt > 1200:
            kj√∏ret√∏y+= 'M3'
        else:
            kj√∏ret√∏y+='M2'
    
    else:
        
        if wt <= 3500:
            kj√∏ret√∏y+='N1'
        elif wt > 1200:
            kj√∏ret√∏y += 'N3'
        else:
            kj√∏ret√∏y += 'N2'
    
    return kj√∏ret√∏y
        
    
    ";"def sum_near_whole(A):
    
    summ = 0
    
    for i in range(len(A)):
        for j in range(len(A)):
            if A[i][j[:-1]] == 0:
            sum += A[i][j+1]
            sum += A[i][j-1]# her kunne jeg iterert gjennom arrayet, og dersom
            sum += A[i+1][j]# j[-1], j[+1] A[-1] eller A[+1] ikke hadde v√¶rt
            sum += A[i-1][j]# rundt A[i][j], hadde ikke de blitt lagt til i summ
                            # derom verdiene er i slutten av listene vil vi f√• 
                            # en index out of range error
            A[i][j+1]=0
            A[i][j-1]=0     # gj√∏r dette slik at desom verdien igjen er i 
            A[i+1][j]=0     #n√¶rheten av et tall som ender med .0 vil det ikke
            A[i-1][j]=0     #p√•virke sum variablen v√•r
            
    return summ"
"def sum_larger(numlist,n):
    sum = 0
    for i in numlist:
        if i>n:
            sum += i
    return sum";"def car_type(n_pass,wt,person):
    if person:
        if n_pass <= 8:
            return ""M1""
        else:
            if wt <= 5000:
                return ""M2""
            else:
                return ""M3""
    else:
        if wt <=3500:
            return ""N1""
        elif 3500 < wt < 12000:
            return ""N2""
        else:
            return ""N3""";"import numpy as np

def sum_near_whole(A):
    set1 = set() #Bruker set fordi da kan hver verdi bare ligge inne en gang, og slipper derfor at tall inkluderes flere ganger. egentlig burde jeg sjekka om posisjonen l√• inne to ganger, da det n√• ikke tas hensyn til om et tall st√•r flere steder, men det hadde jeg ikke ttid til
    for i in range(len(A)):
        for j in range(len(A[i])):
            if j is integer:
                set1.append(A[i-1,j+1]) 
                set1.append(A[i-1,j-1])
                set1.append(A[i+1,j-1])
                set1.append(A[i+1,j+1])
    sum = set1
    return sum
    
#Her burde man ogs√• sjekket om det faktisk er tall ved siden av heltallene, eller om heltallet er i kanten av arrayet
#det hadde jeg ikke tid til:/"
"def sum_larger(numlist, n):

    st√∏rre_enn_n = []
    resultat = sum(st√∏rre_enn_n)

    for i in range(len(numlist)):
        if numlist[i] > n:
            st√∏rre_enn_n.append(numlist[i])
        
    return resultat

sum_larger([2, 5, 4, 7, 3, 8], 5)";"def car_type(n_pass, wt, person):
    
    class = """"
    
    if wt >= 12000:
        if n_pass > 8 and person == True:
            class = ""M3""
        else:
            class = ""N3""
    
    elif wt > 3500:
        if n_pass > 8 and person == True:
            class = ""M2""
        else:
            class = ""N2""
    
    else:
        if n_pass <= 8 and person == True:
            class = ""M1""
        else:
            class = ""N1""
    
    return class";"import numpy as np

def sum_near_whole(A):
    
    resultat = []

    for i in A:
        for j in range(len(A)):
            
            if A[i][j] % 1 == 0:
                
                if A[i-1][j] in A and A[i-1][j] not in resultat:
                    resultat.append(A[i-1][j])
                    
                if (A[i+1][j]) in A and A[i-1][j] not in resultat:    
                    resultat.append(A[i+1][j])
                    
                if A[i][j-1] in A and A[i-1][j] not in resultat:
                    resultat.append(A[i][j-1])
                    
                if (A[i][j+1]) in A and A[i-1][j] not in resultat:    
                    resultat.append(A[i][j+1])
                    
    return np.sum(resultat)
"
"def sum_larger(numlist,n): 
    
    summen = 0 
    
    for tall in numlist: 
        
        if tall > n: 
            summen += tall 
    
    return summen ";"def car_type(n_pass, wt, person): 
    
    if person: 
        if n_pass <= 8: 
            return ""M1""
            
        else: 
            if wt <= 5000: 
                return ""M2""
            else:
                return ""M3""
                
    else: 
        if wt > 12000: 
            return ""N3""
        elif wt > 3500: 
            return ""N2""
        else: 
            return ""N1""
        
#antar at ikke over betyr at det er tillatt at den er akkurat s√• tung 
    ";"def sum_near_whole(A): 
    
    summen = 0 
    ferdig = []
    
    for i in range(len(A)): 
        for j in range(len(A[i])): 
            
            tall = A[i,j]
            
            if int(tall) == tall: 
                
                if j+2 <= len(A[i]):
                    posisjon = str(i)+str(j+1)
                    if posisjon not in ferdig: 
                        summen += A[i,j+1]
                        ferdig.append(posisjon)
                if j-1 >= 0: 
                    posisjon = str(i) + str(j-1)
                    if posisjon not in ferdig: 
                        summen += A[i,j-1]
                        ferdig.append(posisjon)
                if i-1 >= 0: 
                    posisjon = str(i-1) + str(j)
                    if posisjon not in ferdig: 
                        summen += A[i-1,j]
                        ferdig.append(posisjon)
                if i + 2 <= len(A):
                    posisjon = str(i+1) + str(j)
                    if posisjon not in ferdig: 
                        summen += A[i+1,j]
                        ferdig.append(posisjon)
    return summen            
#antar at tall med samme verdi som et tidligere addert tall kan legges til i summen
#alts√• at det kan v√¶re flere tall med lik verdi i arrayet, og at disse skal legges til
#dvs jeg tolker ""hvert tall skal bare med i summen 1 gang"" som tallet p√• en bestemt posisjon
#hvis ikke hadde jeg lagd en liste med alle tallene som har v√¶rt lagt til
#og sjekket om tallet var i listen f√∏r jeg la det til i summen "
"def sum_larger(numlist, n):
    a = 0
    for i in numist:
        if i>n:
            i += a
    return a";"def car_type(n_pass, wt, person):
    

        
    if person == True:
        if n_pass <= 8:
            return 'M1'
        elif n_pass > 8 and wt < 5000:
            return 'M2'
        elif n_pass > 8 and wt > 5000:
            return 'M3'
    
    elif person == False:
        if wt <= 3500:
            return 'N1'
        elif 3500 < wt <= 12000:
            return 'N2'
        elif wt > 12000:
            return 'N3'
            
            
    # Antar her at vekt blir skrevet inn som heltall og ikke f.eks '5000 kg'. hvist det var tilfellet ville jeg heller sagt wt = wt[-3:]";"def sum_near_whole(A):
    a = 0
    
                
    for i in range (len(A)):
        liste = A[i]
        
        if int(liste[i])==liste[i] and A.index(i)!= -1:
            a += A[i+1][i]
            if liste.index(liste[i])!= 0 and liste.index(liste[i])!= -1 :  
                a += liste[i+1]     
                a += liste[i-1]
                
            elif liste.index(liste[i]) == 0:
                a += liste[i+1]
            elif liste.index(liste[i]) == -1:
                a += liste[i-1]
                
        elif int(liste[i])==liste[i] and A.index(i) == -1:
            if liste.index(liste[i])!= 0 and liste.index(liste[i])!= -1 :  
                a += liste[i+1]     
                a += liste[i-1]
                
            elif liste.index(liste[i]) == 0:
                a += liste[i+1]
            elif liste.index(liste[i]) == -1:
                a += liste[i-1]
    return a
            
"
"def sum_larger(numlist, n):
    liste = ''
    for i in numlist:
        if numlist > n:
            liste += numlist[i].sum
    return liste
    
sum_larger([2,5,4,7,3,8],5)
        
";"def car_type(n_pass, wt, person):
    if person = True:
        return M1, M2, M3
    return N1, N2, N3 
    
    if n_pass <= 9:
        return M1
        if person > 8 and wt < 5000:
            return M2
            if person > 8 and wt > 500:
                return M3
                
    if n_pass < 9 and wt < 3500:
        return N1
        if person < 9 and 3500 < wt < 1200:
            return N2
            if person < 9 and wt > 1200:
                return N3
    
car_type(3, 300, False)  

N1

# skriver f√∏rst om persontransport og de ulike kategoriene. B√•de M1, M2 og M3 skal returnere true, deretter o om varetransport og de ulike kategoriene. N1, N2 og N3 skal returnere False. ";"def sum_near_whole(A):
    summen = []
    for i in range(A):
        for j in range(A[i]):
            if A[i][j] == int:
                summen.append(sum([i+1][j] + [i-1])).intersection
    return summen
    
#Lager to for-l√∏kker slik at man kan f√• inn i hver rad og kolonne for √• sjekke om tallet er et heltall. Da vil tallene bli summert sammen og lagt til i summen. Det vil bare bli et tilfelle av hvert tall og legger derfor til intersection. "
"def sum_larger(numlist,n):
    sum=0
    for nums in numlist:
        if nums>n:
            sum+=nums
    return sum";"def car_type(n_pass, wt, person):
    if person==True:
        if n_pass<=8:
            return ""M1""
        else: 
            if wt<=5000:
                return ""M2""
            else:
                return ""M3""
    elif person==False:
        if wt<=3500:
            return ""N1""
        elif wt<=12000:
            return ""N2""
        else:
            return ""N3""
        ";"import numpy as np
def sum_near_whole(A):
    liste=list(A)
    listen=[]
    listen_vertikal=[]
    sum=0
    for element in liste:
        for i in range(len(element)):
            if element[i]%1==0:
                if element[i]==element[-1]:
                    listen.append(element[i-1])
                elif element[i]==element[0]:
                    listen.append(element[i+1])
                else:
                    listen.append(element[i-1])
                    listen.append(element[i+1])
    listen = set(listen)
    listen = list(listen)
    for tall in listen:
        sum+=float(tall)
    return sum
    
    
    """"""Ville gjort omtrent den samme prosessen som tidligere for √• sjekke for hvilke vertikale ledd som skal med i summen.Bare med bruk av numpy"""""" 
    """"""M√•tte s√• brukt p√• det jeg fikk fra denne vertikale listen og deretter m√•tte jeg brukt en set-funksjon(s.symmetrix_difference(t) tror jeg) p√• de to listene, slik at jeg ikke talte noen tall to ganger. Ville gjort om til listen igjen og regnet slik jeg gj√∏r p√• slutten av kode""""""
        "
"def sum_larger(numlist,n):
    
    sum = 0 
    
    if numlist[i]>n:        #sjekker alle tallene i listen som den er st√∏rre enn enn
        sum += numlist[i]   #dersom det er det, plusses tallet p√• i summen, f√∏rste tall som er st√∏rre er 0 + tallet
        return sum          #Her vil vi kunne bruke den verdien vi har for summen neste iterering,ved at den returneres
    else:
        return sum          #dersom tallet ikke er h√∏yere enn n, vil den dirkete returnere summen

sum_lager()        ";"def car_type(n_pass, wt, person):
    
#sjekker hva som skal til for at alle krav skal dekkes
    if n_pass > 8 and wt > 5000 and person == True: #over 8 plasser, og vekt over 5000kg, og personbil skal v√¶re True
        return 'M3'
    elif n_pass > 8 and wt < 5000 and person == True: #over 8 plasser, og vekt max 5000kg, og perosnbil skal v√¶re True
        return 'M2'
    elif n_pass <= 8 and person == True: #mindre eller akkuart 8 plasser (i tilleg til f√∏rersetet), personbil
        return 'M1'
    elif wt > 12000 and person == False: #vekt over 12 000kg og varebil (dermed False)
        return 'N3'
    elif wt > 3500 and wt < 12000 and person == False: #vekt over 3500kg og under 12 000kg og varebil (false)
        return 'N2'
    elif wt < 3500 and perosn == False:#vekt under 3500kg og varebil(false)
        return 'N1'
   
car_type()";"def sum_near_whole(A):
   
    sum = 0 
    
    for linje in len(A): #itererer igjennom alle arraayene/'linjene' i arrayet
        
        for index in linje: #itererer igjennom alle indexene/tallene i hvert array/'linje'
            
            if linje[index] / 1 == float(linje[index]): #m√• sjekke om tallet har 0 i desimalen, dersom den kan det                                             #sjekker vi neste steg, ellers returner den bare summen
                                                        #dersom tallet delt p√• 1 i folat er akkuart det samme som
                                                        #tallet, har tallet 0 som desimal
                    if linje[index] == linje[0]:#sjekker om tallet st√•r p√• index [0] eller [-1], dersom de gj√∏r det                            #funker det ikke √• ha [i+-1] da det vil komme utenfor
                        sum += linje[index + 1] + [linje+1]index]
                        return sum
                    elif linej[index] == linje [-1]: 
                        sum += linje[index - 1] + [linje+1][index]
                        return sum
                    else:
                        sum += linje[index+1]+linje[index-1]
    return sum"
"def sum_larger(numlist, n):
    ans = 0
    for num in numlist:
        if num > n:
            ans += num
    return ans";"# antar at car_type alltid f√•r inn gyldige parametre slik som spesifisert i oppgaven
def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8
            return ""M1"" # personbil
        elif wt <= 5000
            return ""M2"" # buss med totalvekt under eller lik 5000
        else:
            return ""M3"" # buss med totalvekt over 5000
    else:
        if wt <= 3500:
            return ""N1"" # varebil med totalvekt under eller lik 3500
        elif wt <= 12000:
            return ""N2"" # lastebil med totalvekt mellom 3500 og 12000
        else:
            return ""N3"" # lastebil med totalvekt over 12000";"# Her antar jeg at alle radene ikke n√∏dvendigvis har lik lengde. Selv om dette er tilfellet i eksemplet, st√•r det ikke eksplisitt i oppgaveteksten. Antar ogs√• at det kan komme negative tall.

import numpy as np # Fordi inndataen skal v√¶re et numpy array

# Definerer hjelpefunksjon for √• sjekke om en float har desimaldel lik 0
def is_int(x):
    return (abs(x) - int(abs(x))) == 0

def sum_near_whole(A):
    result = 0
    N = len(A)
    for i in range(N):
        K = len(A[i])
        for j in range(K):
            valid = False

            if j > 0 and is_int(A[i, j-1]):                         # Sjekker tallet til venstre
                valid = True

            if j < K-1 and is_int(A[i, j+1]):                       # Sjekker tallet til h√∏yre
                valid = True

            if i > 0 and len(A[i-1]) > j and is_int(A[i-1, j]):     # Sjekker tallet over
                valid = True

            if i < N-1 and len(A[i+1]) > j and is_int(A[i+1, j]):   # Sjekker tallet under
                valid = True

            if valid:
                result += A[i, j]
    return result"
"def sum_larger(numlist, n):
    summen = 0
    
    for i in numlist:
        if i > n:
            summen += i
    
    return summen";"def car_type(n_pass, wt, person):
    
    if person == True: #Bruker if, elif og else her for √• sjekke om kj√∏ret√∏yene passer til kravene
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        elif wt > 5000:
            return ""M3""
    
    else:
        if person == False:
            if wt <= 3500:
                return ""N1""
            elif wt>= 3500 or wt<= 12000: #Siden de med kj√∏ret√∏y type N1 allerede er utelukket kan man skrive or her. 
                return ""N2""
            elif wt>12000:
                return ""N3""
        ";"def sum_near_whole(A):
    liste = []
    
    for n in A: # For hver liste i A 
        for j in A: # For hvert tall i listen n
            if j[2:]== 0: #Valgte √• √• slice f.eks. 1.0 fra [2:] fordi plassering 2 vil v√¶re det tallet etter punktumet
                try:        #Sjekker om det er ett tall etter tallet med x.0 
                    if A[j+1] in liste:
                        continue
                    else:
                        liste.append(A[n][j+1])
                except: #Om det ikke er ett tall etter tar funksjonen i stedet det tallet f√∏r
                    if A[j-1] in liste: 
                        continue
                    else:
                        liste.append(A[n][j-1])
    
            else:
                continue
            
    resultat = sum(liste)
    return resultat
    "
"def sum_larger(numlist,n):
    resultat = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            resultat += numlist[i]
    return resultat
";"def car_type(n_pass, wt, person):
    if person == True and wt > 5000 and n_pass > 8:
        return M3
    elif person == True and wt <= 5000 and n_pass > 8:
        return M2
    elif person == True and n_pass <= 8:
        return M1
    elif person == False and wt > 12000:
        return N3
    elif person == False and wt > 3500:
        return N2
    else:
        return N1";"def sum_near_whole(A):
    mitt_sett = set()
    resultat = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j] == int(A[i][j]): #sjekker om det er et heltall
                if i == 0 and j == 0: #tar √∏vre venstre hj√∏rne
                    mitt_sett.add(A[i+1][j],  A[i][j+1])
                elif i == 0 and j == len(A[i])-1: #tar √∏vre h√∏yre hj√∏rne
                    mitt_sett.add(A[i-1][j], A[i][j+1])
                elif i == len(A)-1 and j == 0: #tar nedre venstre
                    mitt_sett.add(A[i+1][j], A[i][j+1])
                elif i == len(A)-1 and j == len(A[i])-1: #tar nedre h√∏yre
                    mitt_sett.add(A[i+1][j], A[i][j-1])
                elif i == 0: #tar √∏verst
                    mitt_sett.add(A[i+1][j], A[i][j+1], A[i][j-1])
                elif i == len(A)-1: #tar nederst
                    mitt_sett.add(A[i-1][j], A[i][j+1], A[i][j-1])
                elif j == 0: #tar venstre
                    mitt_sett.add(A[i+1][j], A[i-1][j], A[i][j+1])
                elif j == len(A[i])-1: #tar h√∏yre
                    mitt_sett.add(A[i+1][j], A[i-1][j], A[i][j-1])
                else: #tar resten
                    mitt_sett.add(A[i+1][j], A[i-1][j], A[i][j-1], A[i][j+1])
    lst = list(mitt_sett)
    for n in range(len(lst)):
        resultat+=lst[n]
    
    return resultat"
"def sum_larger(numlist, n):
    sm = 0
    for x in numlist:
        if x > n:
            sm += x
    return sm";"def car_type(n_pass, wt, person):
    if person:
        kat = 'M'
        if n_pass <= 7:
            kat += '1'
        elif wt <= 5000:
            kat += '2'
        else:
            kat += '3'
    else:
        kat = 'N'
        if wt <= 3500:
            kat += '1'
        elif wt <= 12000:
            kat += '2'
        else:
            kat += '3'
    
    return kat";"def sum_near_whole(A):
    sm = 0
    stor_i = len(A) - 1
    stor_j = len(A[0]) - 1 # st√∏rste indekser for array
    for i in range(len(A)):
        for j in range(A[i]):
            
            if i == 0: #√∏vre kant
                if j == 0: #√∏vre venstre hj√∏rne
                    if str(A[0][1])[-1] == '0' or str(A[1][0])[-1] == '0':
                        sm += A[i][j]
                elif j == stor_j: #√∏vre h√∏yre hj√∏rne
                    if str(A[0][j - 1])[-1] == '0' or str(A[1][j])[-1] == '0':
                        sm += A[i][j]
                else: #resten av √∏vre kant
                    if str(A[0][j - 1])[-1] == '0' or str(A[0][j + 1])[-1] == '0' or str(A[1][j])[-1] == '0':
                        sm += A[i][j]
                    
            elif i == (stor_i): #nedre kant
                if j == 0: #nedre venstre hj√∏rne
                    if str(A[i][1])[-1] == '0' or str(A[i - 1][0])[-1] == '0':
                        sm += A[i][j]
                elif j == stor_j: #nedre h√∏yre hj√∏rne (alle hj√∏rnene er tatt med :) )
                    if str(A[i][j - 1])[-1] == '0' or str(A[i - 1][j])[-1] == '0':
                        sm += A[i][j]
                else: #resten av nedre kant
                    if str(A[i][j - 1])[-1] == '0' or str(A[i][j + 1])[-1] == '0' or str(A[i - 1][j])[-1] == '0':
                        sm += A[i][j]
                        
            elif j == 0: #venstre kant
                if str(A[i -1][j])[-1] == '0' or str(A[i + 1][j])[-1] == '0' or str(A[i][j + 1])[-1] == '0':
                    sm += A[i][j]
                
            elif j == stor_j: #h√∏yre kant
                if str(A[i -1][j])[-1] == '0' or str(A[i + 1][j])[-1] == '0' or str(A[i][j - 1])[-1] == '0':
                    sm += A[i][j]
            else: #resten
                if (str(A[i -1][j])[-1] == '0' or str(A[i + 1][j])[-1] == '0' or str(A[i][j - 1])[-1] == '0' or str(A[i][j + 1])[-1] == '0'):
                    sm += A[i][j]
    return sm
    
###Beklager rotet, om str(A[i][j])[-1] for et float-heltall gir f. eks 1. og ikke 1.0, skal alle ""== 'O'"" erstattes med ""== '.'"""
"def sum_lager(numlist, n):
    list = []
    for i in range(len(list)):
        if i > n:
            list.append(i)
        else:
            return """"
    sum = sum(list)
    return sum";"def car_type(n_pass,wt, person):
    persontransport = [personbil, buss]
    varetransport = [varebil, lastebil]
    for n_pass in persontrasnport:
        return n_pass == True
    for n_pass in varetransport:
        return n_pass == False
    if person <=8 and n_pass ==True:
        return M1
    elif wt <5000 and person > 8 and n_pass ==True:
        return M2
    elif wt >5000 and person > 8 and n_pass ==True:
        return M3
    elif wt < 3500 and n_pass ==False:
        return N1
    elif 3500 < wt < 12000 and n_pass ==False:
        return N2
    elif wt > 12000 and n_pass ==False:
        return N3
'''       
 for n_pass in persontrasnport:
        return True
        if wt < 5000:
            return 0
        elif wt >= 5000:
            return 1
            if wt == None:
            return 2
        else:
            return """"
        person 
    
    for n_pass in varetransport:
        return False
        if wt <3500:
            return 3
        elif 3500 < wt < 12000:
            return 4
        elif wt > 12000:
            return 5
        else:
            return """"
'''
        
        
        
        ";"def sum_near_whole(A):
    liste = []
    for i in range(len(A)):
        for j in range(len(A[i])):
            #usikker p√• hvordan jeg kan f√• koden til √• sjekke hver rad og legge til de tallene som kommer p√• de bestemte plassene jeg velger. tror det kanskje kan ha noe med [::] men er ikke sikker
            if j == float():
                liste.append(j)
            elif j == int:
                return """"
            else:
                return """"
    sum = sum(liste)
    return sum"
"def sum_larger(numlist,n):
    sum=0
    for num in numlist:
        if num>n:
            sum+=num
    return sum
";"def car_type(n_pass,wt,person):
    if person:
        if n_pass>7:
            if wt>5000:
                return (""M3"")
            return(""M2"")
        return(""M1"")
    if wt>12000:
        return (""N3"")
    if wt>3500:
        return (""N2"")
    return (""N1"")";"def sum_near_whole(A):
    sum=0
    #Lager en ny array som er v√•r orginale array men omfavnet av en ring med 0er
    sumarray=np.zeros((len(A)+2,len(A[i])+2))
    for i in range(len(A)):
        for j in range(len(A[i])):
            sumarray[i+1][j+1]=A[i][j] 

    for i in range(len(A)):
        for j in range(len(A[i])):
            if round(A[i][j])==A[i][j]: #sjekker om det er heltall
                #Bruker sumarray til √• summe siden denne inneholder 0 p√• hj√∏rnene s√• ung√•r vi feilmelding
                #A[i][j] tilsvarer [i+1][j+1] i sumarray
                sum+=sumarray[i+1][j+2]
                sumarray[i+1][j+2]=0 #setter elementet i sumarray 0 slik at det ikke kan plusses flere ganger
                
                sum+=sumarray[i+1][j]
                sumarray[i+1][j]=0
                
                sum+=sumarray[i+2][j+1]
                sumarray[i+2][j+1]=0
                
                sum+=sumarray[i][j+1]
                sumarray[i][j+1]=0
                
    return sum

"
"


def sum_larger(numlist, n):
    
    summen = 0
    
    for i in range(len(numlist)):
        if num_list[i] > n:
            summen += num_list[i]
        
    return summen

summen = sum_larger(numlist, n)

";"


def car_type(n_pass, wt, person):
    
    if person == True:
        if n_pass <= 8:
            return f""M1""
        else:
            if wt <= 5000:
                return f""M2""
            else:
                return f""M3""
    
    else:
        if wt <= 3500:
            return f""N1""
        elif wt <= 12000:
            return f""N2""
        else:
            return f""M3""
    ";"


def sum_near_whole(A):
    
    summen = 0
    
    for i in range(lenA):
        for j in range(len(A[i])):
            if A[i][j] % 1 == 0:
                if i < len(A)-1:
                    if i > 0
                        if j < len(A[i])-1:
                            if j > 0:
                                summen += (A[i+1][j] + A[i-1][j] + A[i][j+1] + A[i][j-1])
                            else:
                                summen += (A[i+1][j] + A[i-1][j] + A[i][j+1])
                        else:
                            summen += (A[i+1][j] + A[i-1][j] + A[i][j-1])
                    else:
                        if j < len(A[i])-1:
                            if j > 0:
                                summen += (A[i+1][j] + A[i][j+1] + A[i][j-1])
                            else:
                                summen += (A[i+1][j] + A[i][j+1])
                        else:
                            summen += (A[i+1][j] + A[i][j-1])
                else:
                    if j < len(A[i])-1:
                            if j > 0:
                                summen += (A[i-1][j] + A[i][j+1] + A[i][j-1])
                            else:
                                summen += (A[i-1][j] + A[i][j+1])
                        else:
                            summen += (A[i-1][j] + A[i][j-1])
        
    
    # for i in range(len(A)):
    #     for j in range(len(A[i])):
    #         if A[i][j] % 1 == 0:
                # for k in range(-1, 2)
                # Try:
                #     v.append(A[i+k][j+k])    Dette rakk jeg ikke, men tror funksjonen skal 
                        
                    
    
                
    

    
    return summen



"
"def sum_larger(numlist, n):
    summen = 0
    
    for i in range(len(numlist)):
        if numlist[i] > n:
            summen += numlist[i]
            
    return summen";"def car_type(n_pass, wt, person):
    
    if person == True: #persontransport
        
        if n_pass <= 8:
            return ""M1""
            
        else:
            if wt <= 5000:
                return ""M2""
                
            else:
                return ""M3""
        
        
    else: #person == False, alts√• varetransport
        
        if wt <= 3500:
            return ""N1""
        
        elif <= 12000:
            return ""N2""
            
        else:
            return ""N3""
            
    #Antar her at alle verdiene som blir lagt inn i funksjonskallet er gyldige verdier";"def sum_near_whole(A):
    liste = []
    
    for i in range(len(A)):
        for j in range(len(A[i])):
            if round(A[i,j],1) == A[i,j]: #sjekker om tallet har 0 som desimal
                
                try:
                    liste.append(A[i+1,j])
                except IndexError:
                    continue
                else:
                    try:
                        liste.append(A[i-1,j])
                    except IndexError:
                        continue
                    else:
                        try:
                            liste.append(A[i,j+1])
                        except IndexError:
                            continue
                        else:
                            try:
                                liste.append(A[i,j-1])
                            except IndexError:
                                continue
                       
                    
    unike_tall = list(set(liste)) 
    summen = sum(liste)
    
    return summen
                "
"def sum_larger(numlist, n):
    summen = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            summen = summen + numlist[i]
        else: 
            summen = summen
    return summen
    
sum_larger([2,5,4,7,3,8], 5)";"def car_type(n_pass, wt, person):
    result = ''
    while n_pass <= 8:
        while wt <= 3500:
            if person == True:
                result = result + 'M1'
            else:
                result = result + 'N1'
        if 3500 < wt <= 12000:
            result = result + 'N2'
        else:
            result = result + 'N3'
    while n_pass > 8:
        if wt <= 5000:
            result = result + 'M2'
        else:
            result = result + 'M3'
    return result
    
car_type(10, 4500, True)";"import numpy as np
def sum_near_whole(A):
    summen = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j] * 10 % 10 == 0:      # Finner ut om tall med indeks j i rad med indeks i har 0 som desimal.
                summen = summen + A[i][j-1] + A[i][j+1] + A[i+1][j]    # Summerer tallene p√• begge sider av tallet med indeks j.                                        Svakhet: Vet at [j-1] tilsvarer det siste tallet i raden dersom j = 0
            else:
                summen = summen
    return summen
    
sum_near_whole(np.array([....]))"
"def sum:larger(numlist,n):
    result = 0
    for i in range (sumlist-1):
        if sumlist(i)>n: #finne tall som er st√∏rre enn n
            result += i #legger sammen tallene som er st√∏rre enn n
    return result";"def car_type(n_pass,wt,person):
    if person ==varetransport: # finner f√∏rst ut hva som er persontransport og varetransport
        if wt>12000: #her deler jeg inn varekj√∏ret√∏yet inn etter vekt
            result = N3
        elif wt>3500:
            result = N2
        else:               #her kommer de varekj√∏ret√∏yene som er under 3500kg
            result = N1
    else:
        if wt>5000 and n_pass>8: #her deles det inn etter vekt og antall, dette er den eneste personbilen som blir delt inn slikt
            result = M3
        elif n_pass>8: # deles inn etter antall seter i bilen
            result = M2
        else:
            result = M1
    return result";"import numpy as np
def sum_near-whole(A):
    sums = np.array()
    for i in range (len(A)-1): #har brukt renge for √• finne ut hvor lang den to dimensjonale np.arrayen er
        for j in range (len(A[i])-1): # her burker jeg in range igjen for √• finne ut hvor langt hvert ledd er
            z = int(A[i,j]) 
            if A[i,j]==int(A[i,j]): #sjekker om A[i,j] er et int-tall og ikke float
                if j-1 >= 0: #sjekker om j-1 er mindre enn 0
                    sums.append(A[i,(j-1)]) 
                if j+1 <= (len(A[i])-1): #sjekker om j+1 er st√∏rre enn selve leddet
                    sums.append(A[i,(j+1)])
                if i-1 >= 0: # samme som linje 8, bare sjekker om det er ledd over
                    sum.append(A[(i-1),j])
                if i+1 <= (len(A)-1): # sjekker om det er ledd under
                    sum.append(A[(i+1),j])
    for a in (len(sums)-1):
        x=sums.count(a) #hvis et ledd ble telt flere ganger
        while x != 1: 
            sums.remove(a) 
            x = sums.count(a)
    np.sum(sums)"
"def sum_larger(numlist, n):
    nyListe = []
    for i in range(len(numlist)):
        if numlist[i]>n:
            nyListe.append(numlist[i])
            
    return sum(nyListe)";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass<8:
            return ""M1""
        elif n_pass>8 and wf<500:
            return ""M2""
        elif n_pass>8 and wf>500:
            return ""M3""
        
    elif person == False:
        if wt >= 3500:
            return ""N1""
        elif wt>3500 and wt<1200:
            return ""N2""
        elif wt > 1200:
            return ""N3""
 ";"import numpy as np

def sum_near_whole(A):
    sumtall = 0
    for i in range(A):
        
    
    
    return sumtall"
"sum_larger(numlist,n):
    n = int
    numlist = []
    summen = 0 #tildeler variablen summen startverdien null
    numlist.sort() # sorter lista i stigende rekkef√∏lge
    while max(numlist) > n: # Kj√∏rer s√• lenge st√∏rste verdi i lista er st√∏rre enn n
        summen += max.numlist # legger den til p√• summen i s√•fall
        numlist.pop(max.numlist) #f√∏r den st√∏rste verdien fjernes
        return numlist #retunerer s√• nye 
    print(summen)

sum_larger([2,5,4,7,3,8],5)";"# Antar at det kun tastes inn tall, alts√• skriver ikke kode for feilmeldinger hvis det tastes inn ""314 kg"" for eksempel

def car_type(n_pass, wt, person):
    if person: #Antagelse at n√•r man taster inn parameteren for person da taster true, men meningsl√∏st √• skrive if person == True. S√• dermed if person:
        if n_pass > 8:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    else: #else blir dermed om man fyller inn none/0
        if wt < 3500:
            return ""N1""
        elif wt > 12000:
            return ""N3""
        else:
            return ""N2""
            
";"import numpy as np

def sum_near_whole(A):
    a = 0
    for i in range(len(A)):
        if ((i // x) % y) == 0:
            a += A[i[i+1]]
            a += A[i[i-1]]
            a += A[i+1[i]]
            a += A[i-1[i]]
    return a 
    
    
""""""pseudokode:
    oprett variablen a
    hvis x heltallsdivisert ikke forlater noe rest / alts√• sjekke om x er integer (vet dette ikke blir helt korrekt, men i bunn og grunn sjekke om det er heltall)
    s√• skal adjacent verdier legges til i a
    alts√• sjekke om kolonne indeks - 1 og +1 eksisterer 
    samt √• sjekke om rad indeks b√•de +1 og -1 eksisterer f√∏r de adderes til a
    retunerer s√• til slutt a som blir summen og det funksjon skal ha som output
    
    
    "
"def sum_lager(numlist,n):
    summen=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            summen+=numlist[i]
    return summen";"def car_type(n_pass,wt,person):
    if n_pass>8 and wt>=5000 and person=True:
        return 'M3'
    elif n_pass>8 and wt<5000 and person=True:
        return 'M2'
    elif n_pass<8 and person=True:
        return 'M1'
    elif wt<3500 and person=False:
        return 'N1'
    elif 3500<=wt<12000 and person=False:
        return 'N2'
    else:
        return 'N3'
        ";"import numpy as np

def sum_near_whole(A):
    nere=[]
    for i in range(len(A)):
        for j in range(len(A[0])):
                        
            if (A[i][j])[:1]=='.':
                if 2<=i<=3 and 2<=j<=3:
                    nere.append(A[i][j+1]+A[i-1][j]+A[i][j-1]+A[i+1][j])
                elif i=1 and j=1:
                    nere.appeend(A[i+1][j]+A[i][j+1])
                else:
                    nere.append(#fortsettelse)
        nere=set(nere)
        liste=list(nere)
        summen=np.sum(nere)
  
    return summen
     
        
# her har jeg kun tatt hensyn til om tallet med null(eller '.' som siste element) er i sentrum av matrisen(til en 4x4) matrise, eller hvis tallet er i f√∏rste rad og kolonne av matrisen. hadde planer om √• lage flere utfall, men inspera sletter alt bak det man endrer, s√• det ble for tidskrevende. h√•per dere skj√∏nner hva tankegangen er ihertfall! gj√∏r deretter listen nere om til et set, slik at alle duplikater slettes. s√• gj√∏r jeg settet om til en liste igjen og finner summen av listen "
"def sum_lagrer(numlist, n):
    summ = 0
    
    for i in range(len(numlist)):
        if numlist[i] > n
        summ += numlist[i]
    return summ
    ";"def car_type(n_pass, wt, person):
    
    if person:
        if n_pass <= 8:
            return ""M1""
        if n_pass > 8:
            if wt < 5000:
                return ""M2""
            if wt  > 5000:
                return ""M3""
    else:
        if wt < 3500:
            return ""N1""
        eilf 12000 >wt > 3500:
            return ""N2""
        else:
            return ""N3""";"def finnheltall(liste, rad): #returnerer kolonnen og raden til sifferet
    heltallplass = []
    
    for i in range(len(liste)):
        tall = str(liste[i]) 
        if int(tall[3]) == 0: #antar at det kun er tall fra 0-9
        heltallplass.append([i,rad])
            
    return heltallplass




def sum_near_whole(A):
    s = set() #antar at alle tall i arrayet er ulike, legger til tallene i matrisen, hvis de er ved siden av eller over/under et heltall
    summ = 0
    
    x = []
    for i in range(len(A)):
        x.append(finnheltall(A[i], i))
        
    for rad in A: 
        for tall in rad:
            if 
            
            s.add(tall) #legger tall til i matrisen hvis de har samme rad og kolonnes+-1 som en liste i listen ""x"", eller hvis de har samme kolonne og +-1rad som en liste i listen ""x"" (kom ikke s√• langt)
    for tall in s:
        summ += tall
        
    return tall"
"def sum_larger(numlist, n):
    larger_list = []
    for i in numlist:
        if i > n:
            larger_list.append(i)
    return sum(larger_list)

#kan eventuelt larger_list = 0, og deretter larger_list += i";"def car_type(n_pass, wt, person):
    if person:
        if n_pass < 9:
            return ""M1""
        else:
            if wt < 5000:
                return ""M2""
            else:
                return ""M3""
    else:
        if wt > 12000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        else: 
            return ""N1""

# med antagelse at wt er tillatt vekt, ettersom ""N3"" med vekt p√• 11000 vil bli definert som ""N2"" av funksjonen. ";"def sum_near_whole(A):
    sum = 0
    for i in range(len(A)-1):
        for o in range(len(A[i])-1):
            if (i == 0 and o == 0) and str(A[i,o]).endswith("".""): #√òverst venstre hj√∏rne
                sum += A[i+1,o]
                sum += A[i,o+1]
            elif (i == (len(A)-1) and o == (len(A[i])-1)) and str(A[i,o]).endswith("".""): #Nederst h√∏yre hj√∏rne
                sum += A[i-1,o]
                sum += A[i,o-1]
            elif (i == 0 and o == (len(A[i])-1) and str(A[i,o]).endswith("".""): #√òverst h√∏yre hj√∏rne
                sum += A[i+1,o]
                sum += A[i,o-1]
            elif (i == (len(A)-1) and o == 0) and str(A[i,o]).endswith("".""): #Nederst venstre hj√∏rne
                sum += A[i-1,o]
                sum += A[i,o+1]
            elif i == 0 and str(A[i,o]).endswith("".""): #√òverste linje, ok ettersom hj√∏rnene er over
                sum += A[i,o+1]
                sum += A[i,o-1]
                sum += A[i+1,o]
            elif i == (len(A)-1) and str(A[i,o]).endswith("".""): #Nederste linje, ok ettersom hj√∏rnene er over
                sum += A[i,o+1]
                sum += A[i,o-1]
                sum += A[i-1,o]
            elif o == 0 and str(A[i,o]).endswith("".""): #Venstre side, ok ettersom hj√∏rnene er over
                sum += A[i,o+1]
                sum += A[i+1,o]
                sum += A[i-1,o]
            elif o == (len(A[i])-1) and str(A[i,o]).endswith("".""): #H√∏yre side side, ok ettersom hj√∏rnene er over
                sum += A[i,o-1]
                sum += A[i+1,o]
                sum += A[i-1,o]
            elif str(A[i,o]).endswith("".""): #Resterende av tallene, selvf√∏lgelig gitt at desimalen er 0 (gjelder da for alle if/elif)
                sum += A[i,o-1]
                sum += A[i+1,o]
                sum += A[i-1,o]
                sum += A[i,o+1]
    return sum"
"def sum_larger(numlist, n):
    _sum = 0
    for num in numlist:
        if (num > n):
            _sum += num
    return _sum";"def car_type(n_pass, wt, person):
    # Antar at wt er int eller float i input
    if person:
        if n_pass <= 8:
            return ""M1""
        if wt <= 5000:
            return ""M2""
        if wt > 5000:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        if wt > 12000:
            return ""N2""
        if (wt > 3500 and wt <= 12000):
            return ""N3""
        ";"def sum_near_whole(A):
    # Find all whole numbers
    whole_numbers = []
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j] - int(A[i][j]) == 0:
                whole_numbers.append((i, j))
                
    numbers_to_sum = []
    for pair in whole_numbers:
        i, j = pair[0], pair[1]
        # Get all neighbours of the whole number
        neighbours = [(i - 1, j), (i + 1, j), (i, j + 1), (i, j - 1)]
        for n in neighbours:
            # Check if the neighbour is inside the matrix
            if ((0 <= n[0] < A.shape[0]) and (0 <= n[1] < A.shape[1])):
                # Only add the neighbours that are not added yet
                if n not in numbers_to_sum:
                    numbers_to_sum.append(n)
                    
    # Add all numbers in the matrix that are neighbours
    result = 0
    for pair in numbers_to_sum:
        i, j = pair[0], pair[1]
        result += A[i][j]
    
    return result"
"def sum_larger(numlist, n):
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
    return summen";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            bil = 'M1'
        elif wt <= 5000:
            bil = 'M2'
        else:
            bil = 'M3'
    else:
        if wt <= 3500:
            bil = 'N1'
        elif wt <= 12000:
            bil = 'N2'
        else:
            bil = 'N3'
    return bil";"def sum_near_whole(A):
    summen = 0
    a = A.copy()
    for i in range(len(A)):
        for j in range(len(A[i])):
            if int(A[i][j]) == A[i][j]:
                if i != 0:
                    summen += a[i-1][j]
                    a[i-1][j]=0
                elif i != len(a):
                    summen += a[i+1][j]
                    a[i+1][j]=0
                
                if j != 0:
                    summen += a[i][j-1]
                    a[i][j-1]=0
                    
                elif j != len(a[i]):
                    summen += a[i][j+1]
                    a[i][j+1]=0
    return summen"
"def sum_larger(numlist,n):
    
    summen = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            summen += numlist[i]

    return summen
";"def car_type(n_pass, wt, person):
    
    if person == ""True"":
        if n_pass > 8:
            if wt > 5000:
                kategori = ""M3""
            else:
                kategori = ""M2""
        else:
            kategori = ""M1""
         
    else:
        if wt > 12 000:
            kategori = ""N3""
        elif wt > 3500:
            kategori = ""N2""
        else:
            kategori = ""N1""
        
    return kategori";"import numpy as np

def sum_near_whole(A):
    
#Plan: lage et sett som best√•r av tallene ved siden av, slik at de bare summeres en gang. Problem: hvis to tall p√• ulike plasser har samme verdi vil de ikke bli plusset sammen.

    resultat = set()
    
    for linje in A:
        for i in range(len(A[linje])):
            if i[1] == 0: 
                a = A[linje][i+1] #tallet etter
                b = A[linje][i-1] #tallet f√∏r
                
                resultat.add(a)
                resultat.add(b)
            
                B = A.reshape()  #fors√∏k p√• √• transpose A. Da vil tallet under heller bli ved siden av. Vet ikke om det funker.
                c = B[linje][i+1] 
                resultat.add(c)
            
    
    summen = 0
    for tall in resultat:
        summen += tall
    
    return summen
    
    
"
"def sum_larger(numlist, n):
    sum = 0
    for i in range(len(numlist)):  #itererer gjennom listen for √• sjekke hvert tall.
        if i > n: 
            sum += i
    return sum
    
    
    
    #range fungerer slik(start,stopp, intervall). hvis vi setter inn kun et tall, slik jeg gj√∏r ved √• ta lengden til listen(antall elementer), vil iterasjonen kj√∏re 4 ganger, ved en liste p√• 4 tall. 
    #. i f√•r da f√∏rst verdien til f√∏rste element, ved andre iterasjon f√•r i verdien til andre element osv. 
    # Kan deretter bruke if setning til √• sjekke om verdien til i er st√∏rre enn veriden til n.
    #funksjonen vil n√• plusse p√• tallet i til sum kun hvis dette tallet er st√∏rre enn n.
    #returnerer deretter summen etter for l√∏kken har iterert gjennom hele listen.
    #for √• f√• denne funksjonen til √• kj√∏re m√• man kalle p√• den og definere en liste og en verdi for n.
    ";"print(""Skriv inn True for persontransport, og False for varettransport, under katergoriern person i funksjonen"")

def car_type(n_pass,wt,person):
    if person == ""True"":
        if n_pass <= 8:     #regner med at bruker skriver inn antall passasjerplasser.
            return (""M1"")
        else:               #vil n√• sjekke for alle andre sitteplasser mer enn 8
            if wt <= 5000:
                return (""M2"")
            else:
                return (""M3"")
                
    elif person == ""False"":
        if wt <= 3500:
            return (""N1"")
        elif wt > 3500 and wt < 12000:  #kunne ogs√• skrevet: 3500<wt<12000
            return (""N2"")
        else:
            return (""N3"")
            
    else: 
        print(""Du har ikke skrevet inn en gyldig parameter for person. Dette progremmet skiller kun mellom persontransport og varetransport"")
        
        
        #funksjon m√• kalles p√• for √• fungere:)
        #funksjon vil stoppe med en gang den kommer til return, for deretter √• skrive ut returnert verdi.
        
    ";"def sum_near_whole(A):   #A er 2D numpy arrayet.
    linje = A.split(""\n"")  #splitter arrayet for hver linje, slik at jeg kan iterere.
    sum = []              #√∏nsker √• putte tallene jeg finner i tom liste, sets senere..
    for tall in linje:
        if tall[2:]== """":   #sjekker om tallet har noe etter punktum
            sum.append[tall]
        else:
            pass
                           #har forh√•pentligvis en liste med kun int tall n√•.
    for i in A:
        if A[i] in sum:    #√∏nsker √• finne posisjon til int tallene i arrayet.
        
def sum_near_whole(A):
    sum = [] #√∏nsker √• f√• oversikt over heltall ved √• plassere de i liste
    for linjer in A: #itererer gjennom hele arrayet. pga 2D array, ser vi n√• p√• hver linj
        for tall in A[i]: #itererer videre for hvert tall i hver linje
            if tall == int(tall): #hvis dette tallet er likt heltallet av seg er desim=0
                sum.append[tall]  #legger tallet til i listen for heltall
                
    for verdier in A:
        if verdier in sum:
            

    summen = 0
    for i in range(len(set)):  #set tilsvarer settet jeg ville laget ut fra verdiene 
        sum+=set[i]
        
    return summen
    
    
    #var litt vanskelig √• uttrykke det jeg √∏nsker i koden. Uten pr√∏ving og feiling ved kj√∏ring av kode, s√• skriver det jeg programmerer i tillegg.
    #f√∏rst er m√•let √• finne posisjonen til tallene som har desimal null. beskrevet fremgangsm√•te i funksjonen.

    
    
    #Ville ha laget sets helt til slutt for √• fjerne evt like verdier i sum listen, siden summen ikke skal inkludere duplikater. Deretter ville jeg iterert gjennom listen med sum verdier for √• finne slutt summen. Skrev inn denne koden over."
"def sum_larger(numlist, n):
    resultat = 0
    for i in numlist:
        if i > n:
            resultat += i
    return resultat";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    else:
        if wt > 12000:
            return ""N3""
        elif wt > 3500 and wt < 12000:
            return ""N2""
        elif wt < 3500:
            return ""N1""";"import numpy as np

def sum_near_whole(A):
    ny_liste = []
    for rad in A:
        for tall in rad:
            if int(tall) == tall:
                if tall not in ny_liste:
                    if tall in A[0]:
                        ny_liste.append(A[1][tall])
                    elif tall in A[len(A[rad])-1]:
                        ny_liste.append(A[len(A)-2][tall])
                    elif tall in A[rad][0]:
                        ny_liste.append(A[rad][1])
                    elif tall in A[rad][len(A[tall])-1)]:
                        ny_liste.append(A[rad][len(A[tall]-2)])
                        
    summen = np.sum(np.array(ny_liste))
    return summen
                    
                    
                    "
"def sum_larger(numlist, n):
    st√∏rre_enn_n = []
    for i in range(len(numlist)):
        if numlist[i] > n:
            st√∏rre_enn_n.append(numlist[i])
    return sum(st√∏rre_enn_n)    ";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8:
            if wt > 5000:
                print(M3)
            else:
                print(M2)
        else:
            print(M1)
    else:
        if wt > 3500:
            if wt > 12000:
                print(N3)
            else:
                print(N2)
        else:
            print(N1)";"def sum_near_whole(A):
    skal_summeres = []
    for i in range(len(A)):
        for j in range(len(row)):
            heltall = int(A[i][j])
            if heltall == A[i][j]:
                skal_summeres.append(A[i][j])
         
                a = A[i+1][j]
                skal_summeres.append(a)
                b = A[i-1][j]
                skal_summeres.append(b)
                c = A[i][j+1]
                skal_summeres.append(c)
                d = A[i][j-1]
                skal_summmers.append(d)"
"def sum_larger(numlist,n):
    result = 0
    for i in numlist:
        while numlist[i] > n: 
            result += numlist[i]
    return result
            ";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass >= 8 and wt < 5000:
            return ""M2""
        elif wt > 5000:
            return ""M3""
        else: 
            return ""M1""
    else:
        if wt < 3500:
            return ""N1""
        elif wt > 3500 and wt < 12000:
            return ""N2""
        else:
            return ""N3""
        ";"import numpy as np
def sum_near_whole(A):
    result = 0
    for i in range(len(A)-1):
        for j in range(A[i]):
            if A[i][j] %= 0:
                result = (A[i][j+1] + A[i][j-1]) + (A[i+1][j] + A[i-1][j])
    return result
                
    "
"import numpy as np
import matplotlib as plt 

def sum_larger(numlist, n):
    
    L = []
    for i in len(numlist):
        if numlist[i] > n:
           L.append(i)
        
        
    for L in range k:
        n = 0
        return L
        
print(abs(L))
           
            
        ";"def car_type(n_pass, wt, person):
    
    if (wt <= 3500) while (person == False and n_pass = 0):
        return N1
        
    for wt in range(3500, 11999):
        if (person == False and n_pass = 0):
            return N2
        
    if (wt >= 12000) while (person == False and n_pass = 0):
        return N3
        
    if n_pass > 8 while (person == True):
        if wt < 5000:
            return M2
        return M3
        
    if (n_pass < 8) while (person == True):
        return M1
        
# beh√∏ver vi √• skrive et kall p√• funskjonen? Tolker det slik at vi ikke m√• det siden det ikke er spesifisert.";"import numpy as np
import matplotlib as plt 

def sum_near_whole(A):
    L = []
    i = A[i]
    for i in range(len(A)):
        if ((([i-4] or [i+4] or [i-1] or [i+1] ) % 1 )== 0):
            return L.append(i)
    
    # k = L[i] usikker p√• om jeg m√• definere dette globalt eller om det holder √• ha det her
    SUM = ()
    for k in range(len(L)):
        if k in SUM:
            SUM.difference(L)
        else:
            SUM = SUM + k
        return SUM
    
print(sum_near_whole(A))
        

# fikk d√•rlig tid til √• l√∏se denne oppgaven... men her ville jeg: ha laget en if setning  hvor alle elementer ""i"" som itererer gjennom, ble  append'et inn i en tom liste dersom elementet sto (i-4 : over) (i +1 : til h√∏yre for) , (i-1 : til venstre for) eller (i+4 : under) et element som gir i % 1 == 0.

# deretter ville jeg laget en for-l√∏kke hvor alle elementene i denne listen ble summert og dereter printet denne."
"def sum_larger(numlist, n):
    summen = 0
    for i in len(numlist):
        if numlist[i] > n:
            summen += numlist[i]
    return summen";"#n_pass=antall plasser utover f√∏rersete, wt=vekt, person=True om persontransport, False om varetransport. Returnere feks N1 eller M2 etc.
def car_type(n_pass, wt, person):
    if person == False: #Om det er varetransport
        if wt <= 3500: #Om vekt er mindre eller lik 3500kg
            return ""N1""
        elif 3500 < wt <= 12000: #Om vekt er over 3500kg eller mindre eller lik 12000 kg
            return ""N2""
        else: #Om vekt er over 12000 kg
            return ""N3""
    else: #Om det er persontransport
        if n_pass <= 8: #Om vi har max 8 ekstra seter
            return ""M1""
        elif wt <= 5000: #Om vekt er mindre eller lik 5000 kg
            return ""M2""
        else: #Om vekt er st√∏rre enn 5000 kg
            return ""M3""";"def sum_near_whole(A):
    sum = 0.0
    
    
    for rad in range(A):
        for tall in range(rad):
            heltall = round(tall) #For √• se om tallet er heltall
            if tall == heltall:
                if not tall[0] or tall[3]: #midterste tall
                sum += rad[tall+1] #Tall til h√∏yre
                sum += rad[tall-1] #Tall til venstre
                elif tall[0]:
                sum += rad[tall+1] #Tall til h√∏yre
                elif tall[3]:
                sum += rad[tall-1] #Tall til venstre
            if rad == 0: #F√∏rste rad
                sum += rad+1[tall]
            if rad == 4: #Siste rad
                sum += rad-1[tall]
    return sum(A)"
"
liste = [4,7,2,25,8,14,1]

def sum_larger(l,n):
    larger = []
    for i in l:
        if l[i]>n:
            larger.append(int(l[i]))
    return sum(larger)    
    
    

funksjonen skal ta alle de tallene i listen som er over tallet n og legge dem til en ny liste som det blir returnert summen av";"
M1 = {}
M2 =
M3 =
N1 =
N2 =
N3 =

DIC = {M1,M2,M3,N1,N2,N3}


def car_type():
    cars = []
    for i in dic:
        if n_pass<8:
            cars = [M1,N1,N2,N3]
            if wt
        else:
            cars = []
            
            
            
jeg ville lage en for-l√∏kke som tok for seg hver parameter og returnerte tilsvarende biler";"import numpy as np


def sum_near_whole(A):
    for i in range(A):
        
        for j in range(A[i]):
            if A[i][j]%1=0:
                A[i,j-1] + A[i,j+1] + A[i-1,j] + A[i+1,j]
            
    
    
funksjonen skal f√∏rst iterere gjennom A for √• finne ut om det er heltall i A.
for s√• √• summere verdiene rundt"
"def sum_larger(numlist, n):
    result = 0
    
    for element in numlist:
        if element > n:
            result += element
            
    return result";"# Antar datatype int for n_pass og wt, og datatype bool for person

def car_type(n_pass, wt, person):
    
    if person:
        if n_pass < 9:
            return ""M1""
        if wt <= 5000:
            return ""M2""
        return ""M3""
        
    if wt <= 3500:
        return ""N1""
    if wt <= 12000:
        return ""N2""
    return ""N3""";"###
    # Antagelse: Et heltall som st√•r inntil et annet heltall skal v√¶re med i summen.
    # Derfor sjekkes det ikke om gjeldende element, A[i, j], selv er et heltall.
###

def sum_near_whole(A):
    result = 0
    bottom = len(A) - 1
    right = len(A[0]) - 1
    
    for i in range(len(A)):
        for j in range(len(A[0])):
            
            cell = A[i, j]
            
            if i:
                if A[i - 1, j] % 1 == 0:
                    result += cell
                    continue
            
            if j:
                if A[i, j - 1] % 1 == 0:
                    result += cell
                    continue
                
            if i != bottom:
                if A[i + 1, j] % 1 == 0:
                    result += cell
                    continue
                
            if j != right:
                if A[i, j + 1] % 1 == 0:
                    result += cell
    
    return result
    "
"def sum_larger(numlist,n):
    resultat = 0
    for i in numlist:
        if i > n:
            resultat += i
    return resultat
    
    
";"def car_type(n_pass,wt,person):
    if person == True:
        if wt =< 5000 and n_pass <=8:
            return ""M1""
        elif n_pass > 8 and wt<=5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif 3500<wt<=12000:
            return ""N2""
        else:
            return ""N3""
            
    ";"def sum_near_whole(A):
    resultat = 0
    for i in A:
        for k in i:
            if len(k) > 2:
                try: #Det vil komme feilmelding om det ikke st√•r noen tall der. Out of range eller noe
                    resultat += (A[i,k-1])
                    A[i,k-1] = 0
                    resultat += (A[i,k+1])
                    A[i,k+1] = 0
                    resultat += (A[i-1,k])
                    A[i-1,k] = 0
                    resultat += (A[i+1,k])
                    A[i+1,k] = 0
    return resultat"
"def sum_larger(numlist, n):
    sum = 0
    
    for tall in numlist:
        if tall > n:
            sum += tall
    
    return sum";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8:
            if wt > 5000:
                return 'M3'
            else:
                return 'M2'
        else:
            return 'M1'
        
    else:
        if wt > 12000:
            return 'N3'
        else:
            if wt > 3500:
                return 'N2'
            else:
                return 'N1'
        
    ";"# Forklarer ideen av programmet for √• f√• frem tankegangen om programmet er feil (hadde litt d√•rlig tid):
# √ònsker √• iterere gjennom A og finne alle tall som tilfredsstiller kravet
# S√• pr√∏ver jeg √• lage en liste med alle andre tall som ligger ved siden av hvert av disse tallene jeg leter etter
# Jeg legger tallene til listene som strenger, for √• i tillegg kunne legge til indeksen som hvert av de andre tall ligger p√• som en del av hver individuell streng.
# Dvs. Pr√∏ver √• legge til en streng som best√•r av tallet, kolonne indeksen og rad indeksen
# Da kan jeg fjerne alle tall som er lik verdi og har lik posisjon fordi det betyr at det er samme tall, bruker et set til dette
# Til slutt summerer jeg alle verdiene

import numpy as np

def sum_near_whole(A):
    sum = []
    
    for j in range(len(A)):
        rad = A[j]
        
        for i in range(len(rad)):
    
            if float(int(rad[i]) == rad[i]:
                index = [A.index(j), rad.index(rad[i])]
                if index[1] == 0:
                    sum.append(str(rad[i+1]) + str(index[0]+1) + str(index[1]))
                elif index[1] == len(rad)-1
                    sum.append(stre(rad[i-1]) + str(index[0]-1) + str(index[1]))
                else:
                    sum.append(str(rad[i+1]) + str(index[0]+1) + str(index[1]))
                    sum.append(str(rad[i-1]) + str(index[0]-1) + str(index[1]))
                
                if index[0] == 0:
                    sum.append(str(A[j+1, i]) + str(index[0]) + str(index[1]+1))
                elif index[0] == len(A)-1:
                    sum.append(str(A[j-1, i]) + str(index[0]) + str(index[1]-1))
                else:
                    sum.append(str(A[j+1, i]) + str(index[0]) + str(index[1]+1))
                    sum.append(str(A[j-1, i]) + str(index[0]) + str(index[1]-1))
                    
    sum = float(set(sum))
    sum = np.sum(sum)
    
    return sum"
"def sum_larger(numlist, n):
    sum=0
    for i in range(len(numlist)):
        if i>n:
            sum+=i
    return sum";"def car_type(n_pass, wt, person):
    if person=True:
        if n_pass=<8:
            return M1
        if n_pass=>9 and wt=<5000:
            return M2
        else:
            return M3
            
    if person=False:
        if wt=<3500:
            return N1
        if wt>3500 and wt=<12000:
            return N2
        else:
            return N3";"def sum_near_whole(A):
    nei takk
    break"
"def sum_larger(numlist, n):
    result = []
    for i in numlist:
        if i > n:
            result.append(i)
    return sum(result)
    ";"def car_type(n_pass, wt, person):
    if person == true:
        if n_pass < 8 and wt < 5000
            return 'M1'
        elif n_pass > 9 and wt < 5000:
            return 'M2'
        elif n_pass > 9 ant wt > 5000:
            return 'M3'
        else:
            return 'tast inn noe gyldig'
    else:
        if wt < 3500:
            return 'N1'
        elif wt < 12000:
            return 'N2'
        elif wt > 12000:
            return 'N3'
        else:
            return 'tast inn noe gyldig'";"def sum_near_whole:
    from_row = [] #itererer gjennom alle radene og legger alle tall til venstre eller h√∏yre for et heltall i en liste
    for i in A:
        for j in A[i]:
            if i % 2 == 0:
                from_row.append(A[(i+1)]), from_row.append(A[(i-1)])
                from_row.remove(A[(i+1)]), from_row.remove(A[(i-1)])
    from_column = []
    for i in A[:,j] #fors√∏kte √• gj√∏re om kolonnene til lister og gj√∏re det samme med dem som over"
"def sum_lager(numlist,n):
    summen = 0
    for i in range(len(numlist)):  #G√• gjennom listen
        if numlist[i] > n:         #Dersom tallet i listen er st√∏rre enn n skal summen plusses med tallet
            summen += numlist[i]
    
    return summen                  #Returnerer summen";"def car_type(n_pass,wt,person):
    if person == False and wt > 12000:
        return ""N3""
    elif person == False and wt > 3500 and wt < 12000:
        return ""N2""
    elif person == False and wt <= 3500:
        return ""N1""
    elif person == True and n_pass > 8 and wt > 5000:
        return ""M3""
    elif person == True and n_pass > 8 and wt <= 5000:
        return ""M2""
    else:
        return ""M1""
        

#I denne funksjonen legges det inn elif setninger med oppgave beskrivelsen over. Det returneres en kategori dersom alle argumeneten stemmer i samme if-setning.";"import numpy as np   
def sum_near_whole(A):
    summen = []
    for rad in A:
        for element in range(len(rad)):
            if rad[element] == int(rad[element]):  #√ònsker √• finne n√•r tallet som er helltall 
                #Ser at denne if-setningen blir litt feil, men vet ikke hvordan jeg skal sette det opp
                summen.append(rad[element+1])      #Legger til tallet som er p√• h√∏yre side til summen
                summen.append(rad[element-1])      #Legger til tallet som er p√• venstre side til summen
                summen.append(A[rad+1][elemet])    #Legger til tallet under 
                summen.append(A[rad-1][element])   #Legger til tallet over
        
    summen = set(summen)                           #Fjerner elementer om de blir lagt til flere ganger
    summ = []
    for tall in summen:
        summ.append(summen[tall])                  #Legger til elementene i settet til en liste
    summen = np.array(summ)                        #Gj√∏r det om til et array
    summen = np.sum(summen)                        #Bruker innebygd numpy funksjon for √• summere sammen tallene
    
    return summen"
"def sum_larger(num,n):
    s=0
    for i in num:
        if i>n:
            s+=i
    return s";"def car_type(n_pass,wt,person):
    if person:
        if n_pass<=8:
            return ""M1""
        elif wt<5000:
            return ""M2""
        else:
            return""M3""
    else:
        if wt<3500:
            return ""N1""
        elif wt<12000:
            return ""N2""
        else:
            return ""N3""
            ";"def sum_near_whole(A):
    heltall=[]
    n√¶rtall=set()
    
    for r in range(len(A)):
        for k in range(len(A[r])):
            if float(int(A[r][k]))==A[r][k]:
                heltall.append([r,k])
    for p in heltall:
        r = p[0]
        k = p[1]
        if r+1 <= len(A):
            n√¶rtall.add([r+1,k])
        if r-1 >= 0:
            n√¶rtall.add([r-1,k])
        if k+1 <= len(A[0]):
            n√¶rtall.add([r,k+1])
        if k-1 >= 0:
            n√¶rtall.add([r,k-1])
    sum = 0
    for p in n√¶rtall:
        sum += A[p[0]][p[1]]
    return sum
    
    "
"def sum_larger(numlist, n):
    sum = 0
    for i in numlist:
        if i > n:
            sum += i
    return sum
            ";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        elif wt > 5000:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt > 3500 and wt <= 12000:
            return ""N2""
        elif wt > 12000:
            return ""N3""";"def sum_near_whole(A):
    sum = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if int(A[i][j]) == A[i][j]:
                sum += A[i][j-1]
                sum += A[i][j+1]
                sum += A[i+1][j]
                sum += A[i-1][j]
                
                
    return sum"
"def sum_lager(numlist,n):
    resultat=0
    for i in numlist:
        if i>n:
            resultat+=i
    return resultat";"def car_type(n_pass,wt,person):
    if person==True:
        if n_plass>8:
            if wt>5000:
                return M3
            else:
                return M2
        else:
            return M1
    else:
        if wt>12000:
            return N3
        elif wt>3500:
            return N2
        else:
            return N1";"def sum_near_whole(A):
    total=0
    myset=set()
    for i in range(len(A)):
        for j in range(len(A[i])):
            if j.round()==j:
                myset.append((A[i][j-1]))
                myset.append((A[i][j+1]))
                myset.append((A[i-1][j]))
                myset.append((A[i+1][j]))
    for i in myset:
        total+=i
    return total"
"def sum_larger(numlist, n):
    for i in numlist
        if i > n:
            sum += i #summerer tall st√∏rre enn n
        return sum";"def car_type(n-pass, wt, person):
    while person == true
        if n-pass == 8: 
            print(""M1"")
        elif n_pass > 8 and wt <= 5000:
            print(""M2"")
        elif n_pass > 8 and wt > 5000:
            print(""M3"")
    while person == false
        if wt <= 3500:
            print(""N1"")
        elif wt > 3500 and wt <= 12000:
            print(""N2"")
        elif wt > 12000:
            print(""N3"")
    return";"import numpy as np

def sum_near_whole(A):
    for i in A #finner hvert ledd i arrayet
        if i == int(i) #vurderer hvert ledd for v√¶re heltall
            x = A[i+1] #finner tallene rundt heltallene
            y = A[i+5]
            z = A[i-5]
            t = A[i-1]
    return np.sum(x, y, z, t) #returnerer summen av tallene"
"def sum_larger(numlist,n):
    svar = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            svar += numlist[i]
    return svar
        ";"def car_typen(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            print('M1')
            
        elif wt < 5000:
            print('M2')
            
        else:
            print('M3')
    
    else:
        if wt < 3500:
            print('N1')
            
        elif 3500 =< wt < 12000:
            print('N2')
        
        else:
            print('N3')";"def sum_near_whole(A):
    ny = ()
    for i in range(A):
        for j in range(A[i]):
            if j == int(j):
                if j != -1:
                    ny.union(A[i][j+1])
                elif j!= 0:
                    ny.union(A[i][j-1])
                elif i != 0:
                    ny.union(A[i-1][j])
                elif: i!= -1:
                    ny.union(A[i+1][j])
                return ny
    Svar = sum(ny)
    return Svar"
"def sum_larger(numlist, n):
    new = []
    for item in numlist:
        if item > n:
            new.append(item)
    
    return sum(new)

";"def car_type(n_pass, wt, person):
    if person:
        
        if n_pass <= 8:
            return ""M1""
        
        elif n_pass > 8 and wt < 5000:
            return ""M2""
        
        else:
            return ""M3""
    
    else:
        if wt <= 3500:
            return ""N1""
        
        elif 3500 < wt <= 12000:
            return ""N2""
        
        else:
            return ""N3""
    
    ";"def sum_near_whole(A):
    used = set()
    
    for i in range(1,len(A)-1):
        for j in range(1,len(A[0])-1):
            f = A[i, j] == int(A[i, j])
            
            if f:
                used.add([i+1, j])
                used.add([i-1, j])
                used.add([i, j+1])
                used.add([i, j-1])
    
    for c in range(1):
        for k in range(1, len(A[0])-1):
            f = A[c, k] == int(A[c, k])
            
            if f:
                used.add([c+1, k])
                used.add([c, k+1])
                used.add([c, k-1])
    
    for a in range(len(A)-1, len(A)):
        for b in range(1, len(A[0])-1):
            f = A[a,b] == int(A[a,b])
            
            if f:
                used.add([a-1, b])
                used.add([a, b+1])
                used.add([a, b-1])
    
    for l in range(1, len(A)-1):
        for p in range(1):
            f = A[l,p]== int(A[l,p])
            
            if f:
                used.add([l+1,p]
                used.add([l,p+1])
                used.add([l-1, p])
    
    for q in range(1, len(A)-1):
        for y in range(len(A[0])-1, len(A[0])):
            f = A[q, y] == int(A[q, y])
            
            if f:
                used.add([q+1, y])
                used.add([q-1, y])
                used.add([q, y-1])
                
    if A[0,0] == int(A[0,0]):
        used.add([0,1])
        used.add([1, 0])
    
    if A[0, len(A)-1] == int(A[0, len(A[0])-1]):
        used.add([0,len(A)-2])
        used.add([1, len(A)-1])
    
    if A[len(A)-1, 0] == int(A[len(A)-1, 0]):
        used.add([len(A)-1, 1])
        used.add([len(A)-2, 0])
    
    if A[len(A[0])-1, len(A)-1] == int(A[len(A)-1, len(A[0])-1]):
        used.add([[len(A[0])-1, len(A)-2]])
        used.add([len(A[0])-2, len(A)-1])
    
    return used

def sum(lst):
    used = list(used)
    sum = 0
    for item in used:
        sum += A[item[0], item[1]]
    
    return sum

    
    
    "
"def sum_larger(numlist,n):
    s=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            s+=numlist[i]
    return s";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"def sum_near_whole(A):
    heltall=[] #Finner alle heltallene i A
    for i in range(len(A)):
        for j in range(len(A[i])):
            try int(A[i][j]):
                heltall.append([i,j])
            except:
                t=0 #Turte ikke √• ikke skrive noe her, men t er ikke brukt
    
    sum=0 #Adderer alle tallene som har koordinater en ifra et heltall
    for k in range(len(A)):
        for l in range(len(A[k])):
            if [k,l] not in heltall:
                if ([k+1,l] in heltall or [k-1,l] in heltall or [k,l+1] in heltall or [k,l-1] in heltall):
                    sum += A[k][l]
        
    return sum"
"def sum_larger(numlist,n):
    sum = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            sum += numlist[i]
    return sum";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass =<7:
            return ""M1""
            
        else:
            if wt =< 5000:
                return ""M2""
            else:
                return ""M3""
    else:
        if wt =< 3500:
            return ""N1""
        elif 3500 < wt =< 12000:
            return ""N2""
        else:
            return ""N3""";"def sum_near_whole(A):
    sum = []
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j]%1==0:
                try:
                    sum.append(A[i][j+1])
                try:
                    sum.append(A[i][j-1])
                try:
                    sum.append(A[i+1][j])
                try:
                    sum.append(A[i-1][j+1])
    sum = set(sum)
    finalsum = 0
    
    for p in range(len(sum)):
        finalsum += sum[p]
    
    return finalsum
                "
"def sum_larger(numlist,n):
    summen = 0
    
    for el in numlist:
        if el > n:
            summen += el
    return summen
            ";"def car_type(n_pass, wt, person):
    
    if person == True:
        
        if n_pass < 9:
            return ""M1""
            
        else:
            if wt <= 5000:
                return ""M2""
            else: 
                return ""M3""
            
        
        
        
    
    
    else:
        
        if wt <= 3500:
            return ""N1""
        elif 3500 < wt <= 12000:
            return ""N2""
            
        else: 
            return ""N3""
    ";"def sum_near_whole(A):
    tall = []
    summen = 0
    
            
            #sjekker om desimalen er lik 0
            
    for row in A:
        for i in range(len(A)):
            for j in range(len(A[0])):
                
               if (i == 0) and (j == 0):
                   if row[i] == int(row[i]):
                    tall.append[A[0][1]]
                    tall.append(A[1][0])
        
                    
                elif (i == 0) and (not(j == 0)):
                    if A[i][j] == int(A[i][j]):
                        tall.append(A[i][j+1])
                        tall.append(A[i][j-1])
                        tall.append(A[i+1][j])
                    
                    
                elif (1 =< i < len(A) - 1) and (1=< j < len(A[0]) -1 ): 
                    
                    if row[i] == int(row[i]):
                    
                    tall.append(row[i+1])
                    tall.append(row[i-1])
                    tall.append(A[i-1][j])
                    tall.append(A[i+1][j])
                    
                elif ((i != 0) and (j == len(A[0])-1 )):
                    if i == len(A)-1:
                        if A[i][j] == int (A[i][j]):
                            tall.append(A[i][j-1])
                            tall.append(A[i-1][j])
                        
                        
                    
                    else:
                        if A[i][j] == int(A[i][j]):
                            tall.append(A[i+1][j])
                            tall.append(A[i-1][j])
                        
            
        
    # gj√∏r om listen til en mengde slik at hvert tall bare blir representert en gang    
    mengde_av_tallene = set(tall)
    
    til_liste_igjen = list(mengde_av_tallene)
    
    for el in til_liste_igjen:
        summen += el
        
        
    return summen"
"def sum_larger(numlist, n):
    biggerlist = []
    for num in numlist:
        if num > n:
            biggerlist.append(num)
    return sum(biggerlist)";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8:
            if wt > 5000:
                type = ""M3""
            else:
                type = ""M2""
        else:
            type = ""M1""
    else:
        if wt > 12000:
            type = ""N3""
        elif 3500 < wt <= 12000:
            type = ""N2""
        else:
            type = ""N1""
    return type";"import math

def sum_near_whole(A):
    
    adjnum = []                                                 #oppretter er tom liste adjacent number
    
    for i in range(len(A)):                                     #itererer gjennom linjene i arrayet
        
        for j in range(len(A[i])):                              #itererer gjennom tallene i linjene
            
            if A[i][j] == float(int(A[i][j])):                  #sjekker om tallet har 0 bak komma
                
                if i == 0:                                      #sjekker om tallet er i √∏verste rad
                    
                    if j == 0:                                  #sjekker om tallet er i f√∏rste kolonne
                        adjnum.append(A[i][j+1])
                        adjnum.append(A[i+1][j])
                    
                    elif j+1 == len(A[i]):                      #sjekker om tallet er i siste kolonne
                        adjnum.append(A[i][j-1])
                        adjnum.append(A[i+1][j])
                   
                    else:
                        adjnum.append(A[i][j-1])
                        adjnum.append(A[i][j+1])
                        adjnum.append(A[i+1][j])
                
                elif i+1 == len(A):                             #sjekker om tallet er i siste rad
                    
                    if j == 0:
                        adjnum.append(A[i][j+1])
                        adjnum.append(A[i-1][j])
                    
                    elif j+1 == len(A[i]):
                        adjnum.append(A[i][j-1])
                        adjnum.append(A[i-1][j])
                    
                    else:
                        adjnum.append(A[i][j-1])
                        adjnum.append(A[i][j+1])
                        adjnum.append(A[i-1][j])
                
                else:                                           
                    
                    if j == 0:
                        adjnum.append(A[i][j+1])
                        adjnum.append(A[i+1][j])
                        adjnum.append(A[i-1][j])
                    
                    elif j+1 == len(A[i]):
                        adjnum.append(A[i][j-1])
                        adjnum.append(A[i+1][j])
                        adjnum.append(A[i-1][j])
                    
                    else:                                       #tallet havner her om det er helt frittst√•ende
                        adjnum.append(A[i][j-1])
                        adjnum.append(A[i][j+1])
                        adjnum.append(A[i+1][j])
                        adjnum.append(A[i-1][j])
    return sum(adjnum)"
"import numpy as np

def sum_larger(numlist, n): 
    numlist = ([2,5,4,7,3,8,], n)
    n = 5
    nyListe = []
    for i in range len(numlist):
        if i > n:
            nyListe.append()
            
    
    summen = np.sum(nyListe)
    return sum 

print(sum)


     ";"car_type(n_pass, wt, person):
    n_pass = int(input(""Hvor mange personer er det plass til i bilen? "")
    wt = float(""Hvor mye er totalvekten i kg? "")
    person = (""Er det persontransport eller varetransport?"")
    
    M1 (personbil): max 8 sitteplasser i tillegg til f√∏rersetet.
    M2 (buss): over 8 sitteplasser, totalvekt ikke over 5000 kg
    M3 (buss): over 8 sitteplasser, totalvekt over 5000 kg
    
    N1 (varebil): tillatt totalvekt ikke over 3500 kg.
    N2 (lastebil): tillatt totalvekt p√• over 3500 kg men ikke over 12000 kg.
    N3 (lastebil): tillatt totalvekt over 12000 kg.
    
    if (n_pass =< 8 and person == persontransport):
        return M1
    elif (n_pass > 8 and wt =< 5000 and person == persontransport):
        return M2
    elif(n_pass > 8 and wt >5000 and person == persontransport):
        return M3
    elif (person == varetransport and wt =<3500):
        return N1
    elif (person ==varetransport and 3500 < wt =< 12000):
        return N2
    elif  (person == varetransport and wt =<12000):
        return N3 
    
    
        
        
    ";"import numpy as np 
def sum_near_whole(A): 
    
    numbers = 
    
    summen = np.sum(numbers)"
"def sum_larger(numlist, n):
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
        
    return summen
        ";"def car_type(n_pass, wt, person):
    
    if person == True:
        if n_pass <= 8:
            return ""M1""
        
        elif n_pass > 8 and wt < 5000:
            return ""M2""
        
        else:
            return ""M3""
    
    else:
        if wt > 12000:
            return ""N3""
        
        elif wt > 3500:
            return ""N2""
        
        else:
            return ""N1""";"def sum_near_whole(A):
    summen = 0
    for i in range(A):
        if A[i] % 1 = 0:
            x = A[i+1]
            y = A[i-1]
            z = A[i-4]
            a = A[i+4]
            summen +=(x+y+z+a)
    return summen"
"def sum_lagrer(numlist, n):
    liste = []                          #oppretter tom liste
    for i in range (len(numlist)):      #itererer igjennom numlist
        if numlist[i] > n:              #derson hver verdi i numlist er st√∏rre enn 5
            liste.append(numlist[i])    #..skal den legges til i 'liste'
    return sum(liste)                   #returnerer summen av alle verdiene i liste";"def car_type(n_pass, wt, person):
    if person == True:              #sjekker om persontransport
        if n_pass <= 8:             
            kategori = ""M1""
        else:
            if wt => 5000:          #antar at n√•r det st√•r 'ikke over', betyr det at eksakt 5000kg er med i M2 
                kategori = ""M3""
            else:
                kategori = ""M2""
    else:                           #varetransport
        if wt > 12000:
            kategori = ""N3""
        elif 3500 < wt <= 12000:
            kategori = ""N2""
        else:
            kategori = ""N1""
    return kategori";"def sum_near_whole(A)
    liste = []                                      #Oppretter tom liste
    for i in range(len(A[0])):                      #dobbel for-l√∏kke, itererer igjennom hele A
        for j in range(len(A)):                     #iterer f√∏rst radene i og s√• kolonnene med j
            if A[i][j] == int(A[i][j]):             #sjekker heltall, dersom ikke avrundet ved bruk av int
                if i != 0:                          #hvis  i ikke er 0 s√• finnes det et tall til venstre
                    liste.append(A[i-1][j])         #legger til i lista
                if i+1 < len(A[0]):                 #dersom true, finnes et tall til h√∏yre
                    liste.append(A[i+1][j])
                if j != 0:                          #dersom true, finnes et tall over
                    liste.append(A[i][j-1])
                if j+1 < len(A):                    #dersom true, finnes tall under
                    liste.append(A[i][j+1])
    return sum(liste)"
"def sum_larger(numlist, n):
    ny_liste = []
    for tall in numlist:
        if tall > n:
            ny_liste.append(tall)
    return sum(ny_liste)";"def car_type(n_pass, wt, person):
    if n_pass == 7:
        retrun 'M1'
    elif n_pass > 8 and wt < 5000:
        return 'M2'
    elif n_pass > 8 and wt > 5000:
        return 'M3'
    elif wt < 3500:
        return 'N1'
    elif wt > 3500 and wt < 12000:
        return 'N2'
    else:
        return 'N3'";"import numpy as np
def sum_near_whole(A):
    liste_tall = []
    for line in A:
        for tall in line:
            if tall == int(tall):
                liste_med_tillegg = [line[tall+1], line[tall-1], A[line+1][tall], A[line-1][tall]]
               for i in liste_med_tillegg:
                   try: 
                       liste_tall.append(liste_med_tilleg[i])
                   
                    except indexerrors:
                        break
    set(liste_tall)
    return sum(liste_tall)
                    "
"def sum_larger(numlist,n):
    liste =[]
    for i in range(len(numlist)+1):
        if numlist[i]>n:
            liste.append(numlist[i])
    return sum(liste)";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass <= 8:
            return 'M1'
        elif n_pass > 8 and wt >5000:
            return 'M3'
        else:
            return 'M2'
    elif person == False:
        if wt<=3500:
            return 'N1'
        elif wt>12000:
            return 'N3'
        else:
            return 'N2'";"def sum_near_whole(A):
    liste =[]
    for i,j in range(len(A)):
    if A[[i][j]]%1==0:
        try:
            # pr√∏ver √• legge til elementene over,under samt ved siden av heltallet, og fjerner heltallet ved bruk av difference
            liste.append(A[[i-1:i+1][j-1:j+1]].difference(A[[i][j]]))
        else:
            none
    return sum(liste)

"
"def sum_larger(numlist, n):
    summen = 0
    for i in range(len(numlist)):
        if numlist[i]>n:
            summen+=numlist[i]
    return summen
sum_larger([2,5,4,7,3,8],5)";"def car_type(n_pass, wt, person):
    if person:
        if n_pass<8:
            return ('M1')
        else:
            if wt<=5000:
                return ('M2')
            else:
                return('M3')
    else:
        if wt <= 3500:
            return ('N1')
        elif wt > 3500 and wt<=12000:
            return ('N2')
        else:
            return('N3')
car_type()";"import numpy as np
def sum_near_whole(A):
    summen=0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j]==int(A[i][j]):
                if not(j == 3):
                    summen+=A[i][j+1]
                if not(j == 0):
                    summen+=A[i][j-1]
                if not(i==3)
                    summen+=A[i+1][j]
                if not(i==0):
                    summen+=A[i-1][j]
                #jeg vet at samme tall ville blitt addert inn to ganger
    return summen
    "
"def sum_larger(numlist,n):
    
    for tall in numlist:
        s=0
        for i in range(len(numlist)):
            
            if tall[i]>n:
            
                s+=numlist[i]
                
            else:
                s+=0
    
    return s
sum_larger(numlist,n)";"def car_type(n_pass,wt,person):
    
    kategori= ''
    if person==True:
        
        if n_pass<=8:
            kategori+='M1'
            
        elif n_pass>8 and wt<=5000:
            kategori+='M2'
        
        elif n_pass>8 and wt>5000:
            kategori+='M3'
            
    if person==False:
        
        if wt<=3500:
            kategori+='N1'
            
        elif 3500>wt<=12000:
            kategori+='N2'
        
        elif wt>12000:
            kategori+='N3'
    
    
    return kategori
    
car_type(n_pass,wt,person)";"def sum_near_whole(A):
    s=0
    
    for lst in A:
        for j in range(len(A)):
        
            for i in range(len(lst)):
                if i==0 and j==0:
            
                    if int(lst[i])==int(lst[i].strip('.')):  #sjekker om det er heltall
                
                
                        s+=lst[j+1][i]+lst[j][i+1]     #s er summen av tallene under og til h√∏yre for heltallet,                                fordi det ikke er noe tall over og til venstre for                                      heltallet.
                
                elif 0<i<len(lst) and 0<j<len(A):
                    
                    if int(lst[i])==int(lst[i].strip('.')):  #sjekker om det er heltall
                    
                        s+=lst[j+1][i]+lst[j-1][i]+lst[j][i+1]+lst[j][i-1]   #s er summen av tallene  under,over, til                                                  h√∏yre og til venstre for heltallet. 
                
                elif i==len(lst) and j==len(A):
                    
                     if int(lst[i])==int(lst[i].strip('.')):   #sjekker om det er heltall
                         
                         s+=lst[j-1][i]i+lst[j][i-1]     #s er summen av tallene over og til venstre for                                        heltallet, fordi det ikke er noe tall under eller til                                  h√∏yre for heltallet.
                        
                    
    return s
    
sum_near_whole(A)
        
    
    
    "
"def sum_larger(numlist,n):
    total = 0
    for element in numlist:
        if element > n:
            total+=element
    return total";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        else:
            if wt <= 5000:
                return ""M2""
            else:
                return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt > 12000:
            return ""N3""
        else:
            return ""N2""";"def sum_near_whole(A):
    tall = []       
    verdiertattmed= []
    for i in range(len(A)):                  
        for j in range(len(A[i])):             
            if A[i][j]==int(A[i][j]):           
                if j < (len(A[i])-1):
                    if f""A[{i}][{j}+1]"" not in verdiertattmed:
                        tall.append(A[i][j+1])
                        verdiertattmed.append(f""A[{i}][{j}+1]"")
                if j > 0:
                    if f""A[{str(i)}][{str(j)}-1]"" not in verdiertattmed:
                        tall.append(A[i][j-1])
                        verdiertattmed.append(f""A[{str(i)}][{str(j)}-1]"")
                if i == 0 and len(A)>=(2):
                    if f""A[{str(i)}+1][{str(j)}]"" not in verdiertattmed:
                        tall.append(A[i+1][j])
                        verdiertattmed.append(f""A[{str(i)}+1][{str(j)}]"")
                elif i == (len(A)-1):
                    if f""A[{str(i)-1}+1][{str(j)}]"" not in verdiertattmed:
                        tall.append(A[i-1][j])
                        verdiertattmed.append(f""A[{str(i)}-1][{str(j)}]"")
                else:
                    if f""A[{str(i)}-1][{str(j)}]"" not in verdiertattmed:
                        tall.append(A[i-1][j])
                        verdiertattmed.append(f""A[{str(i)}-1][{str(j)}]"")
                    if f""A[{str(i)}+1][{str(j)}]"" not in verdiertattmed:
                        tall.append(A[i+1][j])
                        verdiertattmed.append(f""A[{str(i)}+1][{str(j)}]"")
    summen = 0
    for k in tall:
        summen+=k
    return summen
                
                
                "
"def sum_larger(numlist, n): 
    summen = 0
    for i in numlist: 
        if numlist[i] > n: 
            summen += numlist[i]
    return summen

";"def car_type(n_pass, wt, person): 
    if person == True: 
        if n_pass > 8: 
            if wt > 5000: 
                return ""M3""
            else: 
                return ""M2""
        else: 
            return ""M1""
            
    else: 
        if wt < 3500: 
            return ""N1""
        elif 3500 < wt < 12000: 
            return ""N2""
        else: 
            return ""N3""


    ";"def sum_near_whole(A): 
    summen = 0
    for rad in range(len(A)): 
        for j in range(len(A[rad])): 
            if int(rad[j]) == rad[j]:
                if j != 0: 
                    summen += rad[j-1]
                if j != len(rad): 
                    summen += rad[j+1]
                if rad != 0: 
                    summen += A[rad-1][j]
                if rad != len(a): 
                    summen += A[rad+1][j]
            
    return summen

#Vil definere en sum hvor jeg etter hvert vil legge til tallene som oppfyller kravene
#Bruker en for-l√∏kke for rader
#Bruker en for-l√∏kke for kolonner
#Vil at For-l√∏kken for rader g√•r igjennom hver rad og ser etter heltall
#Vil at For-l√∏kken for kolonner g√•r igjennom hver kolonne og ser etter heltall
#S√• vil jeg at funksjonen legger til tallene som oppfyller kravene
    #Tanken er √• finne disse tallene ved √• bruke neste rad med samme nummer for kolonne
    #Setter betingelsen at heltallet av en verdi skal v√¶re lik verdien i arrayet, ...
    # ... basert p√• at de verdiene dette gjelder for vil v√¶re like de samme verdiene med 0 som desimal
#kom ikke p√• hvordan jeg skulle f√• et tall til √• kun bli lagt inn en gang, s√• er klar over at funksjonen ikke gj√∏r dette. 
"
"def sum_larger(numlist, n):
    
    L = numlist
    
    for i in range len(L):
        
        if L[i] > n:
            
            a += L[i]
    
    return a";"def car_type(n_pass, wt, person):
    
    if person == True:
        
        if n_pass > 8 and wt > 5000:
            return ""M3""
        
        elif n > 8 and wt < 5000:
            return ""M2""
        
        else:
            return ""M1""
    
    else:
        
        if wt > 12000:
            return ""N3""
        
        elif wt > 3500: 
            return ""N2""
        
        else:
            return ""N1""";"def sum_near_whole(A):
    
    for i in range len(A):
        
        for j in range len(A[i])
            if A[i]//1 > 0:
            
                a += A[i-1] + A[i+1]"
"import numpy as np
import random as ra

def sum_larger(numlist, n):
    x = max.[numlist] + max[numlist]-1
    return x 
    
    ";"person = [M1, M2, M3]
varetransport = [N1, N2, N3]
def car_type(n_pass, wt, person):
    return str[person] + str[varetransport]
    
    ";"def sum_near_whole([A]):
    if x in range[A]:
        x = int([A])
        
a = input(""hva heter du?"")
b = input(""Hva synes du om ITGK?"")
print(""I hater ITGK, det e s√• s√• s√• s√• vanskelig"")"
"def sum_larger(numlist, n):
    s = 0
    for i in range[numlist]:
        if i > n:
            s = sum(i)
    return s";"def car_type(n_pass, wt, person):
    if wt > 12000 and person == False:
        return 'N3'
    elif:
        wt > 3500 and person == False
        return 'N2'
    elif:
        wt <= 3500 and person == False
        return 'N1'
    elif:
        n_pass > 8 and wt > 5000 and person == True
        return 'M3'
    elif:
        n_pass > 8 and wt < 5000 and person == True
        return 'M2'
    elif:
        n_pass <= 8 and person == True
        return 'M1'";"def sum_near_whole(A):
    s = 0
    for i in range(A):
        if i == int(i):
            s = sum(i+[i+1], (i+[i-1], i+[i+4], i+[i-4])
    return s"
"def sum_larger(numlist, n): 
    summen = 0 
    for tall in numlist: 
        if tall > n: 
            summen += tall 
            
    return summen 
    
sum_larger([2,5,4,7,3,8], 5)
    
    ";"def car_type(n_pass, wt, person): 
    kategori = [""M1"", ""M2"", ""M3"", ""N1"", ""N2"", ""N3""] #alle mulige kategorier 
    if person == True: #varetransport
        kategori =[""N1"", ""N2"", ""N3""] #mulige kategoriene hvis det er varetransport 
        if wt > 12000: 
            kategori = kategori[2]
        elif wt > 3500 or wt <= 12000: 
            kategori = kategori[1]
        elif wt <= 3500: 
            kategori = kategori[0] 
        
        
    elif person == False: #persontransport 
        kategori = [""M1"", ""M2"", ""M3""] #mulige kategorier hvis det er persontransport 
        if n_plass >8 and wt >= 5000:
            kategori = kategori[2]
            
        elif n_plass > 8 and wt < 5000: 
            kategori = kategori[1]
            
        elif n_plass <= 8: 
            kategori = kategori[0]
        
        
    return kategori 
    
car_type(n_pass, wt, person)
#g√•r ut fra at n_pass er sitteplasser utenom f√∏reren, dersom n_pass = 1 er dermed totalt antall sitteplasser 2 ";"import numpy as np 

def sum_near_whole(A): 
    summen = 0
    A = list(A) 
    
    for rad in A:
        for i in range(len(rad)): 
            
            if round(rad[i]) == rad[i]:
                
                if rad[i] == rad[0]: #gjelder for tallene i raden 
                    summen += rad[1]
               
                elif rad[i] != rad[0] or rad[i] != rad[-1]:
                    summen += rad[i + 1] + rad[i - 1]
                    
            if rad == A[0]:  #gjelder for radene i A 
                summen += A[1][i]
            elif rad == A[-1]:
                summen += A[-2][i]
            else: 
                summen += A[rad - 1][i] + A[rad+1][i]
        
                
    return summen 
    
sum_near_whole(A) 

#sjekker om tallet f√∏rst har.0, hvis den har det skal den ta tallet ved siden av seg og legge til i summen. m√• derfor sjekke om tallet i raden st√•r f√∏rst, i midten eller sist. m√• gj√∏re det samme med rader "
"def sum_larger(numlist,n):
    summen=0
    for i in numlist:
        if numlist[i]>n:
            summen+=i
    return summen";"def car_type(n_pass,wt,person):
    
    if n_pass<=8 and person==True:
        return M1
        
    elif:
        n_pass>8 and wt<=5000 and person==True:
            return M2
    
    elif:
        n_pass>8 and wt>=5000 and person==True:
            return M3
            
    elif:
        wt<=3500 and person==False:
            return N1
    
    elif:
        3500<wt<=12000 and person==False:
            return N2
            
    elif:
        wt>12000 and person==False:
            return N3
            
    ";"import nympy as np

def sum_near_whole(A):
    
    tall=[]
    
    for rad in range(len(A)):
        
        for i in range(len(A)):
            
            if A[i]==int(A[i]): #Skjekker om tallet er int eller float
                tall.append([i+1]) #pr√∏ver her √• legge til tallet til h√∏yre for heltallet
                tall.append([i-1]) #pr√∏ver her √• legge til tallet til venstre for heltallet
                tall.append(A[rad+1][i]) #pr√∏ver her √• legge til tallet under heltallet der rad+1 er raden under der heltallet er                         og ""i"" blir tallet under heltallet
                tall.append(A[rad-1][i]) #pr√∏ver her √• legge til tallet over heltallet
                
            
    return sum(tall)       #pr√∏ver her √• returnere summen av alle tallene i lista ""tall"" 
            
        "
"def sum_larger(numlist, n):
    sum_num = 0
    for num in list: 
        if num > n: 
            return sum_num += num
        else: 
            continue # Fortsetter til neste verdi num i lista dersom tallet ikke er st√∏rre enn n 
            
    return sum_num

sum_larger([1, 2, 3, 4, 5, 6, 7], 3)";"def car_type(n_pass, wt, person):
    
    types =  list('M1', 'M2', 'M3','N1', 'N2','N3')
    for car in types:
        
        if person == True:
            if n_pass <= 8:
                return car[0]
            elif n_pass >= 8 and wt <= 5000:
                return car[1]
            elif n_pass >= 8 and wt > 5000: 
                return car[2]
        
        elif person == false:
            if wt <= 3500: 
                return car[3]
            elif 3500 <= wt <= 12000:
                return car[4]
            else: 
                return car[5]
    return car
    
car_type(9, 5400, True)
    
    
    
    
    
    
    
    
    


    
    ";"def sum_near_whole(A):
    sum_tall = 0
    for lst in A: 
        for num in lst: 
            if len(int(lst[num])) == len(lst[num])-1: #unders√∏ker om de har samme lengde, tar h√∏yde for desimal uten tall bak
                sum_tall += (lst[num+1] + lst+1[num] + lst-1[num]) # legger til tallet ved siden av heltallet og tallet under, alts√• num for neste liste
                if num in sum_tall:
                    continue #hopper over tall hvis det allerede er brukt tidligere
    return sum_tall

        






                "
"def sum_larger(numlist, n):
    summen = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            summen += numlist[i]
    return summen";"def car_type(n_pass, wt, person):
    if person:
        if n_pass > 8:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    if not person:
        if wt > 12000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        else:
            return ""N1""
        
        ";"def sum_near_whole(A):
    tall = []
    indekser = []
    for i in range(len(A)):
        for j in range(len(A[i])):
            if (str(A[j, i]))[-1] == (""0"" or "".""):
                if i > 0:
                    tall.append(A[j, i - 1])
                    indekser.append([j, i -1])
                if i < len(A) - 1:
                    tall.append(A[j, i + 1])
                    indekser.append([j, i + 1])
                if j > 0:
                    tall.append(A[j - 1, i])
                    indekser.append([j - 1, i])
                if j > len(A[i]) - 1:
                    tall.append(A[j + 1, i])
                    indekser.append([j + 1, i])
    for i in range(len(indekser)):
        if indekser[i] in (indekser[:i] or indekser[i + 1:]):
            tall.remove(A[indekser[i][0], indekser[i][1]])
            
    return sum(tall)"
"def sum_larger(numlist, n):
    total = 0
    for i in numlist:
        if i > n:
            total += i
    return total";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8:
            if wt > 5000:
                resultat = 'M3'
            else:
                resultat = 'M2'
        else:
            resultat = 'M1'
    elif: person == False:
        if wt > 12000:
            resultat = 'N3'
        elif 1200 => wt > 3500:
            resultat = 'N2'
        else:
            resultat = 'N1'
    return resultat";"def sum_near_whole(A):
    total = []
    for i in A:
        if i == #heltall:
            total.append(A[i+1], A[i-1], A[i+4], A[i-4])
            if A[i] in total:
                total.remove(A[i])
    total = sum.total
    return total
    
#ide: Gj√∏re at total er en liste, i den hensikt at man kan fjerne enheter fra listen
#     for s√• √• finne totalen av enhetene i lista."
"def sum_larger(numlist,n):
    tall_st√∏rre =[]
    summen = 0
    for tall in numlist:
        if tall > n:
            tall_st√∏rre.append(tall)
        else:
            continue
    
    for i in tall_st√∏rre:
        summen += i
    return summen";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return 'M1'
        else:
            if wt <= 5000:
                return 'M2'
            else:
                return 'M3'
    else:
        if wt <= 3500:
            return 'N1'
        elif wt <= 12000:
            return 'N2'
        else:
            return 'N3'";"def sum_near_whole(A):
    summen = 0
    dec_0 = []
    for i in range(len(A)-1):
        if A[i] >
        
        
        
        for index, tall in enumerate(rad):
            if tall.isdecimal():   #sjekker om det ikke inneholder deismaler
                dec_0.append(rad, index) #legger til rad og plassering i en ny liste
            if 
        for i in range(len(rad)-1):
            if 
                
        
        
        

#√∏sker √• sjekke hvert tall om det inneholder desimaler. Hvis det gj√∏r det, vil jeg lagre plassering, b√•de rad og index
#N√•r jeg g√•r igjennom arrayet √∏nsker jeg da √• legge til de tallene som er nabo med det tallet som jeg har lagt i dec_0
#
#N√•r jeg har f√•tt lagt alle disse tallene i en egen liste,jeg bruker √• en if setning og sjekker om tallet allerede er i listen. Hvis det er det, bruker jeg continue slik at tallet ikke blir lagt til 2 ganger.
#loper s√•gjennom den listen og finner summen av den
"
"#numlist = liste med heltall
#n = et heltall
def sum_larger(numlist,n):
    sum = 0
    for i in range(len(numlist)):
        if i > n:
            sum += i
        return sum";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif (n_pass >= 8) and (wt > 5000):
            return ""M3""
        elif (n_pass >= 8) and (wt <= 5000):
            return ""M2""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt > 12000:
            return ""N3""
        else:
            return ""N2""";"import numpy as np

def sum_near_whole(A):
    summen = []
    for i in range(len(A)):
        string_i = str(i)
        for j in range(len(string_i)):
            if i[-1] in [""0"",""."","" ""]:
               if number not in summen:
                    summen.append(A[i+1][i])
                    summen.append(A[i][i+1])
                    summen.append(A[i-1][i])
                    summen.append(A[i][i-1])
    summen2 = float(summen)
    result = np.sum(summen2)
    return result
        
            
# Denne koden vil ikke fungere, men min tankegang er at jeg ved √• konvertere elementene til streng kan sjekke om det siste elementet er 0,. eller "" "".
# Dersom det stemmer skal elementet foran, over, under og bak legges i listen ""summen.""
#Til slutt konverterer jeg elementene i listen til floats og bruker numpy.sum for √• summere floatsene."
"def sum_larger(numlist, n):
    sum = 0
    for i in numlist:
        if i > n:   #sjekker om taller er st√∏rre enn tallet oppgitt, og legger til det tallet om det er st√∏rre
            sum += i
    return sum";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt > 3500 and <= 12000:
            return ""N2""
        else:
            return ""N3""";"
def sum_near_whole(A):
    sum = 0
    for i in range(len(A)):
        for j in range(len(A[i])): #siden radene og kolonnene har forskjellig lengde 
            if (A[i+1,j] - int(A[i+1,j]) == 0) or (A[i-1,j] - int(A[i-1,j]) == 0) or A[i,j+1] - int(A[i,j+1]) == 0 or (A[i,j-1] - int(A[i,j-1]) == 0): #sjekker om et tall st√•r ved siden av over eller under et heltall ved √• trekke fra int av tallet, siden desimal andel droppes ved omgj√∏ring
                sum += A[i,j] #legger til tallet om en av betingelsene eller flere infris
    return sum"
"import numpy as np
def sum_larger(numlist,n):
    ny_liste = []
    for i in numlist(len(numlist)):
        if numlist[i] > n:
            ny_liste.append(numlist[i])
    sum_ny_liste = np.sum(ny_liste)
    return sum_ny_liste
    
        
    ";"def car_type(n_pass, wt, person):
    
    if person == persontransport:
        if n_pass < 8:
            return M1
        if n_pass > 8 and wt <= 5000:
            return M2
        if n_pass > 8 and wt > 5000:
            return M3
    if person == varetransport:
        if wt <= 3500:
            return N1
        if wt > 3500 and wt < 12000:
            return N2
        if wt > 12000:
            return N3
";"import numpy as np
def sum_near_whole(A):
    ny_liste[]
    for i in A:
        for j in i:
            if A[i][j] == #har null som desimal
                #lete etter tallene rundt og appende de til den nye listen for √• s√• summere elementene i listen. 

    return sum_ny_liste

sum_near_whole(A)"
"def sum_larger(x, n):
    Sum = 0
    for i in range(len(x)):
        if x[i] > n:
            Sum = Sum + x[i]
        else:
            Sum = Sum
    return Sum";"def car_type(n_pass, wt, person):
    if person == False:
        if wt < 3500:
            return ""N1""
        elif wt > 3500 and wt < 12000:
            return ""N2""
        elif wt > 12000:
            return ""N3""
        else:
            return ""not posible""
    if person == True:
        if n_pass <= 7:  #det sto antall sitteplasser uttover f√∏rersete i oppgaven s√• antar at man ikke teller med                   #f√∏rersetet da
            return ""M1""
        elif n_pass > 7:
            if wt < 5000:
                return ""M2""
            if wt > 5000:
                return ""M3""
    return";"import numpy as np
def sum_near_whole(A):
    Sum = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if int(A[i:j]) == S[i:j]:
                if i == 0:
                    Sum = Sum + A[(i-1):j]
                if i == A[len(A)]:
                    Sum = Sum + A[(i+1):j]
                if j == 0:
                    Sum = Sum + A[i:(j+1)]
                if j == len(A[i]):
                    Sum = Sum + A[i:(j-1)]
                elif 0 < i < A[len(a)]:
                    Sum = Sum + A[(i-1):j] + A[(i+1):j]
                elif 0 < j < len(A[i]):
                    Sum = Sum + A[i:(j+1)] + A[i:(j-1)]
    return Sum"
"def sum_larger(numlist, n):
    sum = 0
    for i in numlist:
        if i> n:
            sum += i
    return sum
    ";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8 and wt > 5000:
            return ""M3""
        if n_pass > 8 and wt < 5000:
            return ""M2""
        else:
            return ""M1""
    else:
        if wt < 12000:
            return ""N3""
        elif wt >= 3500:
            return ""N2""
        else:
            return ""N1""";"def sum_near_whole(A):
    sum = 0
    s = set()
    for i in range(len(A) - 1):
        for j in range(len(A[i]) - 1):
            if str(A[i][j])[2] == ('0' or ''):
                s.add(A[i][j+1])
                s.add(A[i+1][j])
                s.add(A[i][j-1])
                s.add(A[i-1][j])
    for x in s:
        sum += x
    return sum
    # her antar jeg at samme desimaltall ikke st√•r flere steder i A
                "
"def sum_larger(numlist, n):
    sum = 0
    for num in numlist:
        if numlist[num] > n:
            sum += numlist[num]
    return sum";"def car_type(n_pass, wt, person):   #Jeg g√•r utifra at sitteplasser (n_pass) og vekten (wt) blir lagt inn som et tall
    vic = """"
    if person == True:
        vic += ""M""
        
        if n_pass <= 8:
            vic += ""1""
        elif n_pass > 8 and wt <= 5000:   
            vic += ""2""
        else:
            vic += ""3""
        
    else:
        vic += ""N""
        
        if wt <= 3500:
            vic += ""1""
        elif 3500 < wt >= 12000:
            vic += ""2""
        else:
            vic += ""3""
            
    return vic
    ";"def sum_near_whole(A):
    import numpy as np
    sum = 0
    indx = 0
    for i in A:
        for j in A[i]:
            if j

    return sum"
"def sum_larger(numlist,n):
    res = 0
    for num in numlist:
        if num > n:
            res += num
    return res
    ";"def car_type(n_pass, wt, person):
    if person:    
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"def sum_nearwhole(A):
    result = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if (A[i][j] / A[i][j] == int(A[i][j]) / A[i][j]) or A[i][j] == 0:
                if i < len(A) and j < len(A[i]):
                    result += A[i][j+1] + A[i+1][j]
                if i < len(A) and j == len(A[i]):
                    result += A[i+1][j]
                if i == len(A) and j < len(A[i]):
                    reult += A[i][j+1]
                if j < 0:
                    result += A[i][j-1]
    return result"
"
def sum_larger(numlist, n):
    sum=0
    
    for tall in numlist:
        if tall>n:
            sum+=tall   #legger til tallet i summen om det er st√∏rre enn ""n""
    
    return sum
";"
def car_type(n_pass, wt, person):
    
    
    if person==True:
        
        if n_pass<=8:
            return ""M1""
        else:
            if wt<=5000:
                return ""M2""
            else:
                return ""M3""
                
    
    if person==False:
        
        if wt<=3500:
            return ""N1""
        elif wt<=12000:
            return ""N2""
        else:
            return ""N3""
    
    
    
    
    
    
    
";"import numpy as np

def er_heltall(tall):   #Denne funksjonen finner ut om et tall slutter p√• "",0"" eller ikke
    if (tall*10)%10==0:
        return True
    else return False



def sum_near_whole(A):
    res=[]          #lager en liste til √• legge inn verdier.
    sum=0
    
    for rad in A:           #Lager en n√∏stet for-l√∏kke, for √• legge til verdier til h√∏yre og venstre.
        
        for i in range(len(rad)):   #Har med dette to indexer som representerer en plass i arrayet.
            
            if er_heltall(A[rad][i]):   #Tester om tallet p√• den plassen er et heltall.
                try:        #Bruker try for √• unng√• error index out of range. Om index ikke finnes g√•r koden videre.
                    res.append(A[rad][i+1]) #Appender tallet som ligger til h√∏yre.
                try:
                    if i!=0:                        #Appender kun hvis i!=0, fordi [i-1] vil ellers bli [-1] som er siste elementet i lista.
                        res.append(A[rad][i-1])     #Appender tallet som ligger til venstre.
    
    
    for r in range(len(A)):  #Lager enda en n√∏stet for-l√∏kke, for √• legge til verdier opp og ned.
        
        for j in range(len(A[0])):
            
            if er_heltall(A[r][j]):
                try:
                    res.append(A[r+1][j])
                try:
                    if r!=0:
                        res.append(A[r-1][j])       #Appender kun hvis r!=0 av samme grunn som isted.
        
    
    
    for tall in res:    #Summerer alle tallene som ligger ved et heltall.
        sum+=tall
        
    
    return sum
    
    

    "
"def sum_larger(numlist, n):
    
    ny_liste= []
    
    for i in numlist:
        if i > n:
            ny_liste.append(n) 
            #lager liste med bare tall som er st√∏rre enn n
            
    summen = sum(ny_liste) #summerer alle tallene som er st√∏rre enn n

    return summen
            
    ";"def car_type(n_pass, wt, person):
    
    if person == true: #persontransport vil g√• inn her
        if n_pass <= 7:
            return ""M1""
        elif n_pass ==8 and wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    
    # skjekker n√• varetransport
    
    if totalvekt <= 3500:
        return ""N1""
    elif totalvekt <= 12000:
        return ""N2""
    else:
        return ""N3""
        ";"def sum_near_whole(A):
    
    tall = [] #liste med tall som skal summeres
    
    for row in A:
        for e in row:
            if int(e) == e: #skjekker om e er et heltall
                tall.append(row[e+1]) #legger til tallene p√• h.side av e
                tall.append(row[e-1]) #legger til tallene p√• v.side av e
                tall.append(A[row-1][e]) #legger til tallet over e
                tall.append(A[row+1][e]) #legger til tallet under e
    
    tall = set(tall) #fjerner duplikater
    summ = sum(list(tall)) #summen av tallene
    
    return summ
    
#samme kode, men skjekker om tallene rundt eksisterer, slik at vi skal unng√• √• f√• feilmelding.
    
def sum_near_whole(A):
    
    tall = [] 
    
    for row in A:
        for e in row:
            if int(e) == e: 
                if 0 < row < len(A) and 0 < e < len(row):
                    #E ligger i midten
                    tall.append(row[e+1]) 
                    tall.append(row[e-1]) 
                    tall.append(A[row-1][e]) 
                    tall.append(A[row+1][e]) 
                if row == 0:  #√òverste rad
                    tall.append(A[row+1][e])
                    if 0 < e < len(row): #e er ikke p√• kanten
                        tall.append(row[e+1]) 
                        tall.append(row[e-1]) 
                    elif e == 0:# er p√• v.side
                        tall.append(row[e+1]) 
                    else: #e er p√• h.side
                        tall.append(row[e-1]) 
                if row == len(A): #Nederste rad
                    tall.append(A[row-1][e])
                    if 0 < e < len(row):
                        tall.append(row[e+1]) 
                        tall.append(row[e-1]) 
                    elif: e == 0:
                        tall.append(row[e+1]) 
                    else:
                        tall.append(row[e-1]) 
    
    tall = set(tall) 
    summ = sum(list(tall)) 
    
    return summ
    
"
"def sum_larger(numlist, n):
    summen = 0
    for tall in numlist:
        if tall > n:
            summen += tall
    
    return summen";"def car_type(n_pass, wt, person):
    if person == False:
        if wt > 12000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        else:
            return ""N1""
    elif n_pass > 8 and wt > 5000:
        return ""M3""
    elif n_pass > 8:
        return ""M2""
    else:
        return ""M1""
        ";"import numpy as np

def sum_near_whole(A):
    Summen = 0
    en_dim = []                 #Pr√∏ver √• lage en 2d liste hvor de innerste listene er radene og kolonnene
    for rad in A:
        en_dim.append(rad)
    
    for j in range(len(A[0])):
        en_dim.append(A[:,j])     #Legger til kolonnene
        
    for liste in en_dim:
        Sett = {}
        for i in range((len(liste))-1):
            if len(str(liste[i])) == 1:
                Sett.add(i+1)
            if len(str(liste[i+1])) == 1:
                Sett.add(i)
            
        Summen += sum(sett)
    
    return Summen

    
                
                
            "
"def sum_larger(numlist, n):
    resultat = 0
    for tall in numlist:
        if tall > n:
            resultat += tall
    return resultat ";"def car_type(n_pass, wt, person):
    if person = True:
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt > 3500 and wt <= 12000:
            return ""N2""
        else:
            return ""N3""
    ";"def sum_near_whole(A):
    result= 0
    for rad in A:
        for nr in rad:
            if nr == int(nr):
                result = result + A[rad][[nr]-1] + A[rad][[nr]+1] + A[[rad]-1][nr] + A[[rad]+1][nr]
    return result
    
#Har problemer med √• finne ut av hvordan jeg skal unng√• at samme tall blir lagt inn i resultat. Kunne evt. lagt alle tallene inn i en liste og sjekke om alle tallene var unike, og deretter summert tallene i lista, men det f√∏les ikke helt riktig ut √• gj√∏re hehe. 
    
print(""God Jul:)"")
"
"import numpy as np

def sum_larger(numlist,n):
    result = 0
    for i in range(len(numlist)):
        if numlist[i]>n: 
            numlist[i] = int(numlist[i])
            result += numlist[i]
    return result 
        ";"def car_type(n_pass,wt,person):
    if person == True: #persontransport
        if n_pass <= 8: 
            print('M1')
        elif n_pass > 8 and wt <= 5000: 
            print('M2')
        elif n_pass > 8 and wt > 5000: 
            print('M3')
    else:               #varetransport 
        if wt <= 3500: 
            print('N1')
        elif 3500 < wt <= 12000: 
            print('N2')
        elif wt > 12000: 
            print('N3')

        ";"import numpy as np

def sum_near_whole(A): 
    Ny_A = np.array[]
    #finne indeksplassene med tall som st√•r over, under eller ved siden av et helt tall
    For i in range(len(A)): 
        for j in range(len(A[i])):
            if [i][j] not in Ny_A:  #sjekke plassering 
                if ([i][j-1] == #helt tall 
                or [i][j-1] == #helt tall 
                or [i-1][j] == #helt tall 
                or [i+1][j] == #helt tall): 
                Ny_A.append(A[i][j]) #legge de til i det nye arrayet.
    Ny_A = sum(Ny_A) #summerer verdiene i arrayet
    return Ny_A
    "
"def sum_larger(numlist,n):
    sum = 0
    for num in numlist:
        if num > n:
            sum += num
    return sum";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass =< 8:
            print('M1')
        elif:
            wt =< 5000:
                print('M2')
        else:
            print('M3')
    if person == False:
        if wt=< 3500:
            print('N1')
        elif wt =< 12000:
            print('N2')
        else:
            print('N3')
            ";"import numpy as np

def sum_near_whole(A):
    value = []
    summen = 0
    for list in A:
        for num in list:
            if num == int(num):
                rad_v = A[list][num-1] 
                rad_h = A[list][num+1]
                col_o = A[list-1][num] 
                col_u = A[list+1][num]
                value.append(rad_v)
                value.append(rad_h)
                value.append(col_o)
                value.append(col_u)
                    summen += np.sum(set(value))
    return summen"
"def sum_larger(numlist, n):
    output = 0
    for num in numlist:
        if num > n:
            output += num
    return output";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            category = ""M1""
        elif wt <= 5000:
            category = ""M2""
        else:
            category = ""M3""
    else:
        if wt < 3500:
            category = ""N1""
        elif wt < 12000:
            category = ""N2""
        else:
            category = ""N3""
    return category";"def sum_near_whole(A):
    coords = []
    output = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i,j] == int(A[i,j]):
                n = 0
                while n < 4:
                    n += 1
                    y = i
                    x = j
                    if n == 0:
                        y = i-1
                    elif n == 1:
                        y = i+1
                    elif n == 2:
                        x = j-1
                    else:
                        x = j+1
                    if (y,x) in coords:
                        continue
                    try:
                        output += A[y,x]
                        coords.append((y,x))
                    except:
                        continue
    return output"
"def sum_larger(numlist,n):
    summen=0
    
    for tall in numlist:
        if tall>n:
        summen+=tall    
    
    return summen";"def car_type(n_pass,wt,person):
    if person==True:
        if n_pass>8 and wt>5000:
            return ""M3""
        elif n_pass>8 and wt<=5000:
            return ""M2""
        
        else:
            return ""M1""
            
            
    if person==False:
        if wt>12000:
            return ""N3""
            
        elif wt>3500 and wt<=12000:
            return ""N2""
            
        else:
            return ""N1""";"def sum_near_whole(A):
    summen=[]
    
    for i in range(len(A)):
        
        for j in range(len(A[i])):  #G√•r gjennom alle elementer i todlisten
            if A[i][j]%int(A[i][j])==0         #Sjekker om elementet er et heltall
                summen.append(A[i+1][j]+A[i-1][j]+A[i][j+1]+A[i][j-1])         
                
                             # I linje 8 fors√∏ker jeg √• legge til elementene ved siden                                av og over       
    ferdigsum=set(summen)   #Tar hensyn til at tallet kun skal med i summen en gang
    SUMMEN=sum(ferdigsum)
    
    return SUMMEN"
"def sum_larger(numlist,n):
    store_tall = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            store_tall += tall
            
    return store_tall";"def car_type(n_pass,wt,person):
    
    if person == True:
        if n_pass <= 8:
            return (""M1"")
        else:
            if wt <= 5000:
                return (""M2"")
            else:
                return (""M3"")
    
    else:
        if wt <= 3500:
            return (""N1"")
        elif wt > 3500 and wt <= 12000:
            return (""N2"")
        else:
            return (""N3"")
            
";"#antok at heltall ved siden av heltall ikke skulle plusses p√• i summen totalt

def sum_near_whole(A):
    sum_tall = 0
    for i in range(len(A)):
        for j in range(A[i]):
            
            if int(A[i][j]) % (A[i][j]) == 0:
                if int(A[i][j]) % (A[i][j]) != 0:
                    sum_tall += rad[j+1]
                    if 1 <= i < len(A):
                        if int(A[i-1][j]) % (A[i-1][j]) != 0:
                            sum_tall += rad[i-1][j]
                        if int(A[i+1][j]) % (A[i+1][j]) != 0:
                            sum_tall += rad[i+1][j]
    
    return sum_tall
            
                

    
    definerer en summen = 0
    iterer gjennom A, da radene, med for i in range(A)
    itererer gjennom raden med for j in range(A[i])
    finne heltall ved √• ta int av tallet modulo selve tallet, er heltall om det er lik 0
    sjekke om tallet ved siden av er et heltall, om ikke legges det til i summen
    lager en if l√∏kke for √• sjekke om i er st√∏rre eller lik 1 og mindre enn len(A)
    sjekker med en if l√∏kke om A[i-1][j] ikke er heltall og legger til summen hvis True
    sjekker med en if l√∏kke om A[i+1][j] ikke er heltall og legger til summen hvis True 
    unng√•r √• legge til samme tall mer enn en gang ved √• legge inn en if l√∏kke for √• sjekke 
    om tallet er lagt til fra f√∏r. Vil gj√∏re det ved √• sjekke om det er heltall ved siden av det gitte tallet.
    Hvis det ikke er det kan det legges til, hvis det er ved siden av et heltall, skal det ikke legges til.
    Bruker indeks til tallet, alts√• plass og sjekker samme indeks men en rad opp og en rad ned, og samme rad med 
    annen indeks for plassen ved siden av i raden.
    returnerer summen
    
    
    
            "
"def sum_larger(numlist, n):
    sum = 0
    for i in numlist:
        if i > n:
            sum += i
    return sum";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    else:
        if wt > 12000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        else:
            return ""N1""";"import numpy as np

def sum_near_whole(A):
    sum = 0
    am = np.zeros_like(A)
    dim_arr = am.shape()
    max_i = dim_arr[0]
    max_j = dim_arr[1]
    for i in range(A):
        for j in range(A[i]):
            if A[i, j] - round(A[i,j]) == 0:
                if i == 0:
                    am[i+1, j] = 1
                    if j == 0:
                        am[i, j+1] = 1
                    elif j == max_j:
                        am[i, j-1] = 1
                    else:
                        am[i, j-1] = 1
                        am[i, j+1] = 1
                elif i == max_i:
                    am[i-1, j] = 1
                    if j == 0:
                        am[i, j+1] = 1
                    elif j == max_j:
                        am[i, j-1] = 1
                    else:
                        am[i, j-1] = 1
                        am[i, j+1] = 1
                else:
                    am[i+1, j] = 1
                    am[i-1, j] = 1
                    if j == 0:
                        am[i, j+1] = 1
                    elif j == max_j:
                        am[i, j-1] = 1
                    else:
                        am[i, j+1] = 1
                        am[i, j-1] = 1
    for i in range(am):
        for j in range(am[i]):
            if am[i,j] == 1:
                sum += A[i,j]
    return sum"
"def sum_larger(numlist,n):
    summen = 0
    
    for tall in numlist:
        if tall > n:
            summen += tall
    
    return summen";"def car_type(n_pass,wt,person):
    if person:
        if n_pass <= 8:
            return 'M1'
        else:
            if wt <= 5000:
                return 'M2'
            else:
                return 'M3'
    else:
        if wt <= 3500:
            return 'N1'
        elif 3500 < wt <= 12000:
            return 'N2'
        else:
            return 'N3'";"def sum_near_whole(A):
    s = set()
    summen = 0
    
    for i in range(A):
        for j in range(A[i]):
            if A[i][j] % 1 == 0:
                s.add([i+1,j])
                s.add([i-1,j])
                s.add([i,j-1])
                s.add([i,j+1])
                
    for l in s:
        try:
            summen += A[l[0]][l[1]]
        except:
            pass
    
    return summen"
"def sum_larger(numlist, n):
    sum = 0
    for i in numlist:
        if i > n:
            sum += i
        else:
            pass
    return sum
    ";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8:
            if wt > 5000:
                car = ""M3""
            else:
                car = ""M2""
        else: 
            car = ""M1""
    elif person == False:
        if wt > 12000:
            car = ""N3""
        elif wt <= 3500:
            car = ""N1""
        else:
            car = ""N2""
    return car";"def sum_near_whole(A):
    sum = 0
    for i in A:
        for j in i:
            if j.isdigit() == True:
                if A[i][j-1].isdigit() == False:
                    sum += A[i][j-1]
                if A[i][j+1].isdigit() == False:
                    sum += A[i][j+1]
                if A[i-1][j].isdigit() == False:
                    sum += A[i-1][j]
                if  A[i+1][j].isdigit() == False:
                    sum += A[i+1][j]
            else:
                pass
    return sum"
"def sum_larger(numlist, n):
    larger = []
    
    for num in numlist:
        if num > n:
            larger.append(num)
            
    return sum(larger)        ";"def car_type(n_pass, wt, person):
    if person:
        if n_pass > 8:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    
    else:
        if wt <= 3500:
            return ""N1""
        elif wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"import numpy as np

def sum_near_whole(A):
    
    integers = []
    for i in range(len(A)):
        for j in range(len(A[0])):
            if A[i][j] == float(int(A[i][j])):
                integers.append([i, j])
    
    near_integers = []
    for idx in integers:
        near_integers.append([idx[0] + 1, idx[1]])
        near_integers.append([idx[0] - 1, idx[1]])
        near_integers.append([idx[0], idx[1] + 1])
        near_integers.append([idx[0], idx[1] - 1])
        
    near_int = []
    for indx in near_integers:
        if ((indx[0] >= 0) and (indx[0] <= len(A))):
            if ((indx[1] >= 0) and (indx[1] <= len(A[0]))):
                near_int.append([indx[0], indx[1]])
                
    S = []
    for indeks in set(near_int):
        S.append(A[indeks[0][indeks[1]])
        
    return sum(S)    
    "
"def sum_larger(numlist, n):
    sum = 0
    for number in range(numlist):
        if number in numlist>4:
            sum += number
    
sum_larger([3,6,2,3,8], 4)

#vil ha en funksjon som tar nummere i listen numlist og sjekker om de er st√∏rre enn n, alts√• 4, dersom de er det vil man at programmet skal pluss de tallene som er st√∏rre enn fire og dermed returnere summen.";"def car_type(n_pass, wt, person):
    plasser = int(intput(""Hvor mange tillate sitteplasser kan kj√∏ret√∏yet ha utenom f√∏rersetet?""))
    vekt = float(input(""Hva er totalvekten?""))
    type = """"
    if plasser >= 8:
        return True
        if plasser <= 8:
            print(""M1"")
        elif plass > 8 and vekt <= 5000:
            print(""M2"")
        elif plass > 8 and vekt > 5000:
            print(""M3"")
    else:
        return false
        if vekt <= 3000:
            print(""N1"")
        elif vekt > 3500 and vekt < 12000:
            print(""N2"")
        else: 
            print(""N3"")
    return type

car_type(n_pass, wt, person)
    
    ";"def sum_near_whole(A):
    sum = 0
    if number in A:
        
        numpy.ndarray.reshape()
        
    
    return sum
    

A = np.array([[1. ,4.1,4.7,8.1]
              [2.4,4. ,6.5,1.1]])
sum_near_whole(A)

#her ville jeg funnet alle tall som er heltall, alts√• int, ikke de som er float. Derretter ville jeg funnet tallene som er i posisjon innenfor et intervall p√• siden eller over eller under. Deretter ville jeg satt at dersom to tall i samme posisjon blir funnet skal det tallet bare brukes en gang. til slutt ville jeg lagt sammen alle tallene ved float og returnert funksjonen.
"
"def sum_larger(numlist, n):
    res = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            res += numlist[i]
    return res";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif (n_pass > 8) and (wt <= 5000):
            return ""M2""
        else:
            return ""M3""
            
    if person == False:
        if wt <= 3500:
            return ""N1""
        elif (wt >= 3500) and (wt <= 12000):
            return ""N2""
        else:
            return ""N3""";"def sum_near_whole(A):
    res = 0
    list_of_num = [] #Liste med tall som allerede er summert
    for i in range(len(A)):
        
        for j in range(len(A)):
            #Lager liste for √• sjekke om desimaldel er null
            list_num_dec = (str(A[i][j])).split('.')

            if (int(list_num_dec[-1]) == 0) and not in list_of_num:
                
                #Sjekker om indeksen finnes f√∏r tallene rundt legges til
                if (i > 0) and (i < len(A)):
                    res += A[i-1][j]
                    list_of_num.append(A[i-1][j])
                    
                if i < (len(A)- 2):
                    res += A[i+1][j]
                    list_of_num.append(A[i+1][j])
                    
                if (j > 0) and (j < len(A[i])):
                    res += A[i][j-1]
                    list_of_num.append(A[i][j-1])
                    
                if j < (len(A[i])-2):
                    res += A[i][j+1] 
                    list_of_num.append(A[i][j+1])
    return res"
"def sum_larger(lst,n):
    
    tallene = []
    
    for i in lst:
        if i>n:
            tallene.append(i)
    return sum(tallene)
    
sum_larger([2,5,4,7,3,8],5)";"def car_tyoe(n_plass, wt, person):
    type = []
    
    if person == ""True"":
        if n_plasser <= 8:
            type.append(""M1"")
        else:
            if wt>5000:
                type.append(""M2"")
            else:
                 type.append(""M3"")
    elif person == ""False"":
        if wt<3500:
             type.append(""N1"")
        elif wt>3500 and wt<1200:
             type.append(""N2"")
        else:
             type.append(""N3"")
    else:
        print(""n√• v√¶re False eller True"")
    return type
    
";"def sum_near_whole(A):
    
    tallene = []
    
    for rad in A:
        for tall in rad:
            if tall == int(tall):   #antar at for eksemepl 4.0 og 4 har samme verdi
                tallene.append(A[tall+1])
                tallene.append(A[tal-1])
                tallene.append(A[tall+4])
                tallene.append(A[tall-4])   
                
            else:
                None
                
                
                #tanker er √• legge til de tallene som er rundt ved  √• bruke indeksene som er ved siden av med +-en eller ved siden av med +-fire . men dette vil jo ikke fungere for de tallene som ikke har en nabo p√• indeks -1 osv.
                
    
    return sum(set(tallene))          #m√• fjerne tall som evt kommer to gagner, gj√∏r dermed om til et set.
    "
"def sum_larger(numlist, n):
    total=0
    
    for number in numlist:
        if number>n:
            total+=number
            
    return(total)";"def car_type(n_pass, wt, person):
    
    if n_pass<=8 and person=True:
        return M1
        
    elif n_pass>8 and wt<=5000:
        return M2
        
    elif n_pass>8 and wt>5000:
        return M3
        
    elif wt>12000:
        return N3
        
    elif 3500>wt>=12000:
        return N2
        
    else:
        return N1";"def sum_near_whole(A):
    
    the_sum=0
    
    for list in A:
        
        for number in list:
            
            number=str(number)
            
            if number[-1] == '0' or number[-1] == ' ':
                
                try:
                    
                    indexnumber=list.index[number]      #finner indeks til tallet for √• kunne bruke den senere
                    
                    venstre_tall=list[indexnumber-1]
                    hoyre_tall=list[indexnumber+1]
                    tall_over=A[list-1][indexnumber]
                    tall_under=A[list+1][indexnumber]
                    
                    the_sum = number + venstre_tall + hoyre_tall + tall_over + tall_under
                    
                except IndexError:
                    
    return the_sum
                    
                    
                    
#pr√∏ver alts√• √• g√• gjennom hver liste for √• finne tall (number) som har 0 etter komma ved √• gj√∏re den om til en string og s√• se om tegnet p√• plass -1 er enten 0 eller et mellomrom. Dette forutsetter fors√•vidt at det enten er en 0 eller et mellomrom og tar ikke h√∏yde for at den kanskje bare er tom.
#Deretter tenkte jeg √• legge til alt som skal legges til the_sum. F√∏rst legger jeg til number. Ovenfor har jeg pr√∏vd √• lage variabler for tallene som blir tallet til vensre og tallet til h√∏yre for sat tallet rett over og tallet rett under v√•rt number. Sk√∏nner at dette ikke tar h√∏yde for √• unng√• √• plusse de samme tallene flere ganger slik det stod i oppg. Usikker p√• hvordan jeg eventuelt kunne gjort det. I tillegg hvis tallene st√•r i noen av hj√∏rnene vil vi f√• index error. Pr√∏vde √• l√∏se dette med en exception, slik at den bare hopper ut og fortsetter p√• neste.

#Skj√∏nner at dette nok ikke blir helt riktig. Tror jeg kan bruke noe fra numpy-biblioteket til √• finne elementene og indeksene i et array mye lettere, men dette var jeg alts√• ikke helt forberedt p√• i dag.
                    
    
    "
"def sum_larger(numlist,n):
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
    return summen
";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8 and n_pass >= 0:
            return ""M1""
        elif n_pass > 8 and wt <= 5000 and wt > 0:
            return ""M2""
        elif n_pass > 8 and wt > 5000:
            return ""M3""
        else:
            return ""false input""
    elif not person:
        if wt <= 3500 and wt > 0:
            return ""N1""
        elif wt > 3500 and wt <= 12000:
            return ""N2""
        elif wt > 12000:
            return ""N3""
        else:
            return ""false input""
    else:
        return ""false input""
        
            
        ";"#Denne funksjonen tar dessverre ikke hensyn til om verdien allerede har blitt lagt til fra f√∏r eller ikke
def sum_near_whole(A):
    lstvalues = [0]
    for i in range(len(A)):
        for j in range(len(A[i]):
            if A[i,j] % 1 == 0:
                if j <= len(A[i])-1:
                    lstvalues.append(A[i,j+1])
                if j >= 1:
                    lstvalues.append(A[i,j-1])
                if i >= 1:
                    lstvalues.append(A[i-1,j])
                if i <= len(A)-1:
                    lstvalues.append(A[i+1,j])
    return sum(lstvalues)"
"def sum_larger(numlist, n):
    sum=0
    for i in numlist:
        if numlist[i] > n:
            sum+=numlist[i]
    return sum
            
        ";"def car_type(n_pass,wt,person):
    if n_pass > 8 and wt > 5000 and person==True:
        return ""M3""
        
    elif n_pass > 8 and wt<=5000 and person==True:
        return ""M2""
    
    elif n_pass <=8 and person==True:
        return ""M1""
   
   elif wt >= 12000 and person==False:
       return ""N3""
            
    elif 3500<=wt<=12000 and person==False:
        return ""N2""
        
    else:
        wt<=5000 and person==False:
            return ""N1""
    
   
        ";"def sum_near_whole(A):
    sum=0
    for i in A:
        if A[i,j] ==int(A[i,j]):
            sum+=int(A[i,j])+int([i+1,j+1])
    return sum"
"def sum_larger(numlist, n):
    sum = 0
    for i in range(len(numlist)):
        if numlist[i] > 5:
            sum += numlist[i]
    
    return sum
    ";"def car_type(n_pass, wt, person):
    number = ""1""
    letter = """"
    if person == True:
        letter = ""M""""
        if n_pass > 7:
            number = ""2""
        if wt > 5000:
            number = ""3""
    else:
        letter = ""N""
        if wt > 3500:
            number = ""2""
        if wt > 12000:
            number = ""3""
    
    carType = letter + number
    
    return carType";"def sum_near_whole(A):
    summ = 0
    L = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]
    summation = set()
    for i in range(len(A)):
        for x in range(len(A[i])):
            if A[i][x] in L:
                
                if i == 0:
                    if x == 0:
                        summation.add(A[i+1][x])
                        summation.add(A[i][x+1])
                    elif x == len(A[0])-1:
                        summation.add(A[i+1][x])
                        summation.add(A[i][x-1])
                    else:
                        summation.add(A[i+1][x])
                        summation.add(A[i][x+1])
                        summation.add(A[i][x-1])
                        
                elif i != 0 or i != len(A)-1:
                    if x == 0:
                        summation.add(A[i+1][x])
                        summation.add(A[i][x+1])
                        summation.add(A[i-1][x])
                    elif x == len(A[0])-1:
                        summation.add(A[i+1][x])
                        summation.add(A[i][x-1])
                        summation.add(A[i-1][x])
                    else:
                        summation.add(A[i+1][x])
                        summation.add(A[i][x+1])
                        summation.add(A[i][x-1]
                        summation.add(A[i-1][x])
                        
                else:
                    if x == 0:
                        summation.add(A[i-1][x])
                        summation.add(A[i][x+1])
                    elif x == len(A[0])-1:
                        summation.add(A[i-1][x])
                        summation.add(A[i][x-1])
                    else:
                        summation.add(A[i-1][x])
                        summation.add(A[i][x+1])
                        summation.add(A[i][x-1])
    lst = list(summation)
    for i in range(len(lst)):
        summ += lst[i]
        
    return summ"
"def sum_larger(numlist, n):
    a = 0
    for i in numlist:
        if i > n:
            a += i
    
    return a";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return 'M1'
            
        else:
            if wt <= 5000:
                return 'M2'
            else:
                return 'M3'
        
    
    else:
        if wt <= 3500:
            return 'N1'
        
        elif wt > 3500 and wt <= 12000:
            return 'N2'
        
        else:
            return 'N3'
            
        ";"import numpy as np

def sum_near_whole(A):
    b = []
    for i in range(len(A)):
        
        for j in range(len(A[0])):
            if A[i][j] % 1 == 0.0:
                
                if i == 0 and j == 0:
                    b.append(A[i][1+j]) 
                    b.append(A[i+1][j])
                    
                elif i == 0 and j == 3:
                    b.append(A[i][j-1])
                    b.append(A[i+1][j])
                
                elif i == 0:
                    b.append(A[i][j-1]) 
                    b.append(A[i][j+1])
                    b.append(A[i+1][j])
                
                elif i == 4 and j == 0
                    b.append(A[i][j+1])
                    b.append(A[i-1][j])
                
                elif i == 4 and j == 3:
                    b.append(A[i][j-1])
                    b.append(A[i-1][j])
                
                elif i == 4:
                    b.append(A[i][j-1])
                    b.append(A[i][j+1])
                    b.append(A[i-1][j])
                    
                elif j == 0:
                    b.append(A[i][j+1])
                    b.append(A[i+1][j])
                    b.append(A[i-1][j])
                elif j == 3:
                    b.append(A[i][j-1])
                    b.append(A[i-1][j])
                    b.append(A[i+1][j])
                
                else:
                    b.append(A[i][j+1])
                    b.append(A[i][j-1])
                    b.append(A[i+1][j])
                    b.append(A[i-1][j])
                    
    n = []
    for h in b:
        if h not in n:
            n.append(h)
    
    return np.sum(n)
                
                "
"def sum_larger(numlist, n):
    sum = 0
    for i in numlist:
        if i > n:
            sum += i
    return sum

";"# Her har jeg g√•tt ut ifra at max sitteplasser i tillegg til f√∏rersetet
# betyr max 9 sitteplasser i bilen totalt (f√∏rersete pluss 8 passasjerer)

def car_type(n_pass, wt, person):
    
    # F√∏rst bestemme om det er varetransport eller persontransprot:
    
    if person == True:
        
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    
    elif person == False:
        
        if wt <= 3500:
            return ""N1""
        elif wt > 3500 and wt <= 12000:
            return ""N2""
        else:
            return ""N3""
     
    
        ";"import numpy as np

def sum_near_whole(A):

    newList = []                                         # Lager en ny liste
    
    for rIndex in range(0, (len(A)-1) ):                 # Itererer gjennom radene i matrisen

        for cIndex in range(0, (len(A[rIndex])-1) :      # Itererer gjennom numrene i gjeldende rad

            # Sjekke tallet til venstre:
            if cIndex == 0: 
                pass                                # Siden det ikke er noen kolonne til venstre
            elif len(A[rIndex][cIndex-1]) == 2:
                newList.append(A[rIndex][cIndex])   # Legger til det gjeldende tallet i newList
                continue                            # G√•r videre til neste element i for-loopen

            # Sjekke tallet over:
            if rIndex == 0: 
                pass                                # Siden det ikke er noen rad over
            elif len(A[rIndex-1][cIndex]) == 2:
                newList.append(A[rIndex][cIndex])
                continue

            # Sjekke tallet til h√∏yre:
            if cIndex == (len(A[rIndex])-1):
                pass                                # Siden det ikke er noen kolonne til h√∏yre
            elif len(A[rIndex][cIndex+1]) == 2:
                newList.append(A[rIndex][cIndex])
                continue

            # Sjekke tallet under:
            if rIndex == (len(A)-1):
                pass                                # Siden det ikke er noen rad under
            if len(A[rIndex+1][cIndex]) == 2:
                newList.append(A[rIndex][cIndex])
                continue
        
    newArray = np.array(newList)    # Lager et numpy array med newList
    sum = np.sum(newArray)          # Summerer alle elementene i newList
    
    return sum                      # Returnerer summen av alle tallene som skal summeres
"
"def sum_larger(numlist,n):
    summen = 0
    for element in numlist:
        if element > n:
            summen += element
    return summen";"def car_type(n_pass,wt,person):
    if person:   #Hvis persontransport; g√• inn i denne kodedelen.
        if n_pass <= 8:
            return ""M1""
        elif (n_pass > 8 and wt > 5000):  #strengt tatt ikke n√∏dvendig √• legge inn n_pass betingelse her
            return ""M3""
        else:
            return ""M2""
    else: #om det ikke er persontransport; g√• inn her.
        if wt > 12000:
            return ""N3""
        elif wt <= 3500:
            return ""N1""
        else:
            return ""N2""
        ";"import numpy as np

def sum_near_whole(A):
    for i in range(len(A)): #Antall rader
        for j in range(len(A[i])):  #Antall kolonner
            arr = np.zeros(len(A)*(len(A[i])))
            if str(A[i,j])[-1] == """":  #Dersom tallet bak komma er 0 (tom streng)
                arr[i] = A[i,j+1] + A[i+1,j] + A[i-1,j] + A[i,j-1] #Legger til summen av tallene rundt inn i arr
                A = np.delete(A[i,j+1],A[i+1,j],A[i-1,j],A[i,j-i]) #Oppdaterer A slik at de elementene som er lagt til i arr blir slettet.
    return np.sum(arr)
    
#Legger merke til at bruken av np.delete ikke kommer til √• fungere slik som √∏nsket, men pr√∏ver √• f√• fjernet de elementene som allerede er lagt til i arr, slik at de ikke legges til flere ganger. If- betingelsen med str(A[i.j])[-1] == """" er for √• sjekke at float er lik int (1.0 = 1)."
"def sum_larger(numlist,n):
    mellomlist = []
    for i in numlist:
        if i > n:
            mellomlist += i
    return sum(mellomlist)";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass > 8:
            if wt > 5000:
                return ""M3""
            else: return ""M2""
        else: return ""M1""
    else:
        if wt > 12000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        else: return ""N1""";"def sum_near_whole(A):
    L = []
    for i in range(len(A)):
        for j in range(lenA[i]):
            if A[i,j] == int(A[i,j]):
                if [A[i,j+1]] in A and [A[i,j+1]] not in L:
                    L += [A[i,j+1]]
                if [A[i,j-1]] in A and [A[i,j-1]] not in L:
                    L += [A[i,j-1]]
                if [A[i+1,j]] in A and [A[i+1,j]] not in L:
                    L += [A[i+1,j]]
                if [A[i-1,j]] in A and [A[i-1,j]] not in L:
                    L += [A[i-1,j]]
    return sum(L)"
"def sum_larger(numlist, n):
    
    summen = 0
    
    for e in numlist: #g√•r gjennom alle elementene i numlist
        
        if e > n:
            
            summen += e #legges til p√• summen dersom elementet er st√∏rre enn n
            
    return summen";"def car_type(n_pass, wt, person):
    
    if person: #antar at enten True eller False blir skrevet inn for person. Persontransport
        
        kategori = 'M'
        
        if n_pass <= 8: 
            kategori += '1' #M + 1 = M1
            
        else: #buss
            
            if wt <= 5000: #tolker at 'ikke over' betyr at den kan v√¶re lik
                kategori += '2'
            elif wt > 5000:
                kategori += '3'
    
    else: #False: varetransport, tar ikke hensyn til at annet enn True og False skrives inn for person
    
        kategori = 'N'
        
        if wt <= 3500:
            kategori += '1'
        elif 3500 < wt <= 12000:
            kategori += '2'
        elif wt > 12000:
            kategori += '3'
            
    return kategori";"

def sum_near_whole(A): 
    
    summen = 0
    
    for i in range(len(A)):
        for j in range(len(A[i])):
            
            if int(A[i][j]) == A[i][j]: 
                
                try:
                    summen += A[i-1][j]
                    A[i-1][j]=0
                try:
                    summen += A[i][j-1]
                    A[i][j-1]=0
                try:
                    summen += A[i][j+1]
                    A[i][j+1]=0
                try:
                    summen += A[i+1][j]
                    A[i+1][j]=0
    
    return summen"
"def sum_larger(numlist,n):
    summen = 0
    nyliste = []
    
    for elem in numlist:
        if elem > n:
            nyliste.append(elem)
    
    for i in range(nyliste):
        summen += i
        
    
    return summen
    
""""""
begynner med √• definere summen, som vi senere skal returnere. den er i starten s√•klart 0.
definerer en ny liste som jeg vil bruke til √• regne ut summen p√• senere.
iterere gjennom hvert heltall i lista jeg tar inn, og ser p√• om dette er st√∏rre enn n, om det er True, vil jeg legge dettte tallet til nyliste. npr denne l√∏kka er ferdig, g√•r jeg og ser gjennom elementene i nye lista, og legger hvert element til i summen. 
deretter returnerer jeg summen. her antatr jeg at alle tall er heltall, s√• jeg slipper √• bruke funksjoner for √• omgj√∏re de til integers. 
""""""";"def car_types(n_pass,wt,person):
    if (n_pass <= 8 and person == True):  #skj√∏nner ikke helt hva ""antall sitteplasser utover f√∏rersetet"" betyr. antar dvs . maks 8 personer:)
        type = ""M1""
        
    elif (n_pass > 8 and wt<=5000 and person == True):
        type = ""M2""
        
    elif (n_pass > 8 and wt > 5000 and person == True):
        type = ""M3""
    
    elif (wt <= 3500 and person == False):
        type = ""N1""
        
    elif (wt > 3500 and wt <= 12000 and person == False):
        type = ""N2""
        
    elif (wt > 12000 and person == False):
        type = ""N3""
    
    else: 
        type = ""ukjent bil ??""
        
    return type
    
";"import numpy as np

def sum_near_whole(A):
    summen = 0
    nyliste = [] #definerer en ny liste jeg tenker skal ha med de tallene som skal v√¶re med
    for rad in A:
        for elem in rad:
            if float(elem)==int(elem):
                nyttall1 = A[elem+1]
                nyttall2 = A[elem-1]
                nyttall3= A[rad+1][elem]
                nyttall4=A[rad-1][elem]
                
                if nyttall1 not in nyliste and in A:
                    nyliste.append(nyttall1)
                if nyttall2 not in nyliste and in A:    
                    nyliste.append(nyttall2)
                if nyttall3 not in nyliste and in A:
                    nyliste.append(nyttall3)
                if nyttall4 not in nyliste and in A:
                    nyliste.append(nyttall4)
    for i in nyliste:
        summen += i
    
    return summen
    
""""""    
kan hende dt er noen feil i denne koden, men kan skrive ned det jeg tenkte mens jeg skrev koden.
importerer numpy siden vi skal arbeide med et numpy array
definerer funksjonen
skal returnere summne, s√• da begynner vi med √• lage en variabel kalt summen som vi senere skal returnere, den starter p√• 0.
definerer en ny liste jeg har tenkt √• fylle opp med de tallene som skal bruks til √• regne ut summen med lengre ned i koden
begynner da √• se p√• hvert element, og siden det er en to dimensjonal liste, trenger vi to for l√∏kker, en som itererer gjennom hver rad, og en som itererer gjennom hvert element i de forskjellige radene. ¬®
heretter ser jeg p√• hvilke elementer som skal v√¶re med i den nye lista, siden koden sp√∏r etter tall som er float med desimal lik null, finner jeg disse ved √• se etter om int() og float() av tallet gir True eler False. viss deette gir true, efinerer jeg fire nye st√∏rrelser, som er tenkt skal v√¶re de tallene som ligger vedisen av tallet med deismal lik null. her har jeg tenkt at tallene over og under vil v√¶re tall som er i rad over/under tallet, og de ved siden av er indeks av tallet + 1. deretter ser jeg p√• om de tallene allerede er i nye listen, og om de ikke er det, vil jeg da legge de til. n√•r alt er lagt til, g√•r jeg gjennom den nye listen og legger til hvert element, somda gir summen :)

"""""""
"def sum_larger(numlist, n):
    sum=0
    for i in numlist:
        if i>n:
            sum+=i
    return sum
    ";"def car_type(n_plass, wt, person):
    if person==true:
        if n_plass<=8:
            print(""M1"")
        elif n_plass>8 and wt<=5000:
            print(""M2"")
        else:
            print(""M3"")
    else:
        if wt<=3500:
            print(""N1"")
        elif wt>3500 and wt<=12000:
            print(""N2"")
        else:
            print(""N3"")";"import numpy as np

def sum_near_whole(A):
    near_whole=[]
    for i in range(len(A)):
        for j in range(len(A[i])):
            try:
                int(A[i,j])
                if j==1 and i==1:
                    near_whole.append(A[i,(j+1)],A[(i+1),j])
                elif j==4, and i==4:
                    near_whole.append(A[i,(j-1)], A[(i-1),j])
                elif j==4 and i==1:
                    near_whole.append(A[i,(j-1)], A[(i+1),j])
                elif j==1 and i==4:
                    near_whole.append(A[(i-1),j], A[i,(j+1)])
                else:
                    near_whole.append(A[i,(j+1)], A[i,(j-1)], A[(i+1),j], A[(i-1),j])
    Near_whole=np.array(near_whole)
    sum=np.sum(Near_whole)
    return sum"
"def sum_larger(numlist, n):
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
    return summen";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
        else: 
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif 3500 < wt <= 12000:
            return ""N2""
        else:
            return ""N3""
            ";"def sum_near_whole(A):
    summen = 0
    nabotall = []
    for i in range(len(A)):
        for j in range(len(A[i])):
            if float(A[i, j]) == int(A[i, j]):
                for (A[i-1, j] or A[i+1, j] or A[i, j-1] or A[i, j+1]) not in nabotall:
                    nabotall.append(A[i-1, j])
                    nabotall.append(A[i+1, j]) 
                    nabotall.append(A[i, j-1]) 
                    nabotall.append(A[i, j+1])
    return sum(nabotall)
"
"def sum_larger(numlist, n):
    sum_list = []
    for tall in numlist:
        if tall > n:
            sum_list.append(n)
    retun sum(sum_list)
    
    
# Tenker her √• opprette en tom liste kalt sum_list, for s√• √• ta en forl√∏kke
# for √• iterere gjennom numlist, for √• finne tall > n, og appende disse i listen
# sum_list, for s√• √• returnere summen av denne listen.";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8: and wt >= 5000:
            return ""M3""
        elif n_pass > 8 and wt < 5000:
            return ""M2""
        elif n_pass <= 8:
            return ""M1""
    elif person == False:
        if wt >= 12000:
            return ""N3""
        elif 12000 > wt <= 3500:
            return ""N2""
        elif wt < 3500:
            return ""N1""
            
# Sjekker her f√∏rst om person er true eller false. hvis true, sjekker antall
# passasjerer st√∏rre enn 8, og ser da p√• vekta om det er M3 eller M2, er det 8 
# eller mindre er det M1. Dersom person er false sjekker vi vekta for √• finne 
# ut om det er N!, N2 eller N3";"def sum_near_whole(A):
    result = []
    for i in A:
        for j in i:
            if (j/1) == type(int):
                result.append([j])
                result.append([j-1]) 
                result.append([j+1])
                result.append([i-1][j]) 
                result.append([i+1][j]) 
    return sum(result):
        
# Her vil jeg starte med √• opprette en tom liste, for s√• gjennom to forl√∏kker
# iterert meg gjennom hvert tall i 2D-arrayet. N√•r maskinen finner et tall som 
# n√•r du deler p√• 1 f√•r at er heltall,er tanken at den legger den til dette, 
# samt tallet som befinner seg f√∏r og etter i j-indeksen, alts√•[j-1] og [j+1]
# og over og under, som da er [i-1][j] og [i+1][j].
# Til slutt ville jeg da ha lagt til alle tall det gjelder i listen, jeg 
# opprettet i starten, for s√• √• returnere summen av denne listen.
# Sv√¶rt usikker p√• om dette lar seg gj√∏re uten feilmelding, men tanken er alts√•
# √• finne tall med indeks j som er int n√•r du deler p√• 1, for s√• √• appende dette
# og omkringliggende tall til listen, og returnere summen."
"def sum_larger(numlist, n):
    
    numlist= sort(numlist)
    
    sum_list = []
    
    for i in range(len(numlist)):
        
        if (numlist[i-1] + numlist[i]) > n:
            
            sum_list.append(numlist[i-1])
            sum_list.append(numlist[i])
    
    sum_set = set(sum_list)
    summen = 0
    
    for j in sum_set:
        
        summen += j
    
    return summen
        
        ";"def car_type(n_pass, wt, person):
    
    if person:
        
        if n_pass <= 8:
            type = ""M1""
            
        elif n_pass > 8 and wt <= 5000:
            type = ""M2""
            
        else:
            type = ""M3""
            
    else:
        
        if wt <= 3500:
            type = ""N1""
        
        if 3500 < wt <= 12000:
            type = ""N2""
        
        else:
            type = ""N3""
        
        
    return type
        
        ";"def sum_near_whole(A):
    
    summen = []
    summen_total = 0
    
    for i in range(len(A)):
        
        for j in range(len(i)):
            
            if round(i[j]) == i[j]:     #Alternativt: if str(i[j]).split(""."")[1] == ""0"":
                
                if i == 0:
                    
                    summen.append(A[i+1][j])
                
                elif i == -1:
                    
                    summen.append(A[i-1][j])
                
                else:
                    
                    summen.append(A[i+1][j])
                    summen.append(A[i-1][j])
                    
                
                if j == 0:
                
                    summen.append(A[i][j+1])
                
                elif j == -1:
                
                    summen.append(A[i][j-1])
                    
                else:
                    
                    summen.append(A[i][j-1])
                    summen.append(A[i][j+1])

    for i in set(summen):
        
        summen_total += i
    
    return summen_total
    
    
        
#eg innser at eg kunne ha brukt exceptions for iterasjonserrorene som erstatning for nokre av if-setningan, eller ha endra p√• rangen til for-l√∏kkjene for √• gjere koden mindre rotete.
        
    
    "
"def sum_larger(numlist,n):
    sum = 0
    for tall in numlist:
        if tall>n:
            sum+=tall
    return sum";"def car_type(n_pass,wt,person): #Tar heysn til at det legges inn 3 variabler
    if wt<0 or n_pass<0:
        return ""Vekt og antall sitteplasser m√• v√¶re st√∏rre eller lik 0"" 
    elif person:
        if n_pass<8: # Tar ikke med 8, siden f√∏rersetet er ikke inkludert
            return ""M1""
        elif wt<=5000:
            return ""M2""
        return ""M3""
    elif not person:
        if wt<=3500:
            return ""N1""
        elif wt>3500 and wt<=12000:
            return ""N2""
        return ""N3""
    return ""Person skal enten v√¶re True eller False""";"import numpy as np
def sum_near_whole(A):
    A = np.array(A)
    summen = 0.0
    for i in range (A):
        for j in range(A[i]):
            if A[i,j]==int(A[i,j]):
                if i == 0:
                    summen+= A[i,j+1]
                    summen+= A[i,j-1]
                    summen+= A[i+1,j]
                else:
                    summen+= A[i,j+1]
                    summen+= A[i+1,j]
                    summen+= A[i-1,j]
                    summen+= A[i,j-1]
    return summen"
"def sum_larger(numlist, n):
    
    ny_liste = 0
    for tall in numlist:
        if tall > n:
            ny_liste += tall
    return ny_liste";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif 3500 < wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"import numpy as np

def sum_near_whole(A):
    nytt_set = set()
    
    for row in len(A):
        for i in len(A[row]):
            if (int(A[row][i]*10)) % 10 == 0:
                try:
                    nytt_sett.add(A[row][i+1])
                try:
                    nytt_sett.add(A[row][i-1])
                try:
                    nytt_sett.add(A[row+1][i])
                try:
                    nytt_sett.add(A[row-1][i])
    
    return np.sum(list(nytt_sett))"
"def sum_larger(numlist, n):
    summen = 0
    for number in numlist:
        if number > n:
            summen += number
    return summen";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return 'M1'
        else:
            if wt <= 5000:
                return 'M2'
            else:
                return 'M3'
    else:
        if wt <= 3500:
            return 'N1'
        elif (wt > 3500) and (wt <= 12000):
            return 'N2'
        else:
            return 'N3'
            
            
# her har jeg antatt at ""Antall sitteplasser utover f√∏rersete"" betyr ""ikke inkludert f√∏rersetet""";"import numpy as np

def sum_near_whole(A):
    form = A.shape()
    lengde_sum_array = (len(A))*(len(A[0]))
    summen = np.zeros(lendge_sum_array)
    summen = summen.reshape(form)
    for i in range(len(A)):
        for j in range(len(A[0])):
            num_as_string = str(float(A[i,j]))
            if num_as_string[-1] == '0':
                try:
                    summen[(i-1), j] = A[(i-1), j]
                except IndexError: 
                    pass
                
                try:
                    summen[(i+1), j] = A[(i+1), j]
                except IndexError: 
                    pass
                
                try:
                    summen[i, (j-1)] = A[i, (j-1)]
                except IndexError: 
                    pass
                
                try:
                    summen[i, (j+1)] = A[i, (j+1)]
                except IndexError: 
                    pass
    
    summen = summen.reshape((1,lengde_sum_array))
    verdi = np.sum(summen)
    return verdi
    
#Mulig at reshape ikke ta in tuple, men kun parameter. Ikke 100% sikker.

                 "
"def sum_larger(numlist, n):
    sum = 0
    for i in numlist:
        if i > n:
            sum += i
    return sum

#Begge burde funke, men den under har f√¶rre linjer
def sum_larger(numlist, n):
    sumlist = [i for i in numlist if i>n]
    sum = sum(sumlist)
    return sum";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return ""M1""
        elif wt < 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt < 3500:
            return ""N1""
        elif wt > 12000:
            return ""N3""
        else:
            return ""N2""";"import numpy as np

def sum_near_whole(A):
    sum_list = []   #Kan ogs√• bare lage en tom sum som adderes inn over flere iterasjoner
    for row in range(len(A)):
        for column in range(len(A[row])):
            try:        #Kan ogs√• bruke en if setning som sjekker om (num/1) == (num//1)
                        #Da slipper man ogs√• except meldinge p√• slutten
                whole = int(A[row,column]) #Denne gir en feilmelding for desimaltall
                i = row                     #Dersom verdien er int kj√∏rer koden. 
                j = column                  #Bruker i og j for ryddigere kode
                if column == 0:             
                    sum_list.append(A[i,j+1])
                    A[i,j+1] = 0.               #For √• unng√• at jeg bruker samme verdi fra en index igjen
                elif column == (len(A[row])-1): #setter jeg den brukte indexen i matrisen lik 0, slik at den ikke
                    sum_list.append(A[i,j-1])   #bidra til summen.
                    A[i,j-1] = 0.
                elif column > 0 and column < (len(A[row])-1):
                    sum_list.append(A[i,j-1])
                    sum_list.append(A[i,j+1])
                    A[i,j-1] = 0.
                    A[i,j+1] = 0.
                if row == 0:
                    sum_list.append(A[i+1,j])
                    A[i+1,j] = 0.
                elif row == (len(A[:,column])):
                    sum_list.append(A[i-1,j])
                    A[i-1,j] = 0.
                elif row > 0 and row < len(A[:,column]):
                    sum_list.append(A[i-1,j])
                    sum_list.append(A[i+1,j])
                    A[i-1,j] = 0.
                    A[i+1,j] = 0.
            except:
                pass   #Ingenting skjer dersom det forekommer en feil
    sum = np.sum(np.array(sum_list)) #Gj√∏r settet om til en array, for √• summere det sammen. 
    return sum"
"def sum_larger(numlist,n):
    resultat=0
    for i in numlist:
        if i > n:
            resultat+=i
    return resultat
    ";"def car_type(n_pass,wt,person):
    if person==True:
        if n_pass<=8:
            biltype= 'M1'
        elif n_pass > 8 and wt<=5000:
            biltype='M2'
        else:
            biltype='M3'
    else:
        if wt<=3500:
            biltype='N1'
        elif wt<=12000:
            biltype='N2'
        else:
            biltype='N3'
    return biltype";"def sum_near_whole(A):
    resultat=0
    sjekkliste=A
    for i in range len(A):
        for h in range(len(A[i]))
            if A[i][h]-round(A[i][h])==0.0:
                resultat+=0
            else:
                if i!=len(A) and h!=len(A[i]) and i!=0 and h!=0:
                    if sjekkliste[i+1][h]==A[i+1][h]:
                        resultat+=A[i+1][h]
                        sjekkliste[i+1][h]=0
                    if sjekkliste[i-1][h]==A[i-1][h]:
                            resultat+=A[i-1][h]
                            sjekkliste[i-1][h]=0
                    if sjekkliste[i][h+1]==A[i][h+1]:
                            resultat+=A[i][h+1]
                            sjekkliste[i][h+1]=0
                    if sjekkliste[i][h-1]==A[i][h-1]:
                            resultat+=A[i][h-1]
                            sjekkliste[i][h-1]=0
                elif i==0 and h!=0:
                    if sjekkliste[i+1][h]==A[i+1][h]:
                        resultat+=A[i+1][h]
                        sjekkliste[i+1][h]=0
                    if sjekkliste[i][h-1]==A[i][h-1]:
                            resultat+=A[i][h-1]
                            sjekkliste[i][h-1]=0
                    if sjekkliste[i][h+1]==A[i][h+1]:
                            resultat+=A[i][h+1]
                            sjekkliste[i][h+1]=0
                elif i==len(A) and h!= len(A[i]):
                    if sjekkliste[i-1][h]==A[i-1][h]:
                        resultat+=A[i-1][h]
                        sjekkliste[i-1][h]=0
                    if sjekkliste[i][h-1]==A[i][h-1]:
                            resultat+=A[i][h-1]
                            sjekkliste[i][h-1]=0
                    if sjekkliste[i][h+1]==A[i][h+1]:
                            resultat+=A[i][h+1]
                            sjekkliste[i][h+1]=0
                elif i==len(A) and h==0:
                    if sjekkliste[i-1][h]==A[i-1][h]:
                        resultat+=A[i-1][h]
                        sjekkliste[i-1][h]=0
                    if sjekkliste[i][h+1]==A[i][h+1]:
                            resultat+=A[i][h+1]
                            sjekkliste[i][h+1]=0
                elif i==len(A) and h==len(A[i]):
                    if sjekkliste[i-1][h]==A[i-1][h]:
                        resultat+=A[i-1][h]
                        sjekkliste[i-1][h]=0
                    if sjekkliste[i][h-1]==A[i][h-1]:
                            resultat+=A[i][h-1]
                            sjekkliste[i][h-1]=0
                elif i==0 and h==len(A[i]):
                    if sjekkliste[i+1][h]==A[i+1][h]:
                        resultat+=A[i+1][h]
                        sjekkliste[i+1][h]=0
                    if sjekkliste[i][h+1]==A[i][h+1]:
                            resultat+=A[i][h+1]
                            sjekkliste[i][h+1]=0
                else:
                    if sjekkliste[i+1][h]==A[i+1][h]:
                        resultat+=A[i+1][h]
                        sjekkliste[i+1][h]=0
                    if sjekkliste[i][h+1]==A[i][h+1]:
                            resultat+=A[i][h+1]
                            sjekkliste[i][h+1]=0
    return resultat"
"def sum_larger(numlist,n):
    summen = 0
    for tall in numlist:
        if tall > n:
            summen += tall
    return summen
    
    ";"def car_type(n_pass,wt,person):
    if person == True:
        if n_pass < 8:
            return M1
        elif n_pass >= 8 and wt <= 5000:
            return M2
        elif n_pass >= 8 and wt < 5000:
            return M3
    if wt <= 3500:
        return N1
    elif wt > 3500 and wt <= 12000:
        return N2
    elif wt > 12000:
        return N3";"import numpy as np
def sum_near_whole(a):
    summen = []
    for i in range(len(A)):
        for j in range(len(A[i])):
            str(A[i][j]).split(.)
            for n in range(len(A[i][j]))
                if n[1] == 0: #sjekker om det siste desimalet er null
                    tall1 = A[i-1][j]
                    tall2 = A[i+1][j]
                    tall3 = A[i][j-1]
                    tall4 = A[i][j+1]
                if tall1 not in summen:
                    summen += tall1
                elif tall2 not in summen:
                    summen += tall2
                elif tall3 not in summen:
                    summen += tall3
                elif tall4 not in summen:
                    summen += tall4
    
    return summen"
"def sum_larger(numlist,n):
    quantity = len(numlist)
    a = 0
    
    for i in range(quantity):
        value = int(numlist[i])
        if value >= n:
            a += value
    
    return a        

# Tanken for denne oppgaven er at jeg lager en for-l√∏kke som f√∏rst gir meg hvor mye hver indeks innen listen numlist er verdt i en integer, og kaller den verdien for value. Deretter sjekker jeg om den verdien for indeksen i listen er st√∏rre enn n, og hvis den er det legges den til i a. a returneres i slutten av funksjonen";"def car_type(n_pass, wt, person):
    if person == true:
        if n > 8 and wt > 5000:
            print(""M3"")
        elif n > 8 and wt <= 5000:
            print(""M2"")
        elif n < 8:
            print(""M1"")
        
    elif person == false:
        if n > 8 and wt > 12000:
            print(""N3"")
        elif n > 8 and ( 3500 < wt <= 12000):
            print(""N2"")
        elif n < 8 and wt <= 3500:
            print(""N1"")
            
            
# I denne oppgaven valgte jeg √• bruke en if setning for √• sjekke om det var personbil, eller ikke, og derifra de spesifikke m√•lene for √• bruke minst mulig tid, siden det er lettere √• copy-paste inn de andre verdiene slik. Derifra brukte jeg if/elif-setninger med synkende verdier)";"def sum_near_whole(A):
    a = 0
    n, m = ndarray.shape(A)
    for i in range(n):
        for j in range(m):
            if A[i][j] == int(A[i][j]):
                a += A[i+1]
            if A[i+1][j] == int(A[i+1][j]):
                a += A[i]
            if A[i][j+1] == int(A[i][j+1]):
                a += A[i]
    return a


# Tanken i denne oppgaven er √• bruke ndarray.shape() for √• finne hvor store rader og rekker det er. Derifra sjekker jeg alle verdiene jeg f√•r i radene ved en for l√∏kke av A til h√∏yre bortover, og alle j verdiene av A ovenfra nedover. Dersom det hender seg at en verdi av A[i] er et heltall velger jeg bare en verdi bortover/nedover s√• jeg slipper problemet med at man kan velge to verdier som gir samme verdier. Men hva hvis to heltall er ved siden av hverandre? Men for √• passe p√• at man ikke glemmer om den du st√•r p√• kan v√¶re en verdi man m√• legge p√• la jeg til en if setning som sier: ""hvis neste verdi er et helvtall m√• jeg legge til meg selv. Samme er gjort vertikalt"""
"def sum_larger(numlist,n):
    sum = 0
    for tall in numlist:
        if tall > n:
            sum += tall
    return sum";"def car_type(n_pass,wt,person):
    if person:
        if n_pass <= 8:
            return ""M1""
        else:
            if wt <= 5000:
                return ""M2""
            else:
                return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt > 3500 and wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"import numpy as np

def sum_near_whole(A):
    summ = []
    indeks = []
    posisjon = {}
    for i in range(len(A)):
        for j in range(len(A[i])):
            try:
                if round(A[i][j]) == A[i][j]: #sjekker om det avrundede tallet i lista er lik heltallet
                    indeks.append((i,j)) # √∏osta indeks tar inn indeksen i og j, alts√• rad og kolonne
                    if posisjon[(i,j)] in posisjon:
                            posisjon[(i,j)].append([i,j+1], [i+1,j], [i-1,j], [i,j-1])
                    else:
                        posisjon[(i,j)] = [i,j+1], [i+1,j], [i-1,j], [i,j-1] # kan sjekke om om i og/ellerj blir negative ogs√• fjerne disse indeksene
                    """"""    
                    if i != 0 and j != 0 and i != len(A-1) and j != len(A[i]-1):
                        summ.append(A[i][j+1], A[i+1][j], A[i-1][j], A[i][j-1])
                         # tar inn alle tallene rundt hvis den ikke ligger p√• kanten
                    if j == 0:
                        summ.append(A[i][j+1])
                    if j == len(A[i])
                        summ.append(A[i][j-1]
                    if i == 0:
                        summ.append(A[i+1][j])
                    if i == len(A):
                        summ.append(A[i-1][j])
                        
                    """"""#blir mange if setninger
            except IOError: # hvis ikke bare fortsetter den
                    pass
    for key, value in posisjon.items():
        
    resultat =sum(summ)
    return resultat
    
    
#Har ikke s√• mye tid igjen, men man kan iterere gjennom rad og kolonner og finne posisjonen til heltallene, og ta inn alle tallene rundt samtidig som man passer p√• at et tall ikke har blitt tatt to ganger. det var litt tricky siden et tall kan dukke opp flere ganger i arrayen s√• jeg kan ikke bruke set(). tenkte kanskje √• finne indeksene til de tallene jeg vil summere ogs√• sjekke om om noen av de var like og dermed da fjerne den ene. s√• appende alle tallene med de indeksene og s√• summere hele lista. Pr√∏vde en gang til her:



def sum_near_whole(A):
    summ = {}
    for i in range(len(A)):
        for j in range(len(A[i])):
            if round(A[i][j]) == A[i][j]:
                if posisjon[(i,j)] in posisjon:
                            posisjon[(i,j)].append([i,j+1], [i+1,j], [i-1,j], [i,j-1])
                    else:
                        posisjon[(i,j)] = [i,j+1], [i+1,j], [i-1,j], [i,j-1]
    resultat = []
    for key, value in posisjon.items():
        for liste in value:
            for i in liste:
                if i[0] < 0 or i[1] < 0:
                    del i
            resultat.append(A[liste[0]][liste[1]]) #appender tallene som skal summeres
    resultat  = sum(resultat)
    return resultat
    
    
    "
"
def sum_larger(numlist,n):
    sum_tall = 0 #summen av tallet starter p√• null
    
        for number in numlist:
            if number > n: #Sjekker at tallene er mindre enn n, for at det skal summeres
                sum_tall += int(number) #summerer tall med summen av tallene
            else:
                return sum_tall #returnerer summen av tallene, dersom det ikke er flere tall st√∏rre enn n
    
    return sum_tall
        ";"#Jeg antar at dersom personbil eller buss, vil funksjonen returnere True dersom dette stemmer. I tillegg, vil b√•de varebil og lastebil returnere False
#Jeg antar at en varebil og lastebil, kun har 1 sitteplass uten f√∏rer inkludert.

#Begynner med √• skille transporttype med to kategorier: varetransport og persontransport


def car_type(n_pass,wt,person):
    
    type_transport = []
    person = None

    if n_pass > 1: #Begynner med √• skille transporttype med to kategorier: varetransport og persontransport
        person = True # Dersom sitteplass er med enn 1, vet vi at det er persontransport.
        if wt >= 5000: # Dersom wt
            type_transport.append(""M3"")
        elif wt<= 5000:
            type_transport.append(""M2"")
        else:
            type_transport.append(""M1"")
    
    elif n_pass <= 1:
        person = False # Dersom sitteplass er maks 1, vet vi at det er varetransport.
        if wt <= 3500:
            type_transport.append(""N1"")
        elif wt > 3500 and wt <= 12000:
            type_transport.append(""N2"")
        elif wt > 12000:
            type_transport.append(""N3"")
        else:
            return type_transport #Returner noe, i tilfelle det skjer en feil

    else:
        return type_transport #returnerer ingenting, dersom ingenting stemmer.
    
    return type_transport.strip()    #returnerer en streng med bil-katogori type
    
    ";"import numpy as np
import math

#kan ha blitt gjort p√• en enklere m√•te, dersom jeg hadde brukt sets (mengder) fra start
#rakk ikke √• skrive ferdig, men forklarer hva jeg har tenkt, s√• langt det lar seg gj√∏re.

def sum_near_whole(A):
    
    sum_A = """" #Begynner med tom streng, der det legges til strenger for hvert av tallene som sjekkes, og som er ""godkjen"" 
    # √ònsker √• sjekke dette for hvert element i hver rad, i alle 4 rader. Deretter fjerne elementene fra A, etterhvert som det g√•r igjennom, slik at tallene ikke brukes flere ganger.
    
    for number in A: # sjekker for hver liste i A                       #for number in range(len(A))
        for rad in number: # sjekker for hvert element i listen til A i rad 1
            if rad[0].isdigit(): #her ville jeg ogs√• sjekke om tallet er et heltall
                sum_A.append(str(rad[0])+ ""+"" + str(rad[1])) #dersom f√∏rste element i rad er heltall, adderer med tall til h√∏yre
                A.remove(rad[0]) #√ònsker √• fjerne tall fra A, slik at det ikke adderes flere ganger
             #gjentas for hvert element i hver rad, og siden kolonnen er 5, gjentas dette 5 ganger.
     
                
    # for hvert element som trekkes fra A, og som videre legges til i sum_A, √∏nsker jeg videre √• regne ut summen av elementene som blir lagt til 
    utregning = 
    
    # Etter √• ha regnet ut summen, √∏nsker jeg √• legge til summen i sum_A og returnere listen
    total_sum = ""= "" + str(utregning)


    sum_A.split() #gj√∏r sum_A om til en liste, slik at jeg kan bruke sort()
    sum_A.sort() #sorterer etter stigende verdi
    sum_A.append(totalsum) #legger til totalsummen til listen
    return sum_A
    
"
"def sum_larger(numlist, n):                #definerer funksjonen. 
    result = 0                          #sjekker for hvert element i lista om det er->
    for elem in numlist:
        a =int(numlist[elem])              #st√∏rre enn n. Hvis det er st√∏rre vil det bli 
        if a > n:                         #addert til resultatet og vi sitter igjen
            result += a                   #med summen. 
    
    return result
    
    ";"def car_type(n_pass, wt, person): 
    if person == 'buss' or 'personbil':    #bruker if setinger for √• sjekke om ulike bet
        if n_pass <= 8:                    #ingelser stemmer. 
            return 'M1'
        elif n_pass > 8:
            if wt > 5000:
                return 'M3'
            else:
                return 'M2'
    elif person != 'buss' or 'varebil':
        if wt > 12000:
            return 'N2'
        elif  3500 < wt < 12000:
            return 'N2'
        else: 
            return 'N1'
    else:
        return ('du har ikke oppgitt riktig informasjon')
    
    
    
    
    
   ";"import numpy as np        

def sum_near_whole(A):
    sum = 0
#da jeg har en 2D liste ville jeg laget en dobbel forl√∏kke for √• kunne g√• inn i hvert indre element i listen. Ville sjekket for om det var noen desimaltall som hadde desimaldel = 0.
    #Ville s√• funndet de ulike tallene  over under og ved siden ved √• bruke innebygd funksjon. Dermed ville jeg summert tallene
    
    
    return sum"
"def sum_larger(numlist,n):
    result=0
    for i in numlist:
        if i > n:
            result+=i
    return result
    ";"def car_type(n_pass,wt,person):
    if person:
        if n_pass<=8:
            return print('M1')

        else:
            if wt<=5000:
                return print('M2')
            elif wt>5000:
                return print('M3')
    elif not person:
        if wt<=3500:
            return print('N1')
        elif 3500<wt=<12000:
            return print('N2')
        elif wt>12000:
            return print('N3')";"def sum_near_whole(A):
    result=0
    tall=[]
    for i in range(len(A)):
        for j in range(len(A[i])):
            #sjekker om det er et helt tall
            if A[i][j]==int(A[i][j]):
                
                #tall over
                if i>0:
                    a=A[i-1][j]
                    if a not in tall:
                        tall.append(a)
                        result+=a
                #tall under
                if i<len[A]-1:
                    b=A[i+1][j]
                    if b not in tall:
                        tall.append(b)
                        result+=b
                #tall til venstre
                if j>0:
                    c=A[i][j-1]
                    if c not in tall:
                        tall.append(c)
                        result+=c
                #tall til h√∏yre
                if j<len(A[i]-1):
                    d=A[i][j-1]
                    if d not in tall:
                        tall.append(d)
                        result+=d
                
    
    return result"
"def sum_larger(numlist,n):
    sum = 0
    for i in numlist:
        if i > n:
            sum += i
        return sum
";"def car_type(n_pass,wt,person):
    if (n_pass <= 8) and (person == True):
        return (""M1"")
    elif (n_pass > 8) and (wt <= 5000) and (person == True):
        return (""M2"")
    elif (n_pass > 8) and (wt > 5000) and (person == True):
        return (""M3"")
    elif (wt <= 3500) and (person == False):
        return (""N1"")
    elif (12000 > wt > 3500) and (person == False):
        return (""N2"")
    else:
        return (""N3"")";"def sum_near_whole(A):
    sum = 0
    for line in A:
        line = A.strip().split("","")
        for i in line:
            if i[3] == 0:
                sum += i[line-1][i] + i[line][i+1]
                if i[3] == [-1]:
                 sum += i[line-1][i] + i[line][i-1]  
                if i[3] == line[0]:
                 sum += i[line+1][i] + i[line][i+1] 
                if i[3] == line[-1]:
                 sum += i[line+1][i] + i[line][i+1] 
            return float(set(sum))
                
                "
"def sum_larger(numlist,n):
    if i in numlist and i>n:
        return sum(i)
    else:
        return 0";"def car_type(n_plass,wt,person):
    if wt>12000 and person=false:
        return N3
    elif 12000>=wt>3500 and person=false:
        return N2
    elif 3500>=wt>=0 and person=false:
        return N1
    elif n_plass >8 and wt>5000 and person=true:
        return M3
    elif n_plass>8 and wt<=5000 and person=true:
        return M2
    else:
        return M1";"import numpy as np
def sum_near_whole(A):
    n%1 = 0
    if n in A:
        
    "
"def sum_larger(numlist,n):
    summ = 0
    for i in numlist:
        if i > n:
            summ += i
    return summ";"def car_type(n_pass,wt,person):
    kategori = ''
    if person == True:
        kategori += 'M'
        if wt > 5000:
            kategori += '3'
            return kategori
        elif n_pass <= 8:
            kategori += '1'
            return kategori
        else:
            kategori += '2'
            return kategori
    elif person == False:
        kategori += 'N'
        if wt > 12000:
            kategori += '3'
            return kategori
        elif wt > 3500:
            kategori += '2'
            return kategori
        else:
            kategori += '1'
            return kategori";"def sum_near_whole(A):
    summ = 0
    sett = set()
    for a in A:
        for j in A[a]:
            if A[a][j] == int(A[a][j]):
                if a == A[0]:
                    sett.add(A[1][j])
                    if j == a[0]:
                        sett.add(A[a][1])
                    elif j == a[-1]:
                        sett.add(A[a][-2])
                    else:
                        sett.add(A[a][j-1])
                        sett.add(A[a][j+1])
                        
                elif a == A[-1]:
                    sett.add(A[-2][j])
                    if j == a[0]:
                        sett.add(A[a][1])
                    elif j == a[-1]:
                        sett.add(A[a][-2])
                    else:
                        sett.add(A[a][j-1])
                        sett.add(A[a][j+1])
                    
                else:
                    sett.add(A[a-1][j])
                    sett.add(A[a+1][j])
                    if j == a[0]:
                        sett.add(A[a][1])
                    elif j == a[-1]:
                        sett.add(A[a][-2])
                    else:
                        sett.add(A[a][j-1])
                        sett.add(A[a][j+1])
    for e in sett:
        summ += e
    return sett
                        
                        
                        
                        
                "
"def sum_larger(numlist, n):
    sum = 0
    for i in numlist:
        if i > n:
            sum += i
    return i";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return 'M1'
        elif wt <= 5000:
            return 'M2'
        else:
            return 'M3'
    else:
        if wt <= 3500:
            return 'N1'
        elif wt <= 12000:
            return 'N2'
        else:
            return 'N3'";"def sum_near_whole(A):
    temp = []
    sum = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j] % 1 == 0:
                if (i > 0) and ([i - 1, j] not in temp):
                    temp.append([i - 1, j])
                    sum += A[i - 1][j]
                if (i < len(A) - 1) and ([i + 1, j] not in temp):
                    temp.append([i + 1, j])
                    sum += A[i + 1][j]
                if (j > 0) and ([i, j - 1] not in temp):
                    temp.append([i, j - 1])
                    sum += A[i, j - 1]
                if (j < len(A[i]) - 1) and ([i, j + 1] not in temp):
                    temp.append([i, j + 1])
                    sum += A[i, j + 1]
    return sum"
"def sum_larger(numlist, n):
    su = 0
    for i in range(len(numlist)):
        if numlist[i] > n :
            su += numlist[i]
    return su ";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return 'M1'
        elif wt < 5000:
            return 'M2'
        else:
            return 'M3'
    else:
        if wt <= 3500:
            return 'N1'
        elif wt <= 12000:
            return 'N2'
        else: 
            return 'N3'";"def sum_near_whole(A):
    d = {}
    su = 0.0 
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i,j] == float(int(A[i,j])):
                if i-1 >= 0:
                    bl = str(i-1) +'_'+ str(j) 
                    if (bl not in d):
                        d[bl] = [i-1,j]
                if len(A) >= i+1:
                    bl = str(i+1) +'_'+ str(j) 
                    if (bl not in d):
                        d[bl] = [i+1,j]
                if j-1 >= 0:
                    bl = str(i) +'_'+ str(j-1) 
                    if (bl not in d):
                        d[bl] = [i,j-1]
                if len(A[i]) >= j+1:
                    bl = str(i) +'_'+ str(j+1) 
                    if (bl not in d):
                        d[bl] = [i,j+1]
    for k in d.keys(): 
        t = d[k]
        su += A[t[0],t[1]]
    return su "
"def sum_larger(numlist, n):
    
    summen = 0
    
    for elmt in numlist:
        if elmt > n:
            summen += elmt
    return summen
    
print(sum_larger(numlist, n))";"def car_type(n_pass, wt, person):
    
    if person:
        if n_pass > 8:
            if wt > 5000:
                biltype = ""M3""
            else:
                biltype = ""M2""
        else:
            biltype = ""M1""
            
    else:
        if wt > 12000:
            biltype = ""N3""
        elif wt > 3500:
            biltype = ""N2""
        else:
            biltype = ""N1""
            
    return biltype";"import numpy as np

def sum_near_whole(A):
    
    near = set()                      #oppretter et set for √• unng√• at det samme tallet adderes mer enn 1 gang

            
    lister = A.tolist()               #vet ikke om dette var n√∏dvendig 
    
    for i in range(len(lister)):
        for j in range(len(lister[i])):
            if len(j) == 2:              #hvis desimaldelen til tallet er null, skal elementet ha lengden 2
                try:
                    near.add(lister[i][j-1])     
                    near.add(lister[i][j+1])  #vet ikke om det funker mtp. √• se p√• tidligere og kommende i og j-verdier
                    near.add(lister[i-1][j])
                    near.add(lister[i+1][j])
                    
                else:
                    None
                    
    liste = list(near)
    
    return sum(liste)                #var usikker p√• om sum-funksjonen funker p√• sett, s√• omgjorde til liste"
"def sum_larger(numlist,n):
    storre=[]
    
    for i in range(len(numlist)):
        if numlist[i]>n:
            storre.append(numlist[i])
    
    totalt=sum(storre)
    
    return totalt";"def car_type(n_pass,wt,person):
    
    if person==True: 
        
        if n_pass<=8:
            return ""M1""
        
        elif n_pass>8 and wt<=5000:
            return ""M2""
        
        elif n_pass>8 and wt>5000:
            return ""M3""
    
    else: 
        
        if wt<=3500:
            return ""N1""
            
        elif wt>3500 and wt<=12000:
            return ""N2""
        
        elif wt>12000:
            return ""N3""";"def sum_near_whole(A):
    
    A=list(A)
    totalt=[]
    
    for i in range(A):
        
        for j in range(A[i]):
            
            if A[i][j]==int(A[i][j]):
                
                try: 
                    #legger til indeksene p√• hver side av tallet med desimaldel lik null:
                    if A[i][j+1] not in totalt:
                        totalt.append(A[i][j+1])
                    
                    if A[i][j-1] not in totalt:
                        totalt.append(A[i][j-1])
                        
                    #legger til indeksene over og under tallet med desminaldel lik null:
                    
                    if A[i+1][j] not in totalt:
                        totalt.append(A[i+1][j])
                    
                    if A[i-1][j] not in totalt:
                        totalt.append(A[i-1][j])
                
                except IndexError: # if index out of range
                    continue
                
    return sum(totalt)
                    
                    
            "
"
def sum_larger(numlist, n):
    summen = 0 
    for i in  numlist:
        if i > n: #hvis tallet i lista p√• indeks i er st√∏rre enn n,
            summen += i #vil den legges til i summen
    return summen #vil g√• gjennom l√∏kka til alle tallene i lista og lege til de som er st√∏rre enn n til summen.
    

sum_larger([2,5,4,7,3,8], 5)";"def car_type(n_pass, wt, person):
    if n_pass <= 8:
        return True, ""M1""
    elif n_pass > 8 and wt < 5000:
        return True, ""M2""
    elif n_pass > 8 and wt > 5000:
        return True, ""M3""
    
    elif n_pass == 0 and wt < 3500:
        return False, ""N2""
    elif n_pass == 0 and (3500 < wt < 12000):
        return False, ""N2""
    elif n_pass == 0 and wt > 12000:
        return False, ""N3""
        
     ";"#hvi helt tall indeks 1 i rad 2, s√• skal [1] rad 1 og rad 3, [0] og [2] rad 2

def sum_near_whole(A):
    
    
    return"
"def sum_larger(numlist,n):
    total = 0
    
    for i in range len(numlist):
        if numlist[i] > n:
            total += numlist[i]
    
    return total";"def car_type(n_pass,wt,person):
    if person == ""True"":
        if n_plass <= 9: #""utover f√∏resetet"" tolkes som m/ sj√•f√∏r, n_plasser = 9 = 8 + sj√•f√∏r (hvis tolkningen er                    feil s√• skal ""<="" v√¶re kun ""<"")
            return ""M1""
                            #hvis n_plass = 8 funker egentlig b√•de M1 og 2, men her vil den returnerer  M1
        elif n_plass >= 8: #siden det st√•r ""over 8"" tolkes det som 8 inkl sj√•f√∏r (hvis feil skal 8 v√¶re 9)
            if wt < 0:
                print(""Ugyldig vekt"") #usikker om dere √∏nsket med ugyldig paramterere, men tok det med i tilfelle
            
            elif wt < 5000:
                return ""M2""
            
           
            else:
                return ""M3""
        
        else:
            print(""Ugyldig antall personer"")
    
    elif person == ""False"":
        if wt < 0:
            print(""Ugyldig vekt"")
            
        elif wt < 3500:
            return ""N1""
            
        elif wt >= 3500 and wt < 12000:
            return ""N2""
        
        else:
            return ""N3""
            
    else:
        print(""Ugyldig, skriv True eller False p√• person"")";"def sum_near_whole(A):
    total = () #litt usikker om set hadde () eller {}, men poenget er at total skal v√¶re et set
    
    for i in range (len(A)):
        
        for j in range (len(A[i])):
            
            if A[i,j]%1 == 0:
                try:
                venstre = A[i][j-1]
                hoyre = A[i][j+1]
                oppe = A[i-1][j] 
                nede A[i+1][j]
                
                except IndexError:
                    ignore #Usikker p√• hvordan jeg skal f√• den til √• hoppe over den da hvis indexen ikke eksisterer
                    
                total.add(venstre)
                total.add(hoyre)
                total.add(oppe)
                total.add(nede) #litt usikker om hvordan set.update funker s√• det blir litt spagetti her
    
    liste = liste(total) #gj√∏re om til en liste
    total1 = sum(liste) #summere listen
    
    return total1
                
                
                
        
            "
"def sum_larger(numlist,n):
    result = 0
    for i in numlist:
        if numlist[i] > n:
            result = result + numlist[i]
    return result
            ";"def car_type(n_pass,wt.person):
    if person == True:
        if n_pass > 8:
            return M1
        elif wt < 5000:
            return M2
        else:
            return M3
    else:
        if wt < 3500:
            return N1
        elif wt < 12000:
            return N2
        else:
            return N3";"def sum_near_whole(A):     #Har gjort dette p√• den mest tungvinte m√•tten mulig, men skal funke hvis det ikke er syntax feil
    result = 0
    pos_used = []
    for i in len(A):
        for number in row:
            if (A[i][j] % 1) == 0:    #Usikker p√• om det m√• brukes 0.0 eller 0
                if i == 0:
                    if j == 0:
                        if (i+1,j) not in pos_used:
                            result = result + A[i+1][j]
                            pos_used.append((i+1,j))
                            
                        if (i,j+1) not in pos_used
                            result = result + A[i][j+1]
                            pos_used.append((i,j+1))
                            
                            
                    elif j == (len(A[i])-1):
                        if (i+1,j) not in pos_used:
                            result = result + A[i+1][j]
                            pos_used.append((i+1,j))
                            
                        if (i,j-1) not in pos_used
                            result = result + A[i][j-1]
                            pos_used.append((i,j-1))
                            
                    else:
                        if (i,j-1) not in pos_used:
                            result = result + A[i][j-1]
                            pos_used.append((i,j-1))
                        
                        if (i,j+1) not in pos_used
                            result = result + A[i][j+1]
                            pos_used.append((i,j+1))
                            
                        if (i+1,j) not in pos_used
                            result = result + A[i+1][j]
                            pos_used.append((i+1,j))
                            
                            
                            
                            
                           
                           
                if i == (len(A)-1):
                    if j == 0:
                        if (i-1,j) not in pos_used:
                            result = result + A[i-1][j]
                            pos_used.append((i-1,j))
                            
                        if (i,j+1) not in pos_used
                            result = result + A[i][j+1]
                            pos_used.append((i,j+1))
                            
                            
                    elif j == (len(A[i])-1):
                        if (i-1,j) not in pos_used:
                            result = result + A[i-1][j]
                            pos_used.append((i-1,j))
                            
                        if (i,j-1) not in pos_used
                            result = result + A[i][j-1]
                            pos_used.append((i,j-1))
                            
                    else:
                        if (i-1,j) not in pos_used:
                            result = result + A[i-1][j]
                            pos_used.append((i-1,j))
                        
                        if (i,j+1) not in pos_used
                            result = result + A[i][j+1]
                            pos_used.append((i,j+1))
                            
                        if (i,j-1) not in pos_used
                            result = result + A[i][j-1]
                            pos_used.append((i,j-1)) 
                            
                            
                if 0 < i < (len(A)-1) and (j == 0 or j == (len(A[i]-1))):
                    if j == 0:
                        if (i,j+1) not in pos_used
                            result = result + A[i][j+1]
                            pos_used.append((i,j+1))
                            
                        if (i-1,j) not in pos_used:
                            result = result + A[i-1][j]
                            pos_used.append((i-1,j))
                            
                        if (i+1,j) not in pos_used
                            result = result + A[i+1][j]
                            pos_used.append((i+1,j))
                            
                    elif j == (len(A[i]-1)):
                        
                        if (i,j-1) not in pos_used
                            result = result + A[i][j-1]
                            pos_used.append((i,j-1))
                            
                        if (i-1,j) not in pos_used:
                            result = result + A[i-1][j]
                            pos_used.append((i-1,j))
                        
                        if (i+1,j) not in pos_used
                            result = result + A[i+1][j]
                            pos_used.append((i+1,j))
                
                else:
                    
                    if (i,j-1) not in pos_used
                        result = result + A[i][j-1]
                        pos_used.append((i,j-1))
                            
                    if (i-1,j) not in pos_used:
                        result = result + A[i-1][j]
                        pos_used.append((i-1,j))
                        
                    if (i+1,j) not in pos_used
                        result = result + A[i+1][j]
                        pos_used.append((i+1,j))
                            
                    if (i,j+1) not in pos_used
                        result = result + A[i][j+1]
                        pos_used.append((i,j+1))
                    
                    
"
"def sum_larger(numlist,n):
    storre_tall=[]
    for i in range(len(numlist)):
        if numlist[i]>n:
            storre_tall.append(numlist[i])
    return sum(storre_tall)";"def car_type(n_pass,wt,person):
    if person==True:
        if n_pass=<8:
            return ""M1""
        else:
            if wt>5000:
                return ""M3""
            else:
                return ""M2""
    else:
        if wt=<3500:
            return ""N1""
        elif wt=<12000:
            return ""N2""
        else:
            return ""N3""";"def sum_near_whole(A):
    tall=[]
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][k]%1==0:
                if i==0 and k!=0 and k!=len(A[i]):
                    tall.append(A[i][k-1])
                    tall.append(A[i][k+1])
                    tall.append(A[i+1][k])
                elif i==0 and k==0:
                    tall.append(A[i][k+1])
                    tall.append(A[i+1][k])
                elif i==0 and k==len(A[i]):
                    tall.append(A[i][k-1])
                    tall.append(A[i+1][k])
    
    
    return sum(tall)
    "
"def sum_lagrer(numlist, n):
    sum = 0
    for i in range(len(numlist))
        if n < numlist[i]:
            sum += numlist[i]
    return sum";"def car_type(n_pass, wt, person):
    
    if person == True:
        if wt < 5000:
            print('M2')
        elif wt >= 5000:
            print('M3')
        else:
            print('M1')
            
    else:
        if wt < 3500:
            print('N1')
        elif wt < 12000:
            print('N2')
        else:
            print('N3')
            
    return";"import numpy as np

def sum_near_whole(A):
    sum = 0
    for i in range(len(A)):
        if A[i][1] == 0:
            sum += np.prod(A[i], i-1 and i+1)
        for j in range(len(A[i])):
            if A[i,j][1] == 0:
                sum += np.prod(A[i,j], j-1 and j+1)    
    return sum"
"def sum_larger(numlist,n):
    total = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            total += numlist[i]
    return total";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass <= 8:
            return 'M1'
        elif n_pass > 8 and wt > 5000:
            return 'M3'
        elif n_pass > 8 and wt <= 5000:
            return 'M2'
    else:
        if wt >= 12000:
            return 'N3'
        elif 3500 <= wt < 12000:
            return 'N2'
        elif wt <= 3500:
            return 'N1'";"import numpy as np

def sum_near_whole(A):
    total = 0
    
    heltall = []                   #finner alle heltall og lagrer dem i en liste som indeksen i en tuppel.
    for i in range(len(A)):
        for j in range(len(A[i])):
            if (int(A[i][j]*10)%10) == 0: 
                heltall.append((i,j))
    
    already_added = []               # lager en liste med tall som allerede er lagt til som indeksen deres.
    for i in range(len(heltall)):
        index = heltall[i]  #Finner indeksene for tallene som ligger under, over, venstre og til h√∏yre for heltallet
        kordinater_summer = [(index[0]+1, index[1]),(index[0]-1, index[1]),(index[0], index[1]-1),(index[0],index[1]+1 )]

        for p in range(len(kordinater_summer)):
            try:                                    
                if kordinater_summer[p] not in already_added:
                    total += A[kordinator_summer[p][0]][kordinator_summer[p][1]]
                    already_added.append(kordinater_summer[p])
            
            except:  
                pass
                              # Unntaksh√•ndtering om indeksen f.eks er ""out of range"".
    return total
        
                
            "
"def sum_larger(numlist, n):
    sum=0
    for num in numlist:
        if num>n:
            sum+=num";"def car_type(n_pass, wt,person):
    if (person==True): #enten M1,M2,M3
        if (n_pass<=8):
            return ""M1""
        else:
            if (wt>5000):
                return ""M3""
            else:
                return ""M4""
                
    else: #enten n1,n2,n3
        if (wt<=3500):
            return ""N1""
        else:
            if (wt<=12000):
                return ""N2""
            else:
                return ""N3""
                
#antatt at input er alltid i riktig format
        
            ";"import math
offsets = [-1, 1]

def sum_near_whole(A):
    numset=set()
    for i in range(len(A)):
        for j in range(len(A[i])):
            for off in offsets:
                #cheching if index in bounds
                if ( (i+off)>=0 and (i+off)<=len(A[i])-1):
                    if ((A[i+off][j]-math.floor(A[i+off][j]) == 0):  #then its a whole number, susceptible to rounding errors though
                        numset.add(A[i][j])
                        
                if ((j+off)>=0 and (j+off)<=len(A)-1):
                    if ((A[i][j+off]-math.floor(A[i][j+off]) == 0):  #then its a whole number, susceptible to rounding errors though
                        numset.add(A[i][j])
    sum = 0
    for n in numset:
        sum+=n
    return sum
                    
                    "
"def sum_larger(numlist, n):
    summ=0
    for i in range (len(numlist)):
        if numlist[i]>n:
            summ+=numlist[i]
    return summ ";"def car_type(n_pass, wt, person):
    if person==True:
        if n_pass<=8:
            return ""M1""
        elif n_pass>8 and wt<5000:
            return ""M2""
        elif n_pass>8 and wt>5000:
            return ""M3""
    elif person==False:
        if wt<3500:
            return ""N1""
        elif wt>3500 and wt<12000:
            return ""N2""
        elif wt>12000:
            return ""N3""";"def sum_near_whole(A):
    global A
    summ=0
    for i in range (len(A)):
        for j in range (len(A[i])):
           if A[i][j]==int(A[i][j]) and A[i][j]!=0:
                b=legg_til_rundt(i, j)
                summ+=b
    return summ
                    
def legg_til_rundt(i, j):
    summ=0
    try:
        summ+=A[i+1][j]
        A[i+1][j]=0
    except:
        pass
    try:
        summ+=A[i-1][j]
        A[i-][j]=0
    except:
        pass
    try:
        summ+=a[i][j+1]
        A[i][j+1]=0
    except:
        pass
    try:
        summ+=A[i][j-1]
        A[i][-1]=0
    except:
        pass
    return summ
    
    
    "
"def sum_larger(numlist,n):
    summ=0
    for i in range(len(numlist)):
        if i > n:
            summ+=i
    return summ";"def car_type(n_pass,wt,person):
    
    if person != ""persontransport"":
        if wt > 12000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        else:
            return ""N1""
            
    if person == ""persontransport"":
        if n_pass > 8 and wt > 5000:
            return ""M3""
        elif n_pass > 8 and wt < 5000:
            return ""M2""
        else:
            return ""M1""";"def sum_near_whole(A):
    summ = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            
    
    return summ
            "
"def sum_larger(numlist, n):
    for i in numlist:
        result = 0
        if numlist[i] <= n:
            i += 1
        else:
            result += numlist[i]
            i += 1
    return result";"def car_type(n_pass, wt, person):
    
    if person == True:
        
        if n_pass <= 8:
            return 'M1'
            
        elif (n_pass > 8) and (wt <= 5000):
            return 'M2'
            
        else:
            return 'M3'
    
    else:
        
        if wt <= 3500:
            return 'N1'
            
        elif 3500 < wt <= 12000:
            return 'N2'
        
        else:
            return 'N3'";"def sum_near_whole(A):
    
    sum = 0
    for i in A:
        if A[i] == int(A[i])
            sum += A[i-1] + A[i+1] + A[i+len(A)] + A[i-len(A)]
            
            if i == 0:
                sum -= A[i-1]
            if i == -1:
                sum -= A[i+1]
            if 0 < i< len(A):
                sum -= A[i-len(A)]
            if -1 > i > -len(A):
                sum -= A[i+len(A)]
                
            i += 1
        
        else:
            i += 1
    
    return sum"
"

def sum_larger(numlist, n):
    x = list(filter(lambda x: x > n, numlist))      #filtrerer bort alle tallene mindre enn 5
    return sum(x)";"


def car_type(n_pass, wt, person):
    if person:
        if(n_pass > 8):
            if(wt > 5000):
                return ""M3""
            else:
                return ""M2""
        return ""M1""
    else:
        if(wt > 12000): return ""N3""
        elif(wt > 3500): return ""N2""
        else: return ""N1""";"


def sum_near_whole(A):
    sum = 0
    B = A    #lager en kopi, for √• summere alle tallene
    for i, a in enumerate(A)
        for j, b in enumerate(a)
            if(b-round(b) == 0):    #hvis det er et heltall
                if i < len(A):  #Sjekker om det er et tall under.
                    sum += B[i+1, j]
                    B[i+1, j] = 0     #Setter kopien lik null slik at det ikke har noen betydning om det summeres flere ganger.
                if i > 0:   #Er det et tall over?
                    sum += B[i-1, j]
                    B[i-1, j] = 0
                if j < len(a): #summerer tallet til h√∏yre og setter korresponderende verdi i kopien til 0
                    sum += B[i, j+1]
                    B[i, j+1] = 0
                if j > 0:       #summerer tallet til venstre
                    sum += B[i, j-1]
                    B[i, j-1] = 0
    return sum
                    
                    "
"def sum_lager(numlist, n):
    summen = 0
    
    for i in range(len(numlist)):
        if numlist[i] > n:
            summen += i
        
    return i    
        ";"def car_type(n_pass, wt, person):
    
    biltype = ''
    
    if person == True: 
        if n_pass == 7:
            biltype = 'M1'
        elif n_pass > 8 and wt < 5000:
            biltype = 'M2'
        elif n_pass > 8 and wt > 5000:
            biltype = 'M3'
        
    elif person == False:
        if wt < 3500:
            biltype = 'N1'
        elif wt > 3500 and wt < 12000:
            biltype = 'N2'
        elif wt > 12000:
            biltype = 'N3'
    
    return biltype
            ";"def sum_near_whole(A):
    
    for i in range(len(A)):
        for j in range(len(i)):
            if (A[i])[j] == int:
                tall = A[i][j+1] + A[i][j-1] + A[i+1][j] + A[i-1][j]
            
            tallet = tall += tall         
                
    return tallet"
"def sum_larger(numlist,n):
    summen = 0 
    for element in numlist:
        if element > n: 
            summen += element
            return summen
sum_larger(numlist,n) #med gitte verdier ";"def car_type(n_pass,wt,person):
    temp = True
    if person == ""persontransport"":  #sjekker 
        if n_pass >= 8:
            if wt < 5000:
                return ""M1""
            else:
                return ""M3""
        else: 
            return ""M1""
    if person == ""varetransport"":
        if wt < 3500:
            return ""N1""
        elif wt >= 3500:
            if wt < 1200:
                return ""N2""
            else:
                return ""N3""
        temp = False 
    return temp
        
car_type(n_pass,wt,person)";"def sum_near_whole(A):
    summen = 0 
    for line in A:
        for ele in line:
            if line[ele]==int(line[ele]): #litt usikker p√• om det g√•r ann √• finne heltallet p√• denne m√•ten
                if line[ele]==line[0]:
                    summen += line[1]
                elif line[ele]==line[1]: 
                     summen += line[0] + line[2]
                elif line[ele]==line[-1]:
                    summen += line[-2]
        return summen
            else:
                return ""Det finnes ingen heltall i arrayet""

sum_near_whole(A)
A = np.array([])


#rakk ikke se p√• verdeiene som er over/under heltallet "
"def sum_larger(numlist, n):
    sum_ = 0
    for num in numlist:
        if num > n:
            sum_ += num
    return sum_";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass < 8:
            return ""M1""
        elif n_pass => 8 and wt <= 5000:
            return ""M2""
        elif n_pass => 8 and wt > 5000:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt <= 12000:
            return ""N2""
        else:
            return ""N3""";"def is_int(num):
    try:
        if str(num)[-1] == ""."":
            return True
        else:
            return False
    except:
        return False

def sum_near_whole(A):
    sum_ = 0
    for ind1 in range(1:len(A)):
        for ind2 in range(1:len(ind1)):
            if is_int(A[ind1-1][ind2]) or is_int(A[ind1+1][ind2]) or is_int(A[ind1][ind2-1]) or is_int(A[ind1][ind2+1]):
                sum_ += A[ind1][ind2]
    for ind2 in range(len(A[0])):
        if is_int(A[1][ind2]):
            sum_ += A[0][ind2]
    for ind2 in range(1:len(A)):
        if is_int(A[ind2][1]):
            sum_ += A[ind2][0]
    return sum_
            
            
            
#kommentar for oppgave 12: jeg mener at x arrayen for h(x) er x = np.arange(-3, 5, 0.5), ekstremt vanskelig √• se steglengden uten ruter og at oddetal ikke er inkluder i x-aksen. √ònsker gjerne forklaring p√• dette om jeg tar feil og om mulig"
"def sum_larger(numlist, n):
    result = 0
    for i in numlist:
        if i > n:
            result += i
            
    return result";"def car_types(n_pass, wt, person):
    if person == False:
        if wt > 12000:
            return ""N3""
        elif wt > 3500 and wt < 12000:
            return ""N2""
        else:
            return ""N1""
            
    else:
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt < 5000:
            return ""M2""
        else:
            return ""M3""";"def sum_near_whole(A):
    result = 0
    for rad in A:
        for tall in rad:
            if int(tall) == tall:
                result += rad[tall-1] + rad[tall+1]
                
                
    return result"
"def sum_larger(numlist, n):
    lst = []
    n = n += 0
    for i in lst:
        if item(i) in lst > n: #ville funnet alle i > n 
            return(sum(item(i))) # summert alle i (da > n)
        else:
            return(0)
    ";"def car_type(n_pass, wt, person):
    if person > 1:
        return True
        if n_pass > 8 and wt > 5000:
            return(""M3"")
        elif n_pass > 8 and wt < 5000:
            return(""M2"")
        elif n_pass > 8:
            return(""M1"")
    else:
        return False
        if wt > 12000:
            return(""N3"")
        elif 12000 < wt > 3500:
            return(""N2"")
        elif wt <= 3500:
            return(""N1"")
            

            
#Ville laget en if-setning som ga True(persontransport)/False(varetransport). Dersom True skulle den kj√∏rt koden videre til if-setningen om persontransport. False skulle kj√∏rt koden videre til if-setningen vedr√∏rende varetransport. 
     ";"import numpy as np

sum_near_whole(A):
    A = np.array([])
    for i in A:
        if i = int[i]:
            heltall = i + sum(float(#desimaltallene som omringer heltallet))
    return(heltall)"
"def sum_lagrer(numlist, n):
    summen=0
    for i in range (len(numlist)):
        if numlist[i]>n:
            summen+=numlist[i]
    return summen
#Sjekker om hvert tall i listen er st√∏rre enn n, og om det er det legges det til i summen
";"def car_type(n_pass, wt, person):
    klasse = """"
    if person:
        klasse+=""M""
        if n_pass<=8:
            klasse+=""1""
        elif wt<=5000:
            klasse+=""2""
        else:
            klasse+=""3""
    else:
        klasse+=""N""
        if wt<=3500:
            klasse+=""1""
        elif wt<=12000:
            klasse+=""2""
        else:
            klasse+=""3""
    return klasse
    
#Sjekker f√∏rst om det er personbil ved (if person)
#S√• legger jeg p√• m eller n i strengen og sjekker s√• for antall plasser og vekt";"def sum_near_whole(A):
    summen=0
    indekser=[]
    for i in range(len(A)):
        for j in range(len(A[0])):
            if i!=len(A)-1
                if A[i+1][j]==int(A[i+1][j]):
                    if [i+1,j] not in indekser:
                        indekser.append([i+1,j])
            if i!=0
                if A[i-1][j]==int(A[i-1][j]):
                    if [i-1][j] not in indekser:
                        indekser.append([i-1,j])
            if j!=len(A[0])-1
                if A[i][j+1]==int(A[i][j+1]):
                    if [i,j+1] not in indekser:
                        indekser.append([i,j+1])
            if j!=0
                if A[i][j-1]==int(A[i][j-1]):
                    if [i,j-1] not in indekser:
                        indekser.append([i,j-1])
    for i in range (len(indekser)):
        summen+=A[indekser[i][0]][indekser[i][1]]
    return summen

#Forklaring
#lager en tom liste hvor indeksne til tall ved siden av heltall skal legges inn
#Lager s√• en dobbel l√∏kke hvor jeg sjekker om ved en indeks mer eller mindre vil v√¶re
#lik int() av det samme, alts√• om det er et heltall ved siden av. Samme sjekker jeg
#for over og under.
#Jeg sjekker ogs√• at tallet ikke er i enden ved √• si at i eller j ikke skal sjekke for
#tal ved siden av om det selv er ytterst
#Legger s√• til indeksen i indekser dersom den har et heltall ved siden av og om den 
#ikke allerede er i indekser
#Til slutt finner jeg verdien til de indeksene som har heltall ved siden av, ved hjelp
#av en for l√∏kke

"
"# Assuming task means strictly larger, hence '>' not '>='
def sum_larger(numlist,n):
    tot = 0
    for num in numlist:
        if num > n:
            tot += num
    return tot";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return ""M1""
        else:
            return [""M2"", ""M3""][int(wt > 5000)]
    else:
        if wt <= 3500:
            return ""N1""
        else:
            return [""N2"", ""N3""][int(wt > 12000)]";"import numpy as np

def find_neighbours(coord, m, n):
    """"""
    Finds neighbours of given coordinate, also considering edge cases.
    coord: tuple of coordinates
    m: # rows
    n: # columns
    
    output: list of tuples (coordinates of neighbours)
    """"""
    i,j = coord
    neighbours = []
    
    # Checks edge cases, adds neighbour in all legal directions
    if i != 0:
        neighbours.append((i-1,j))
    if i != m - 1:
        neighbours.append((i+1,j))
    if j != 0:
        neighbours.append((i,j-1))
    if j != n - 1:
        neighbours.append((i,j+1))
    
    return neighbours


def sum_near_whole(A):
    summed = []                # stores all entries already counted
    m, n = np.shape(A)         # gets rows and cols
    tot = 0                    # stores sum
    
    # Loops through whole array
    for i in range(m):
        for j in range(n):
            
            # Checks if no decimal part
            if int(A[i,j]) == float(A[i,j]):
                
                # Finds neighbours
                neighbours = find_neighbours((i, j), m, n)
                
                # Checks if neighbours are already counted, adds them if not
                for nb in neighbours:
                    if nb not in summed:
                        summed.append(nb)
                        tot += A[nb[0],nb[1]]
    return tot"
"def sum_larger(numlist, n):
    summen = 0
    for item in numlist:
        if item > n:
            summen += item
    return numlist";"def car_type(n_pass,wt,person):
    #For √• slippe √• returnere flere plasser i koden lager jeg en streng-variabel som koden skal returnere til slutt
    kj√∏ret√∏y = '' 
    if person == True:
        if n_pass < 7: #M1 har bare  7 plasser utenom f√∏rersetet
            if wt < 5000:
                kj√∏ret√∏y += 'M3'
            else:
                kj√∏ret√∏y += 'M2'
        else: 
            kj√∏ret√∏y += 'M1'
    else:
        if wt < 3500:
            if wt < 12000:
                kj√∏ret√∏y += 'N3'
            else:
                kj√∏ret√∏y += 'N2'
        else:
            kj√∏ret√∏y += 'N1'
    
    return kj√∏ret√∏y
        
    ";"def sum_near_whole(A):
    summen = 0
    for i in range(len(A)):
        for j in range(len(A[i]):
            element = str(A[i][j]).split('.')
            if element[1] == ' ':
                summen += (A[i-1][j] + A[i+1][j] + A[i][j-1] + A[i][j+1]
                #Tenkte f√∏rst √• bruke set, men det hadde ikke fungert da samme verdi kan opptre andre steder i arrayen ogs√•
                if str(A[i][j+2]).split('.')[1] == ' ':
                    summen -= (A[i][j+1])*1/2
                if str(A[i][j-2]).split('.')[1] == ' ':
                    summen -= (A[i][j-1])*1/2
                if str(A[i+2][j]).split('.')[1] == ' ':
                    summen -= (A[i+1][j])*1/2
                if str(A[i-2][j]).split('.')[1] == ' ':
                    summen -= (A[i-1][j])*1/2
    return summen
        "
"

def sum_larger(numlist,n):
    for i in numlist:
        if numlist[i]>n:
            return numlist[i]
        else numlist.pop
        ";"

n_pass= #antall pasjasjerer utover sj√•f√∏r
wt= #tillat totalvekt
person= #boolsk true eller false (true persontransport, false varetransport)


def car_type(n_pass,wt,person):
    if person == true:
        if wt>5000 and n_pass>8:
            print(""M3"")
        elif wt<5000 and n_pass>8:
            print(""M2"")
        elif n_pass<8:
            print(""M1"")
            
    elif person == false:
        if wt>12000:
            print('N3')
        elif 3500<wt<12000:
            print('N2')
        elif wt<3500
    
    else:
        Print(""Pr√∏v p√• nytt ;D"")
            
    
    ";None
"import numpy as np
def sum_larger(numlist,n):
array = np.array(numlist)   #gj√∏r om listen til et array
    st√∏rre = array > n  #numpy returnerer alle verdiene i arrayet st√∏rre enn n
    summen = np.sum(st√∏rre)    #summerer det som er st√∏rre og returnerer det
    return summen";"def car_type(n_pass, wt, person):
    type = """" #antar at imputen er riktig for oppgaven
    if person:
        if n_pass <= 8: #hvis f√∏rersetet ikke inkl i n_pass
            type = ""M1""
        elif wt <= 5000:    #trenger ikke sjekke plassene lengere
            type = ""M2""
        else: #hvis den er ingen av de andre typene, m√• den v√¶re, sparer computasjon og tid, kunne hatt med betingelse... men
            type = ""M3""
    else:
        if wt <= 3500:
            type = ""N1""
        elif wt <= 12000:
            type = ""N2""
        else:
            type = ""N3""
    return type";"import numpy as np

def sum_near_whole(A):
    Liste_m_summer = []
    for i in range(len(A)):
        
        for j in range(len(A[i])):
            integer = int(A[i][j])
            if integer == A[i][j]:      #lager en liste hvor vi legger til alle omkringliggende floats til et heltall
                try:
                    Liste_m_summer.append(A[i+1][j])
                try:
                    Liste_m_summer.append(A[i-1][j])
                try:
                    Liste_m_summer.append(A[i][j+1])
                try:
                    liste_m_summer.append(A[i][j-1])
#hvis vi antok at alle floats var unike  kunne vi brukt set til √• fjerne dobbler
    #liste_m_summer=set(liste_m_summer)
#Riktigere m√•te, ville sjekket indexene til tallene i lista er like og hvis de var det, ville s√∏kt opp eller testet, antar at dette funker n√•
 # hvis vi har flere like tall (men ikke samme tallet) i liste_m_summer sjekker jeg om de har lik index i A, hvis de har det sletter jeg en av de fra liste_m_summer
    for i in range(len(Liste_m_summer)):
        for j in range(i+1,len(Liste_m_summer)):
            if liste_m_summer[i] == liste_m_summer[j]:
                if A.index(liste_m_summer[i]) == A.index(liste_m_summer[j]):
                    Liste_m_summer.pop(j)
                    
#summerer den nye listen og returnerer den
    Liste_m_summer = np.array(Liste_m_summer)
    return np.sum(Liste_m_summer)"
"import numpy as np

def sum_larger(numlist,n):
    sum_list=[]
    for i in numlist:
        if numlist[i] > n:
            sumlistsum_list.append(numlist[i])
            numlist.pop(numlist[i])
        else:
            numlist.pop(numlist[i])
    
    return np.sum(sum_list)";"def car_type(n_pass, wt, person):
    katergori=""""
    if person==False and wt<3500:
        kategori+=""N1""
    elif person==False and 3500<wt<12000:
        kategori+=""N2""
    elif person==False and wt>12000:
        kategori+=""N3""
    elif person==True and n_pass<=8:
        kategori+=""M1""
    elif person==True and n_pass>8 and wt<=5000:
        kategori+=""M2""
    else:
        kategori+=""M3""
    return kategori
    ";"import numpy as np

sum_near_whole(A):
    if i%1==0:
        
        
    np.sum"
"def sum_larger(numlist, n):
    resultat = 0
    
    for i in numlist:
        if i > n:
            resultat += i
            
    return resultat";"def car_type(n_plass, wt, person):
    
    if person == False:
        if wt > 12000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        else:
            return ""N1""
    if person == True:
        if n_plass > 8 and wt > 5000:
            return ""M3""
        elif n_plass > 8 and wt <= 5000:
            return ""M2""
        else:
            return ""M1""
    ";"def sum_near_whole(A):
    for rad in A:
        ved_siden = []
        under = []
        over = []
        for i in rad:
            if int(rad[i]) == float(rad[i]):
                try:
                    ved_siden.append(A[rad][i+1])
                except IndexError: #betyr at [rad][i] var det borterste tallet.
                    ved_siden.append(A[rad][0]) 
                    
                try:
                    under.append(A[rad+1][i])
                except IndexError:  #betyr at [rad][i] var det nederste tallet.
                    over.append(A[rad-1][i])
                
        summ = sum(ved_siden) + sum(under) + sum(over)
        
    return float(summ)
                
            "
"def sum_larger(numlist, n):
    summen = 0
    for tall in numlist:
        if tall > n:
            summen += tall
    return summen";"def car_type(n_pass, wt, person):
    if person == ""persontransport"":
        if (n_pass > 8) and (wt <= 5000):
            return ""M2""
        elif (n_pass > 8 ) and (wt > 5000):
            return ""M3""
            
        else:
            return ""M1""
            
    else:
        if wt <= 3500:
            return ""N1""
            
        elif (wt > 3500) and (wt <= 12000):
            return ""N2""
            
        else: 
            return ""N3""";"def sum_near_whole(A):
    sum = 0
    for line in A:
        for i in range(len(line)):
            if int(line[i]) % 10 == 0:
                sum += line[i+1] + line[i-1] 
    return sum
    "
"def sum_larger(numlist, n):
    s = 0
    for i in range(int(len(numlist))):
        if numlist[i] > n:
            s += numlist[i]
            
    return s";"def car_type(n_pass, wt, p):
    if p == True:
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif 3500 <= wt <= 12000:
            return ""N2""
        else: 
            return ""N3""";"miport numpy as np

def sum_near_whole(A):
    s = []
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i,j] == int(A[i,j]):
                if i == 0:
                    s.append(A[i+1,j])
                    if j == 0:
                        s.append(A[i, j+1])
                    elif j == -1:
                        s.append[A[i, j-1]]
                    else:
                        s.append[A[i, j-1]]
                        s.append(A[i, j+1])
                elif i == -1:
                    s.append(A[i-1, j])
                    if j == 0:
                        s.append(A[i, j+1])
                    elif j == -1:
                        s.append[A[i, j-1]]
                    else:
                        s.append[A[i, j-1]]
                        s.append(A[i, j+1])
                else:
                    s.append[A[i, j-1]]
                    s.append(A[i, j+1])
                    s.append(A[i-1, j])
                    s.append(A[i+1,j])
    s = np.array(s)
    return np.sum(s)
                    "
"#antar at input bare inneholder gyldige elementer
def sum_larger(numlist, n):
    summ = 0
    for i in range(len(numlist)):
        if numlist[i] > n:
            summ += numlist[i]
    
    if summ > 0:      
        return summ
    else:
        return(f'No elements in list larger than {n}')
    ";"def car_type(npass, wt, person):
    if person == True:
        if npass <= 8: #'sitteplasser i tillegg til f√∏rersetet' tolkes som 8 passasjerer + sj√•f√∏r
            ctype = 'M1'
        elif npass > 8 and wt <= 5000:
            ctype = 'M2'
        elif npass > 8 and wt > 5000:
            ctype = 'M3'
    
    if person == False:
        if wt <= 3500:
            ctype = 'N1'
        elif (3500 < wt <= 12000): #wt > 3500 and wt <= 12000
            ctype = 'N2'
        elif wt > 12000:
            ctype = 'N3'
    
    return ctype";"import numpy as np
A = #np.array([eksempel_array])

def sum_near_whole(A):
    sums = [] #liste over summer rundt heltall
    usednumbers = [] #lage en oversikt over allerede brukte numre for referanse til if-setning
    #while-loop for tall not in usednumbers? Dumt √• samle alle indeksene i samme condition, skipper all kode hvis en av indeksene er i usednumbers
    
    for i in range(len(A)): #n√∏stet liste
        for j in range(len(A[i])): #elementer i n√∏stet liste
        
            #kan jeg tilegne indeks til en variabel?
            a = A[i+1][j] #element under
            b = A[i-1][j] #element over
            c = A[i][j+1] #element til h√∏yre
            d = A[i][j-1]) #element til venstre
            
            if A[i][j] % 1 == 0: #anta at dette er korrekt definisjon p√• et heltall
            
                #anta gyldige indekser
                #men hvis ikke, try-except? eller if-elif? #ikke tid til dette, kommenter heller
                summ = 0
                
                #try:
                    if a not in usednumbers:
                        summ += a #element rad under
                        
                    if b not in usednumbers:
                        summ += b #element rad over
                        
                    if c not in usednumbers:
                        summ += c #element til h√∏yre
                        
                    if d not in usednumbers:
                        summ += d #element til venstre
                        
                    usednumbers.append(a, b, c, d)
                #except IndexError:         #hvis A[i][j] er siste element i liste vil A[i][j+1] gi feilmelding
                    #break? continue? pass?
                
                sums.append(summ)
                

                
                #try:
                 #   summ += A[i-1][j] #element rad under
                #except IndexError:
                    
                #try:
                #    summ += A[i][j+1] #element til h√∏yre
                #except IndexError:
                    
                #try:
                #    summ += A[i][j-1]) #element til venstre
                #except IndexError:
                    
                
                
                #except IndexError:
                    #if i(+/-)1 (>/<) len(A[i]):
                        #summ = posisjoner utenom de som er utenfor gyldige intervaller
                    #if j(+/-)1 (>/<) len(A[i][j]):
                    
                #samle except-clauses til en mer kompakt linje? eller bruke if {indeks} innenfor len(A[][])?
                
                #ikke bruke samme tall i summ flere ganger m√• fikses, kom tilbake senere
    return sums
        "
"def sum_larger(numlist, n):
    result = 0
    for i in numlist:
        if i > n:
            result +=i
    return result";"def car_type(n_pass, wt, person):
    if person == True:
        if wt < 5000:
            if n_pass <=8:
                return ""M1""
            else:
                return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt <= 12000:
            return ""N2""
        else:
            return ""N3""
        ";"def sum_near_whole(A):
    result = 0
    for i in A:
        for j in i:
            if str(j).endswith(""0""):
                result += i[j-1] + i[j+1] + A[i-1][j] + A[i+1][j]
                #skulle ha sjekket om j ligger i kantene, for da √• ikke inkludere de indexene som
                #ville ha ligget utenfor matrisen. Kunne ha sjekket om indexen til j er p√• starten eller slutten.
                #fks. hvis indexen til j er 0 kan vi ikke ta med leddet i[j-1]. Samme prinsippet gjelder for i
                
    return result
                
                
                
"
"def sum_larger(numlist, n):
    resultat = 0
    for i in range(len(numlist):
        if numlist[i] > n:
            resultat += numlist[i]
    return resultat
    
   
#sum_larger([2,5,4,7,3,8], 5)
# hvis dette printes vil vi f√• samme svar som eksempelet.";"def car_type(n_pass, wt, person):
    
    if person == True: #Personbil
        if n_pass <= 7: #8 seter med f√∏rersetet
            return ""M1""
        elif n_pass > 7 and wt <= 5000:
            return ""M2""
        else: 
            return ""M3""
    else: #Varetransport
        if wt <= 3500:
            return ""N1""
        elif wt > 3500 and wt <= 12000:
            return ""N2""
        else:
            return ""N3""
            
#car_type(9, 4000, True)
#Dette ville printet M2";"def sum_near_whole(A):
    summen = 0
    for i in range(len(A)):
        
        for j in range(len(A[i])):
            
            if A[i,j] == int(A[i,j]): #sjekker om float tallet har 0 som desimaltall
                
                
                if A[i,j] != A[i-1]: #sjekker om tallet er plassert helt til h√∏yre i 2Dlisten
                    summen += A[i,j+1]
                    A[i,j+1] = 0 # gj√∏r om summert tall til 0, slik at det ikke vil p√•virke summen hvis det summeres en gang til. 
                    
                if A[i,j] != A[i,0]: #sjekker om ta√∏√∏et er plassert helt til venstre i 2Dlisten. 
                    summen += A[i,j-1]
                    A[i,j-1] = 0 # gj√∏r om summert tall til 0
                    
                if A[i,j] != A[0,j]: #sjekker om tallet er plassert √∏verst i 2D listen.
                    summen += A[i-1,j]
                    A[i-1,j] = 0 # gj√∏r om summert tall til 0
                    
                if A[i,j] != A[-1,j]: #sjekker om tallet er nederst i 2D listen
                    summen += A[i+1,j]
                    A[i+1,j] = 0 # gj√∏r om summert tall til 0
    return summen
                    
#Hvis jeg ikke hadde sjekket om tallene sto i ""kantene"" av 2D listen ville dette gitt feil,
#fordi dette ville summert med tall som ikke skulle v√¶re med. 
                
                
                
                
                
                
                
            "
"def sum_larger(numlist,n):
    tall = []
    i = 0
    for element in numlist: #lager en forl√∏kke for √• komme gjennom alle tallene i lista
        if element[i] > n: #starter p√• tall p√• plassering 0, og hvis det er st√∏rre enn n s√• gjelder neste
            tall *= element[i] #lager et nytt tall som ganger tallet som var st√∏rre med n med neste. 
    return tall #det nye tallet som har alle tall > n ganget sammen
        
        ";"def car_type(n_pass,wt,person):
    if n_pass > 2 and wt>5000 and person=True: #skiller persontransport fra vare med =True
        if n_pass>8 and wt>5000:
            return(""M3"")
        elif n_pass>8 and wt<5000: 
            return(""M2"")
        else:
            return(""M1"")
            
        
    
    elif person=False: #skiller varetransport fra person med =False
        if wt<3500:
            return(""N1"")
        elif 12000>wt>3500:
            return(""N2"")
        else:
            return(""N3"")
    
    #kan kanskjer gj√∏res mer effektivt, men burde funke

    
print(car_type(n_pass,wt,person))";"def sum_near_whole(A):
    numbers = "" ""
    for i in range(len(A)):
        for j in A[i]:
            if [i,j][1] == 0: #tenker p√• i som raden og j som kolonne. 
                numbers += [i,j+1] or [i,j-1] #for √• f√• med tallene som er ved siden av heltallet
                numbers += [i+1,j] or [i-1,j] #for √• f√• med tallene over og under heltallet 
                #burde ha med noe for at et tall ikke kommer med flere ganger, men usikker p√• hva
        return numbers 
        
    #for j in A[i]:
        #if [j] == int():
            #numbers += [i+1] or [i-1]
            
            

        
    
    

 "
"def sum_larger(numlist, n):
    
    summen= 0
    
    for i in numlist:
        if i>n:
            summen+=i
    
    return summen";"def car_type(n_pass, wt, person):
    
    if person:
        if n_pass<=8:
            return ""M1""
        if wt<=5000 and n_pass>8:
            return ""M2""
        if wt>5000 and n_pass>8:
            return ""M3""
        else:
            return ""Ugyldig input.""
            
    else:
        if wt>12000:
            return ""N3""
        if wt>3500:
            return ""N2""
        if wt>0:
            return ""N1""
        else:
            return ""Ugyldig input.""";"def sum_near_whole(A):
    summen = 0
    
    for i in range(len(A)):
        for j in range(len(A[i])):
            
            if A[i,j]%1==0 and A[i,j]!=0:
                
                if i>0:
                    if A[i-1,j]%1!=0:
                        summen+=A[i-1,j]
                        A[i-1,j]=0
                if i<len(A)-1:
                    if A[i+1,j]%1!=0:
                        summen+=A[i+1,j]
                        A[i+1,j]=0
                if j>0:
                    if A[i,j-1]%1!=0:
                        summen+=A[i,j-1]
                        A[i,j-1]=0
                if j<len(A[i])-1:
                    if A[i,j+1]%1!=0:
                        summen +=A[i,j+1]
                        A[i,j+1]=0
                
    return summen"
"def sum_larger(numlist, n):
    if len(numlist) ==0:
        return 0
    result = 0
    for i in range(0, len(numlist)):
        if numlist[i] > n:
            result+= numlist[i]
    return result";"def car_type(n_pass, wt, person):
    car_type = """"
    if person:
        car_type+= ""M""
    else:
        car_type+= ""N""
        
    if person and n_pass <= 8:
        car_type+= ""1""
        
    elif person and n_pass > 8 and wt <= 5000: 
        car_type+= ""2""
        
    elif person and n_pass > 8 and wt > 5000:
        car_type += ""3""
        
    elif person == False and wt <= 3500:
        car_type += ""1""
        
    elif person == False and wt > 3500 and wt <= 12000: 
        car_type += ""2""
        
    elif person == False and wt > 12000: 
        car_type += ""3""
    
    return car_type";"def sum_near_whole(A): 
    added_coords = []
    sum = 0 
    for i in range(0, len(A)):
        for j in range(0, len(A[i])):
            if A[i][j].is_integer():
                temp = 0 
                if i == 0 and j == 0:
                    temp = A[i+1][j] + A[i][j+1]
                    sum += temp
                    added_coords.append([i,j+1], [i+1,j])
                    
                elif i == 0 and j>0 and j<len(A[i])-1:
                    if [i, j-1] not in added_coords: 
                        temp += A[i,j]
                    if [i, j+1] not in added coords:
                        temp+= A[i][j+1]
                    if [i+1, j] not in added coords: 
                        temp+= A[i+1][j]
                    sum+= temp
                    added_coords.append([i, j-1], [i, j+1], [i+1, j])
                
                elif i == 0 and j == len(A[i]) -1:
                    if [i, j-1] not in added_coords: 
                        temp += A[i][j-1]
                    if [i+1, j] not in added_coord: 
                        temp+= A[i+1][j]
                    sum+=temp
                    added_coords.append([i, j-1], [i+1, j])
                
                elif i>0 and j ==0:
                    if [i, j+1] not in added_coords: 
                        temp += A[i][j+1]
                    if [i-1, j] not in added_coords:
                        temp+= A[i-1][j]
                    if [i+1, j] not in added_coords: 
                        temp+= A[i+1][j]
                    sum+= temp
                    added_coords.append([i, j+1],[i-1, j],[i+1, j])
                
                elif i> 0 and i < len(A)-1 and j> 0 and j< len(A[i])-1:
                    if [i, j+1] not in added_coords: 
                        temp += A[i][j+1]
                    if [i-1, j] not in added_coords:
                        temp+= A[i-1][j]
                    if [i+1, j] not in added_coords: 
                        temp+= A[i+1][j]
                    if [i, j-1] not in added_coords:
                        temp+= A[i][j-1]
                    sum+= temp
                    added_coords.append([i, j+1],[i-1, j],[i+1, j],[i, j-1])
                
                elif i > 0 and i < len(A) and j == len(A[i])-1:
                    if [i-1, j] not in added_coords:
                        temp+= A[i-1][j]
                    if [i+1, j] not in added_coords: 
                        temp+= A[i+1][j]
                    if [i, j-1] not in added_coords:
                        temp+= A[i][j-1]
                    sum+= temp
                    added_coords.append([i-1, j],[i+1, j],[i, j-1])
                elif i == len(A)-1 and j == 0: 
                    if [i, j+1] not in added_coords: 
                        temp += A[i][j+1]
                    if [i-1, j] not in added_coords:
                        temp+= A[i-1][j]
                    sum+= temp
                    added_coords.append([i, j+1],[i-1, j])
                elif i == len(A)-1 and j < 0 and j< len(A[i]):
                    if [i, j+1] not in added_coords: 
                        temp += A[i][j+1]
                    if [i-1, j] not in added_coords:
                        temp+= A[i-1][j]
                    if [i, j-1] not in added_coords:
                        temp+= A[i][j-1]
                    sum+= temp
                    added_coords.append([i, j+1],[i-1, j],[i, j-1])
                else: 
                    if [i-1, j] not in added_coords:
                        temp+= A[i-1][j]
                    if [i, j-1] not in added_coords:
                        temp+= A[i][j-1]
                    sum+=temp
    return sum
    
# Veldig tungvinft m√•te √• gj√∏re det p√•. 
# Enkelte av if testene i starten er nok overfl√∏dig ettersom koordinatene ikke har blitt itterert over
# Kom ogs√• p√• underveis i kodingen at det er overfl√∏dig √• legge til koordinatene p√• nytt dersom de er i listen fra f√∏r, men dette skal ikke ha innvirkning p√• resultatet, annet enn en tregere kj√∏ring, ettersom listen blir lengre √• itterere over for √• finne ut om dem er der fra f√∏r. 


                    
                    
                
                    
                "
"def sum_larger(numlist, n):
    summen = 0
    for i in numlist:
        if i > n:
            summen += i
    return summen";"def car_type(n_pass, wt, person):
    if person == True:
        if n_pass > 8:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    else:
        if wt > 120000:
            return ""N3""
        elif wt > 3500:
            return ""N2""
        else:
            return ""N1""";"def sum_near_whole(A):
    funnet=[]
    A = list(A)
    for i in range(len(A)):
        for j in range(len(A[i])):
            if A[i][j] % 1 == 0:
                if not [i, j] in funnet:
                    funnet.append([i, j])
    
    rad = len(A)
    col = len(A[0])
    
    teller = []
    
    for k in funnet:
        if k[0] != 0:
            cand = [k[0]-1, k[1]]
            if not cand in teller:
                teller.append(cand)
        
        if k[0] != rad:
            cand = [k[0]+1, k[1]]
            if not cand in teller:
                teller.append(cand)
                
        if k[1] != 0:
            cand = [k[0], k[1]-1]
            if not cand in teller:
                teller.append(cand)
                
        if k[1] != col:
            cand = [k[0], k[1]+1]
            if not cand in teller:
                teller.append(cand)
    
    summen = 0            
    for l in teller:
        summen += A[l[0]][l[1]]
    return summen
        "
"#koden forkortet ned ved √• bruke list-comprehentions
def sum_larger(numlist, n):
    return sum([i for i in numlist if i>n])
    
#Gj√∏r det samme som koden over, bare p√• flere linjer:  
#def sum_larger(numlist, n):
#    result = 0
#    for i in numlist:
#        if i > n:
#            result += i
#    
#    return result";"def car_type(n_pass, wt, person):
    #test for persontransport
    if person == True
        if n_pass <= 8: 
            return ""M1""
        elif n_pass > 8:
            if wt <= 5000:
                return ""M2""
            else:
                return ""M3""
    #test for varetransport
    else:
        if wt <= 3500:
            return ""N1""
        elif wt > 12000:
            return ""N3""
        else:
            return ""N2""
    ";"

def sum_near_whole(A):
    #result blir et set med koordinater til verdiene som skal adderes. Slik blir det ingen duplikater av samme koordinat
    result = set()
    
    for i in range(len(A)): #G√•r gjennom hver rad
    
        for n in range(len(A[i])):              #og s√• hver kolonne
        
            if A[i][n] - int(A[i][n]) == 0:     #sjekker om tallet er et heltall
            
                if i+1 <= len(A)-1:                #sjekker om rad i+1 ikke er out of range
                    result.add((i+1, n))
                    
                if i-1 != -1:                        #sjekker om rad i-1 ikke er -1
                    result.add((i-1, n))
                    
                if n+1 <= len(A[i])-1:              #sjekker om indeks n+1 ikke er out of range
                    result.add((i, n+1))
                    
                if n-1 != -1:                        #sjekker om indeks n-1 ikke er -1
                    result.add((i, n-1))
    
    total = 0
    
    for t in result:
        total += A[t[0], t[1]]  
    
    return total"
"def sum_larger(numlist, n):
    summen= 0
    for i in numlist: #koden kj√∏rer gjennom hele num list
        if i> n: #sjekker indeks i numlist opp mot n
            summen += i #er i st√∏rre enn n plusser den i p√• summen
        else:
            return summen #hvis i er mindre enn n returnerer den kun summen
    return summen #returnerer summen av indekser i listen etter iterasjoner gjennom hele listen
    print(f""Summen av tallene i listen numlist som er st√∏rre enn n er:"", summen)";"def car_type(n_pass, wt, person):
    if person == True: #hvis dette stemmer m√• kj√∏ret√∏yet v√¶re for persontransport
        if n_pass> 8 and wt> 5000:
            return ""M3""
        elif n_pass> 8 and wt< 5000:
            return ""M2""
        else:
            return ""M1""
    else: #det er varetransport
        if wt< 3500:
            return ""N1""
        elif 3500 < wt < 12000:
            return ""N2""
        else:
            return ""N3"" 
    return car_type(n_pass, wt, person)
            #har n√• sjekket hvilke kj√∏ret√∏y det er i forhold til parameterne. koden sjekker f√∏rst om det er varetransport/ persontransport, s√• gjennom if- setningene. ";"import numpy as np

def sum_near_whole(A):
    summen=0 #starter p√• 0
    
    for element in A: #vil iterere gjennom hele A, og sjekke etter heltall
    
        if A[[i]].0== A[[i]]: #pr√∏ver √• sjekke om en indeks i et av leddene har ingen desimaler (.0)
            summen += A[[i+1]] + A[[i-1]] #vil addere leddet etter i og leddet f√∏r i, men ikke i 
            
            for rad in A: #hvis leddet er p√• rad 1 skal det ogs√• addere leddet under
            
                if A[[i]] in A[[1]]:
                    summen+= A[[2[i]]] #plusser da p√• indeks i i rad 2
                    
                elif A[[i]] in A[[-1]]: #-1 viser til siste rad, da skal leddet over ogs√• adderes
                    summen+= A[[-1[i]]]
                    
                else: #om indeksen ikke er p√• f√∏rste eller siste rad skal det addere leddet over og under
                    summen= summen + A[[i+1[i]]] + A[[i-1[i]]]

    return summen

        "
"def sum_larger(numlist,n):
    result = 0
    for tall in numlist:
        if tall > n:
            result += tall
    return result
            ";"def car_type(n_pass, wt, person):
    person == True 
    if person: 
        if n_pass <= 8:
            return ""M1""
        elif n_pass > 8 and wt < 5000: # Her antar jeg at vekta, wt, vil v√¶re oppgitt i kg.
            return ""M2""
        else:
            return ""M3""
    if not person:
        if wt < 3500:
            return ""N1""
        elif wt >= 3500 and wt < 12000:
            return ""N2""
        else: 
            return ""N3""
        ";"import numpy as np
def sum_near_whole(A):
    summen = 0
    for i in A:
        for j in A[0]:
            if A[i,j].1f == 0:
                # legge tallet som st√•r over, under eller ved siden av nb = A[i,j] til i summen
                summen += (j+1) + A[i+1,j] + (j-1) # dersom ikke j = 0
        for j in A[1,3]:
            if A[i,j].1f == 0:
                summen += (j+1) + (j-1) + A[i+1,j] + A[i-1,j]
        for j in A[4]:
            if A[i,j].1f == 0:
                 summen += (j+1) + (j-1) + A[i-1,j]
    return summen "
"def sum_larger(numlist, n):                             #definerer funksjonen
    
    sum = 0                                             #Setter startsum som 0
    
    for i in range(len(numlist)):                       #Antall ganger loop kj√∏rer
        
        if element in numlist > n:                      #hvis tallet i listen er st√∏rre enn n = 5
            sum += element                              #Summerer tall st√∏rre enn n = 5
        else:
            continue                                    #Hvis tall mindre enn n = 5 skal den fortsette til neste tall
        
    return(sum)                                         #Funksjonen returnerer sum av tall st√∏rre enn n = 5

sum_larger([2, 5, 4, 7, 3, 8], 5)                       #kaller p√• funksjonen";"def car_type(n_pass, wt, person):
    
    
    
    if n_pass <= 8 and wt > 0 and person == ""persontransport"":
        svar = ""M1""
    elif n_pass > 8 and wt <= 5000 and person == ""persontransport"":
        svar = ""M2""
    elif n_pass > 8 and wt > 5000 and person == ""persontransport"":
        svar = ""M3""
        
        
        
    elif n_pass > 0 and wt <= 3500 and person == ""varetransport"":
        svar = ""N1""
    elif n_pass > 0 and (12000 >= wt > 3500) and person == ""varetransport"":
        svar = ""N2""
    elif n_pass > 0 and wt > 12000 and person == ""varetransport"":
        svar = ""N3""
    else:
        return(""Pr√∏v igjen"")
    
    return svar
    
    
    
car_type(8, 1200, ""persontransport"")";"def sum_near_whole(A):
    
    
    
    
    
    
    
    
    "
"def sum_lager(numlist,n):
    summen=0
    for tall in range(len(numlist)-1):
        if numlist[tall]>n:
            summen+=numlist[tall]
    return summen";"def car_type(n_pass,wt,person):
    if person==True:
        if wt<3500:
            type=""N1""
        elif 12500>wt>3500:
            type=""N2""
        else:
            type=""N3""
    else:
        if n_pass>=8:
            type=""M1""
        elif n_pass>8 and wt<=5000:
            type=""M2""
        else:
            type=""M3""
    return type";"def sum_near_whole(A): #Planen for √• l√∏se oppgaven er √• sjekke om tallet er st√∏rre en en integer versjon av seg selv.                       Deretter legge til de elementene rundt i en egen liste og summere de.
    lst=[]
    for object in A:
        B=int(object)
        if A[object]==A[B] and (len(A)-object<16):
            lst.append(A[object+1],A[object-1],A[object+4],A[object-4])
            
    return(sum(lst))"
"def sum_lager(numlist, n):
    #Oppretter en variabel for summen av tallene
    summen = 0
    #Itererer gjennom lista og finner elementer som er ST√òRRE ENN (ikke lik) oppgitt variabel
    for element in numlist:
        if element > n:
            summen += element #Hvis if-l√∏kken sl√•r inn vil tallet bli lagt til i summen
    #Returnerer summen
    return summen ";"def car_type(n_pass, wt, person):
    #Avgj√∏r om det er en varebil eller personbil
    if person:
        #Sjekker om sitteplasser er over 8
        if n_pass > 8:
            #Avgj√∏r klasse utifra vekt
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
        #Siden sitteplasser er mindre eller lik 8 er det M1
        else:
            return ""M1""
    
    else:
        #Sjekker vektklasse for √• avgj√∏re kategori
        if wt > 12000:
            return ""N3""
        elif 3500 < wt <= 120000:
            return ""N2""
        else:
            return ""N1""
    ";"import numpy as np
def sum_near_whole(A):
    #For √• summere tallene m√• det itereres gjennom listene og sjekke etter heltall
    #Deretter skal tallet foran, bak, over og under (hvis de finnes) legges til i summen
    summen = 0
    for i in range(len(A)):
        element = A[i]
        for j in range(len(element)):
            if element[j] == int(element[j]): #Avgj√∏r om det er heltall
                #Sjekker plassering av heltallet og adderer vannrett
                if j == 0:
                    summen += element[1]
                elif i == len(element)-1:
                    summen += element[j-1]
                else:
                    summen += element[j-1]+element[j+1]
                #Sjekker plassering av heltallet og adderer loddrett    
                if i == 0:
                    summen += A[1, j]
                elif i == len(A)-1:
                    summen += A[i-1, j]
                else:
                    summen += A[i-1, j] + A[i+1,j]
    
    return summen
"
"def sum_larger(numlist, n):
    summ=0
    for i in numlist:
        if i>n:
            summ+=i
    return summ";"def car_type(n_pass, wt,person):
    if person==True:
        if n_pass>8:
            if wt<=5000:
                car='M2'
            else:
                car='M3'
        else:
            car='M1'
    else:
        if wt<=3500:
            car='N1'
        elif wt<=12000:
            car='N2'
        else:
            car='N3'
    return car";"def sum_near_whole(A):
    ind=set()
    for row in len(A):
        for col in len(A[row]):
            if A[row,col]%1==0:
                if row-1>-1:
                    ind+=([row-1,col],)
                if row+1<4:
                    ind+=([row-1,col],)
                if col-1>-1:
                    ind+=([row,col-1],)
                if col+1<4:
                    ind+=([row,col+1],)
    summ=0
    for indx in ind:
        row = indx[0]
        col=indx[1]
        summ+=A[row,col]
    return summ"
"def sum_larger(numlist,n):
    
    for i in numlist:
        if i >= n:
            summen += i
        else:
            i += 1
    
    return summen
    
    
print(sum_larger([2,5,4,7,3,8],5))
            ";"def car_type(n_pass,wt,person):
    
    if person == True:
        if n_pass <= 8: 
            return M1
        elif wt <= 5000:
            return M2
        else:
            return M3
    
    else:
        if wt <= 3500:
            return N1
        elif wt <= 12000:
            return N2
        else:
            return N3
    
";"def sum_near_whole(A):
    total_summen = []
    totalsum = 0
    
    for i in range(len(A)):
        for i in A:
            if i % 1 == 0:
                if A[i-1] not in total_summen:
                    total_summen.append(A[i-1])
                elif A[i+1] not in total_summen:
                    total_summen.append(A[i+1])
                else:
                    i += 1
            else:
                i += 1
                
    totalsum = sum(total_summen)
    return totalsum
"
"def sum_larger(numlist,n):
    numlist = []
    n=0
    for i in numlist:
        if i > n:
            return sum.(numlist[i])
            numlist.append(n)
sum_larger()";"
def car_type(n_pass,wt,person):
    if person==True:
        if n_pass <=8:
            return ""M1""
        elif n_pass >8 and wt<5000:
            return ""M2""
        elif n_pass > 8 and wt >5000:
            return ""M3""
    else:
        if wt<3500:
            return ""N1""
        elif 3500<wt<12000:
            return ""N2""
        elif wt>12000:
            return ""N3""
   
car_type (9,5000,True)

        ";"import numpy as np
A = np.array ([""""])
def sum_near_whole(A):
    lengde = len(A)
    for i in range (lengde):
        n=0
        if i==[""n.""]:
            return sum()
        else:
            
"
"def sum_larger(numlist,n):
    resultat = []
    k = 0
    for tall in numlist:
        if tall > n:
            k += tall
    return k";"def car_type(n_pass, wt, person):
    if person == True:                  #persontransport
        if n_pass > 8:                 #plass til mer enn 8: m2 og m3
            if wt < 5000:              #plass til mer enn 8, vekt opp til 5000
                return ""M2""
            elif: wt >= 5000:
                return ""M3""             #Plass til mer enn 8 og vekt over 5000
        elif n_pass <= 8:               #Opp til 8 personer i bilen - personbil
            return ""M1""
    
    elif person == False:               #Varetransport
        if wt < 3500:                   #Vekt under 3500: N1
            return ""N1""
        elif wt >= 3500 and wt < 12000: #Vekt mellom 3500 og 12000: N2
            return ""N2""
        elif wt >= 12000:               #vekt st√∏rre enn eller lik 12000
            return ""N3""
        
#i denne koden har jeg regnet med at dersom man skal ha vekt lik f.eks. 12000, saa skal man ha en bil som er hakket storre selv om det er lov med vekt inntil 12000 for aa vaere paa den sikre siden. ";"def sum_near_whole(A):
    n = 0
    for tall in A[i]:
        if str(tall[1]) == 0:            #Sjekker om indeks 1 i tallet er lik 0
                                #Gjorde det om til en string for √• kunne sjekke indeks 1
            nabotall_rad = A[i-1] + A[i+1]  #Bestemmer hva som er nabotall p√• samme rad
            nabotall_kol = A[i][i] #Nabotall p√• neste kolonne vil ha samme indeksplass
            
            if nabotall_kol == A[i-1]:
                n += nabotall_kol
            elif nabotall_kol == A[i+1]:
                n += nabotall_kol
            elif A[i-1] == A[i+1]:
                n += A[i-1]
            else:
                n += nabotall_rad + nabotall_kol
                
#de 4 siste elif/if/else-setningene skulle sjekke om nabotallene til heltallet var like
#eller om nabotallene til kolonnen under var lik et nabotall p√• linjen over.
#Alle nabotallene til heltallene blir lagt til i varuabelen n som blir returnert
                
    return n
        
    "
"def sum_larger(numlist,n):
    sum = 0
    
    for element in numlist:
        
    for i in range(len(numlist)):
        if numlist[i] > n:
            sum += numlist[i]
    
    return sum

sum_larger([[2,5,4,7,3,8]],5)
            
        
";"def car_type(n_pass,wt,person):
    persontransport = True
    varetransport = False
    
    if person == persontransport:
        if n_pass <= 7:
            return ""M1""
        elif n_pass > 8 and wt < 5000:
            return ""M2""
        elif n_pass > 8 and wt > 5000:
            return ""M3""
        
        else:
            person = False
            break
            
    if person != varetransport:
        if wt > 12000:
            return ""N3""
            
        elif 3500 < wt < 12000:
            return ""N2""
            
        elif wt < 3500:
            return ""N1""
        
        else:
            person = varetransport
        
        ";"def sum_near_whole(A):
    sum = []
    
    for linje in A:
        for tall in linje:
            
            
            sum.append()
            
            
            
    
            
#A er en 2D liste i et numpy array. For √• f√• til √• returnere summen av verdiene omgitt med tynne streker (vist i figuren), og at hvert tall skal bare med i summen en gang, ville jeg tatt i bruk set(). videre ville jeg gjort om alle flyttal med 0, alts√• (1.0 eller 7.0) om til int. deretter vil jeg finne for hver linje tallet ved siden av heltallet, og lagt det inn i listen sum. deretter vil jeg summere opp alle tallene i sum lister og returnere summen 
    
    
    
    return summen
    
    "
"def sum_larger(numlist, n):
    summen = 0
    for num in numlist:
        if num > n:
            summen += num
    return summen
    ";"def car_type(n_pass, wt, person):
    if person:
        if n_pass > 8:
            if wt > 5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    else:
        if wt > 12000:
            return ""N3""
        elif wt > 3500 and wt <= 12000:
            return ""N2""
        else:
            return ""N1""";"def sum_near_whole(A):
    summen = 0
    indekser = []
    for j in range(len(A)):
        for i in range(len(A[j])):
            if str(A[j][i])[-1] == ""."":    #Vi har funnet et heltall
                if A[j] == A[0]:
                    if A[j][i] == A[0][0]:
                        indekser.append([j,i+1])
                        indekser.append([j+1, i])
                    elif A[j][i] == A[0][-1]:
                        indekser.append([j,i-1])
                        indekser.append([j+1,i])
                    else: 
                        indekser.append([j,i-1])
                        indekser.append([j,i+1])
                        indekser.append([j+1,i])
                elif A[j] == A[-1]:
                    if A[j][i] == A[-1][0]:
                        indekser.append([j,i+1])
                        indekser.append([j-1, i])
                    elif A[j][i] == A[-1][-1]:
                        indekser.append([j,i-1])
                        indekser.append([j-1,i])
                    else: 
                        indekser.append([j,i-1])
                        indekser.append([j,i+1])
                        indekser.append([j-1,i])
                elif A[j][i] == A[j][0]:
                    indekser.append([j,i+1])
                    indekser.append([j-1,i])
                    indekser.append([j+1,i])
                elif A[j][i] == A[j][-1]:
                    indekser.append([j,i-1])
                    indekser.append([j-1,i])
                    indekser.append([j+1,i])
                else:
                    indekser.append([j,i+1])
                    indekser.append([j,i-1])
                    indekser.append([j-1,i])
                    indekser.append([j+1,i])
    unike_indekser = set(indekser)
    for a in indekser:
        summen += Aa
    return summen"
"def sum_lagrer(numlist, n):
    for i in range(len(numlist)):
        a = 0
        if numlist[i] > n:
            a+=numlist[i]
    return a
            ";"def car_typen(n_pass, wt, person):
    if person == 'True':
        if n_pass <= 8:
            print('M1')
        elif n_pass > 8:
            if wt <= 5000:
                print('M2')
            elif wt > 5000:
                print('M3')
    elif person == 'False':
        if wt > 1200:
            print('N3')
        elif wt <= 3500:
            print('N1')
        else:
            print('N2')";"def sum_near_whole(A):
    "
"def sum_larger(numlist, n):
    s = 0
    for num in numlist:
        if(num > n):
            s += num
            
    return s";"def car_type(n_pass, wt, person):
    result = """"
    if(person == ""persontransport""):
        result += ""M""
        if(n_pass <= 7): #7+1 sitteplasser inkl. sj√•f√∏r
            result += ""1""
        else:
            if(wt > 5000):
                result += ""3""
            else:
                result += ""2""
    elif(person == ""varetransport""):
        result  += ""N""
        if(wt <= 3500):
            result += ""1""
        elif(wt > 3500 and wt <= 12000):
            result += ""2""
        else:
            result += ""3""
    else:
        result = ""Ugyldig input""
        
    return result";"def sum_near_whole(A):
    s = 0
    summed = [] #liste over indexer som allerede er med i summen
    L = len(A)
    for i in range(L):
        for j in range(A[i]):
            #M√• f√∏rst sjekke om A[i][j] har desimaldel lik null
            if(A[i][j] == float(round(A[i][j]))):
                #Sjekker f√∏rst opp og ned, m√• sjekke at index ved siden av
                #ikke g√•r utenfor lista
                if(i+1 < L and  [i+1, j] not in summed):
                    s += A[i+1][j]
                    summed.append([i+1, j])
                if(i-1 >= 0 and [i-1, j] not in summed):
                    s += A[i-1][j]
                    summed.append([i-1, j])
                    
                #Deretter venstre og h√∏yre
                if(j+1 < len(A[i]) and [i, j+1] not in summed):
                    s += A[i][j+1]
                    summed.append([i, j+1])
                if(j-1 >= 0 and [i, j-1] not in summed):
                    s += A[i][j-1]
                    summed.append([i, j-1])
    
    return s"
"def sum_larger(numlist, n):
    sum = 0
    for x in range(len(numlist)):
        if x[n] > n:
            sum += x[n]
    return sum";"def car_type(n_pass, wt, person):
    if person == True or person == 'True':
        if n_pass <= 8:
            type = 'M1'
        elif n_pass > 8:
            if wt <= 5000:
                type = 'M2'
            elif wt > 5000:
                type = 'M3'
    else:
        if wt <= 3500:
            type = 'N1'
        elif wt > 3500 and wt < 12000:
            type = 'N2'
        else:
            type = 'N3'
    return type";"def sum_near_whole(A):
    sum = 0
    for x in A:
        for y in x
                if A[x][y][2]=='': #for √• skjekke om tegnet etter '.' er tomrom
                     #Her ville jeg lagd en if-setning som sa at det ville skjekket om den var 'nabo' med en kant, men det fikk jeg ikke til
                    sum += A[x-1][y] #Den over
                    sum += A[x+1][y] #Den under
                    sum += A[x][y+1] #Den til h√∏yre
                    sum += A[x][y-1] #Den til venstre
                        # M√•tte ogs√• lagd en kommando som sa at om den allerede var valgt, at den is√•fall ikke skulle blitt valgt igjen.
    return sum

                    "
"def sum_larger(numlist, n):
    result = 0
    for num in numlist:
        result += num if num > n else 0
    return result";"def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return ""M1""
        elif wt <= 5000:
            return ""M2""
        else:
            return ""M3""
    else:
        if wt <= 3500:
            return ""N1""
        elif wt <= 12000:
            return ""N2""
        else:
            return ""N3""
";"import numpy as np
def sum_near_whole(A):
    total = 0
    for i in range(len(A)):
        for j in range(len(A[i])):
            above = below = side1 = side2 = None
            if i > 0:
                above = A[i-1][j] % 1 == 0
            if len(A)-1 > i 
                below = A[i+1][j] % 1 == 0
            if j > 0:
                side1 = A[i][j-1] % 1 == 0
            if len(A[i])-1 > j:
                side2 = A[i][j+1] % 1 == 0
            if above or below or side1 or side2:
                total += A[i][j]
    return total
        "
"def sum_larger(numlist, n):
    for tall in numlist:
        if tall>n:
            return sum(tall)
        else:
            return None
sum_larger([2,5,4,7,3,8],5)

    ";"def car_type(n_pass,wt,person):
    if n_pass<=8 and person==True:
        return ""M1""
    elif n_pass> 8 and wt<5000 and person==True:
        return ""M2""
    elif n_pass>8 and wt>5000 and person==True:
        return ""M3""
    elif wt<3500 and person==False:
        return ""N1""
    elif wt>3500 and wt<12000 and person==False:
        return ""N2""
    elif wt>12000 and person == False:
        return ""N3""

return car_type(n_pass, wt, person)
        ";"def sum_near_whole(A):
    for tall in A:
        
        
    
    return sum(A)"
"def sum_larger(numlist,n):
    
    summen=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            summen+=numlist[i]
    
    return summen";"def car_type(n_pass, wt, person):
    
    if person==True:
        if n_pass>8:
            if wt>5000:
                svar=""M3""
            else:
                svar=""M2""
        else:
            svar=""M1""
    else:
        if wt>3500:
            if wt>12000:
                svar=""N3""
            else:
                svar=""N2""
        else:
            svar=""N1""
    return svar";"def sum_near_whole(A):
    totalsum=0
    for i in range(len(A)):
        for j in range(len(A)):
            if j==0 andi==0:
                if "". "" in A[i][j+1] or "". "" in A[i+1][j]:
                    totalsum+=A[i][j]
            elif j==0:
                if "". "" in A[i][j+1] or "". "" in A[i+1][j] or "". "" in A[i-1][j-1]:
                    totalsum+=A[i][j]
            
            elif j==len(A[i]):
                if "". "" in A[i][j-1] or "". "" in A[i+1][j] or "". "" in A[i-1][j-1]:
                    totalsum+=A[i][j]
                    
            elif i==len(A):
                if "". "" in A[i][j-1] or "". "" in A[i][j+1] or "". "" in A[i-1][j-1]:
                    totalsum+=A[i][j]
            
            elif i==len(A) and j==len(A[j]):
                if "". "" in A[i][j-1] or "". "" in A[i-1][j-1]:
                    totalsum+=A[i][j]
                    
            else:
                if "". "" in A[i][j-1] or "". "" in A[i][j+1] or "". "" in A[i+1][j] or "". "" in A[i-1][j-1]:
                    totalsum+=A[i][j]
                    
    return totalsum"
"def sum_lagrer(numlist,n):
    resultat=0
    for i in range(len(numlist)):
        if numlist[i]>n:
            resultat+=numlist[i]
    return resultat";"def car_type(n_pass, wt, person):
    bil=''
    while person==True:
        if n_pass==8:
            bil='M1'
        elif n_pass>8 and wt<5000:
            bil='M2'
        elif n_pass>8 and wt>=5000:
            bil='M3'
    while person==False:
        if wt<=3500:
            bil='N1'
        elif wt>3500 or wt<12000:
            bil='N2'
        elif wt>=12000:
            bil='N3'
    return bil";"def sum_near_whole(A):
    resultat=[]
    for i in row(A):
        if row[i]==int:
            resultat.append(row[i+1])
            if row[i-1]=True:
                resultat.append(row[i-1])
    
    for j in column(A):
        if column[j]==int:
           resultat=resultat.append(column[j][j+1])
           resultat=resultat.append(column[j][j-1])
    
    resultat=resultat.set()
    resultat=sum.resultat
    return resultat"
"def sum_larger(numlist,n):
    for i in lst(numlist[]):
        s.append(n)
        
    return
        s.pop(numlist[]>=n)
        
print(numlist[]>=n)
    
    
    ";"def car_type(n_pass,wt, person):
    
#n_pass=antall sitteplasser utover f√∏rersetet
#wt=vekt
#person: True hvis persontransport. False hvis varetransport


n=(1,10)#passasjerer

wt=(0,12000)#kg


    for i in range:
        
        
    if n_pass>=2 and wt<=3000:
        return (M1,M2, M3)
    
    elif n<=1:
    return (N1, N2, N3)
        
        


    ";"def sum_near_whole(A):
    
    
    
    
    return"
"def sum_larger(numlist, n):
    summ=0
    for tall in numlist:
        if tall>n:
            summ+=n
    return summ";"def car_type(n_pass, wt, person):
    if person:
        if n_pass>8:
            if wt>5000:
                return ""M3""
            else:
                return ""M2""
        else:
            return ""M1""
    else:
        if wt>12000:
            return ""N3""
        elif wt>3500:
            return ""N2""
        else:
            return ""N1""";"def sum_near_whole(A):
    summ=0
    rad=[]
    kolonne=[]
    brukt=[]
    for rad_i in range(len(A)):
        rad.append(rad_i)
        for kolonne_i in range(len(A[i])):
            if kolonne_i not in kolonne:
                kolonne.append(kolonne_i)
            if A[rad_i][kolonne_i]==int(A[rad_i][kolonne_i]):
                if rad_i+1 in rad:
                    if f""{rad_i+1},{kolonne_i}"" not in brukt:
                        brukt.append(f""{rad_i+1},{kolonne_i}"")
                        summ+=A[rad_i+1][kolonne_i]
                if rad_i-1 in rad:
                    if f""{rad_i-1},{kolonne_i}"" not in brukt:
                        brukt.append(f""{rad_i-1},{kolonne_i}"")
                        summ+=A[rad_i-1][kolonne_i]
                if kolonne_i+1 in kolonne:
                    if f""{rad_i},{kolonne_i+1}"" not in brukt:
                        brukt.append(f""{rad_i},{kolonne_i+1}"")
                        summ+=A[rad_i][kolonne_i+1]
                if kolonne_i-1 in kolonne:
                    if f""{rad_i},{kolonne_i-1}"" not in brukt:
                        brukt.append(f""{rad_i},{kolonne_i-1}"")
                        summ+=A[rad_i][kolonne_i-1]
    return summ"
"def sum_larger(numlist, n):
    s = 0
    
    for x in numlist:
        # Bruker en conditional expression/ternary operator fordi det
        # sparer tid og plass. For mere kompliserte uttrykk √• sjekke
        # blir det vanskelig √• lese, men i dette tilfellet er det s√• enkelt 
        # at jeg synes det er greit.
        s += x if x > n else 0
        
    return s";"# Oppgaven spessifiserer ikke noe maksvekt p√• personbil (M1) som er litt rart.
# Dermed klassifiserer programmet alle kj√∏ret√∏y med maks 8 seter som en
# personbil, selv om den f. eks. veier 10 tonn.

# Jeg antar at n√•r det st√•r ""ikke over"" s√• er det greit om kj√∏ret√∏yet
# veier akkurat maksgrensen.

def car_type(n_pass, wt, person):
    if person:
        if n_pass <= 8:
            return ""M1""
            
        if wt <= 5000:
            return ""M2""
            
        return ""M3""
        
    if wt <= 3500:
        return ""N1""
        
    if wt <= 12000:
        return ""N2""
        
    return ""N3""";"# Oppgaven nevnte ikke noe om dimensjonene p√• 2D arrayet, s√• jeg g√•r ut ifra at
# 2D arrayet ikke n√∏dvendigvis er kvadratisk. Oppgaven sa heller ikke noe om
# lengdene p√• radene s√• jeg antar at de kan v√¶re av ulik lengde. P√• grunn av
# dette velger jeg da √• bruke len(A[i]) for hver rad i tilfellet de er av ulike
# lengder. 

def sum_near_whole(A):
    summed = [] # Liste for √• holde styr p√• hvilke tall som har blitt summert
    result = 0
    
    for i in range(len(A)): # G√•r gjennom alle
        for j in range(len(A[i])): # verdiene i 2d arrayet
            if A[i, j] != int(A[i, j]): # Sjekker om en verdi ikke er et heltall
                continue # Hvis det ikke er et heltall s√• fortsett letingen
            
            # Liste med indeksene til naboene til heltallet
            neighbours = [
                (i-1, j),
                (i+1, j),
                (i, j-1),
                (i, j+1)
            ]
            
            # G√•r gjennom alle naboene til heltallet
            for pos in neighbours:
                # Sjekker om omr√•det der det burde v√¶re en nabo er finnes i 2D arrayet
                if pos[0] < 0 or pos[1] < 0 or pos[0] >= len(A) or pos[1] >= len(A[pos[0]]):
                    continue # Hvis den ikke finnes s√• hopper vi over den
                
                if pos in summed:
                    continue # Hvis vi har summert dette tallet allerede s√• g√• videre
                
                # Legger til i listen s√• vi ikke kan summerer det p√• nytt
                summed.append(pos) 
                
                result += A[pos[0], pos[1]]
                
    return result"
"def sum_lager(numlist,n)
st√∏rre_tall = """"
liste = [1,2,3,4,5,6,7,8,9]

for i in range(len(n)>= liste)):
    return st√∏rre tall += numlist(i).upper
        
    
    

";"def car_type(n_pass, wt, person)
bil_type = """"
for i in range ()";"def sum_near_whole(A)
"
